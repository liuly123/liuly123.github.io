<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开源库</title>
      <link href="/2020/03/08/Linux/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
      <url>/2020/03/08/Linux/%E5%BC%80%E6%BA%90%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-OpenCV"><a href="#1-OpenCV" class="headerlink" title="1.OpenCV"></a>1.OpenCV</h3><h4 id="1-1源码包"><a href="#1-1源码包" class="headerlink" title="1.1源码包"></a>1.1源码包</h4><p><a href="https://codeload.github.com/opencv/opencv/tar.gz/3.4.5" target="_blank" rel="noopener">opencv</a>，<a href="https://codeload.github.com/opencv/opencv_contrib/tar.gz/3.4.5" target="_blank" rel="noopener">opencv_contrib</a></p><h4 id="1-2编译安装"><a href="#1-2编译安装" class="headerlink" title="1.2编译安装"></a>1.2编译安装</h4><pre><code class="sh">sudo apt-get install build-essentialsudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-devsudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff5-dev #处理图像所需的包sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev liblapacke-devsudo apt-get install libxvidcore-dev libx264-dev #处理视频所需的包sudo apt-get install libatlas-base-dev gfortran #优化opencv功能sudo apt-get install ffmpeg#安装包解压到~目录cd ~/opencv-3.4.5mkdir buildcmake -DOPENCV_EXTRA_MODULES_PATH=/home/liuly/opencv_contrib-3.4.5/modules ..make -j3sudo make install</code></pre><h3 id="2-Eigen"><a href="#2-Eigen" class="headerlink" title="2.Eigen"></a>2.Eigen</h3><pre><code class="sh">sudo apt install libeigen3-dev</code></pre><p>3.Pangolin</p><pre><code class="sh">sudo apt install libglew-devsudo apt install ffmpeg libavcodec-dev libavutil-dev libavformat-dev libswscale-dev libavdevice-devsudo apt install libjpeg-dev libpng12-dev libtiff5-dev libopenexr-devgit clone https://github.com/stevenlovegrove/Pangolin.gitcd Pangolinmkdir buildcd buildcmake ..make -j3sudo make install</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tensorflow笔记</title>
      <link href="/2020/03/06/%E5%85%B6%E4%BB%96/Tensorflow%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/03/06/%E5%85%B6%E4%BB%96/Tensorflow%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/tensorflow/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/tensorflow/</a></p><p>需要先安装pip： <code>sudo apt install python-pip</code></p><p>选择<code>Linux</code>，<code>cp27</code>，<code>1.3.0</code>，复制代码安装</p><pre><code class="sh">pip install \  -i https://pypi.tuna.tsinghua.edu.cn/simple/ \  https://mirrors.tuna.tsinghua.edu.cn/tensorflow/linux/cpu/tensorflow-1.3.0-cp27-none-linux_x86_64.whl</code></pre><p>测试</p><pre><code class="python">pythonimport tensorflow as tftf.__version__</code></pre><p>设置vim</p><pre><code class="sh">vim ~/.vimrcset ts=4set nu</code></pre><h1 id="Tensorflow框架"><a href="#Tensorflow框架" class="headerlink" title="Tensorflow框架"></a>Tensorflow框架</h1><h4 id="计算图和会话"><a href="#计算图和会话" class="headerlink" title="计算图和会话"></a>计算图和会话</h4><pre><code class="python">#coding:utf-8import tensorflow as tfx = tf.constant([[1.0,2.0]])w = tf.constant([[3.0],[4.0]])y = tf.matmul(x,w)#x与w相乘print ywith tf.Session() as sess:#（这是一个用来计算的会话）不带with后面的，就不计算结果，就只是网络框架    print sess.run(y)</code></pre><h4 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h4><pre><code class="python">#coding:utf-8#两层简单神经网络（全连接），两输入，一输出，隐含层三个神经元import tensorflow as tf#输入层，一行两列x = tf.constant([[0.7,0.5]])#网络层的权值，一层神经元有两组连接，权值用随机数生成w1 = tf.Variable(tf.random_normal([2,3],stddev=1,seed=1))w2 = tf.Variable(tf.random_normal([3,1],stddev=1,seed=1))#前向传播过程a = tf.matmul(x,w1)#x与w1矩阵乘y = tf.matmul(a,w2)#a与w2乘#用会话计算结果with tf.Session() as sess:    init_op = tf.global_variables_initializer()    sess.run(init_op)    print sess.run(y)</code></pre><h4 id="反向传播（训练）"><a href="#反向传播（训练）" class="headerlink" title="反向传播（训练）"></a>反向传播（训练）</h4><pre><code class="python">#!/usr/bin/python2.7# coding:utf-8# 喂数据，并训练，共有32组样本# 学习目标：输入为两个随机数，两数和&lt;1时，输出1，否则输出0import tensorflow as tfimport numpyBATCH_SIZE = 8seed = 23455# 基于seed产生随机数：实例化一个随机数生成器rdm = numpy.random.RandomState(seed)# 生成32行2列的随机数作为输入X = rdm.rand(32, 2)# 从X输入的两个数小于1时，Y输出1Y = [[int(x0 + x1 &lt; 1)] for (x0, x1) in X]# 打印样本print &quot;X:\n&quot;, Xprint &quot;Y:\n&quot;, Y# 神经网络的输入输出占位x = tf.placeholder(tf.float32, shape=(None, 2))y_ = tf.placeholder(tf.float32, shape=(None, 1))# 随机生成网络权值w1 = tf.Variable(tf.random_normal([2, 3], stddev=1, seed=1))w2 = tf.Variable(tf.random_normal([3, 1], stddev=1, seed=1))# 相乘a = tf.matmul(x, w1)y = tf.matmul(a, w2)# 损失函数loss = tf.reduce_mean(tf.square(y-y_))# 反向传播（训练）方法，步长=0.001，损失函数值=losstrain_step = tf.train.GradientDescentOptimizer(0.001).minimize(loss)#train_step = tf.train.MomentumOptimizer(0.001, 0.9).minimize(loss)#train_step = tf.train.AdamOptimizer(0.001).minimize(loss)# 生成会话来用样本训练模型with tf.Session() as sess:    init_op = tf.global_variables_initializer()  # 初始化参数    sess.run(init_op)    # 打印出未经训练的模型    print&quot;w1:\n&quot;, sess.run(w1)    print&quot;w2:\n&quot;, sess.run(w2)    # 训练模型    STEPS = 3000    for i in range(STEPS):        start = (i*BATCH_SIZE) % 32  # 每次喂8组数据:0～8,8~16,16~24,24~32        end = start + BATCH_SIZE        # 喂数据训练，使用X[start,end]方式可以超出列表范围，使用X[place]不能超出索引        sess.run(train_step, feed_dict={x: X[start:end], y_: Y[start:end]})        if i % 500 == 0:            total_loss = sess.run(loss, feed_dict={x: X, y_: Y})            print(&quot;训练%d轮后，损失函数值为%g&quot; % (i, total_loss))    # 打印训练后的参数    print&quot;\n&quot;    print&quot;w1:\n&quot;, sess.run(w1)    print&quot;w2:\n&quot;, sess.run(w2)</code></pre><h2 id="神经网络优化"><a href="#神经网络优化" class="headerlink" title="神经网络优化"></a>神经网络优化</h2><h4 id="损失函数-loss-：预测值-y-与已知答案-y-的差距"><a href="#损失函数-loss-：预测值-y-与已知答案-y-的差距" class="headerlink" title="损失函数(loss)：预测值(y)与已知答案(y_)的差距"></a>损失函数(loss)：预测值(y)与已知答案(y_)的差距</h4><p>主流的有三种：</p><ul><li><strong>均方误差mes(Mean Squared Error)</strong><br>$$<br>MSE(y_,y)=\frac{\sum_{i=1}^n(y-y_)^2}{n}<br>$$</li></ul><pre><code class="python">loss_mse = tf.reduce_mean(tf.square(y-y_))</code></pre><ul><li><p><strong>交叉熵ce(Cross Entropy)</strong></p><p>表征两个概率分布之间的距离<br>$$<br>H(y_,y)=-\sum_{i=1}^n(y_*logy)<br>$$</p><pre><code class="python">loss_ce = -tf.reduce_mean(y_*tf.log(tf.clip_by_value(y, 1e-12, 1.0)))#1e-12防止值为0</code></pre><p>当y有n个可能的输出值（即n分类）时，y_与每个y的ce符合概率分布（概率的和为1），使用softmax()函数<br>$$<br>softmax(y_{i})=\frac{e^{y_{i}}}{\sum_{j=1}^{n}e^{y_{i}}}<br>$$</p><pre><code class="python">ce = tf.nn.sparse_softmax_cross_entropy_with_logits(    logits=y, labels=tf.argmax(y_, 1))lose_ce = tf.reduce_mean(ce)</code></pre></li><li><p><strong>自定义损失函数</strong></p><p>例如<br>$$<br>loss(y_,y)=\sum_{i=1}^{n}f(y_,y)<br>$$</p><p>$$<br>f(y_,y) = \left{ {\begin{array}{<em>{20}{c}}<br>{PROFIT</em>(y_ - y)\quad y &lt; y_\quad 预测值小于实际值时，误差乘上PROFIT}\<br>{COST*(y - y_)\quad y &gt;  = y_\quad {\rm{ }} 预测值大于实际值时，误差乘以COST}\end{array}} \right.<br>$$</p><pre><code class="python">loss = tf.reduce_mean(tf.where(tf.grater(y, y_), COST*(y-y_), PROFIT*(y_-y)))</code></pre></li></ul><p><strong>一个训练的示例，损失函数采用均方误差</strong></p><pre><code class="python">#!/usr/bin/python2.7# coding:utf-8# 喂数据，并训练，共有32组样本# 学习目标：Y=x1+x2，并加入随机噪声-0.05~0.05import tensorflow as tfimport numpyBATCH_SIZE = 8seed = 23455rdm = numpy.random.RandomState(seed)# 目标模型X = rdm.rand(32, 2)Y_ = [[x1+x2+(rdm.rand()/10.0-0.05)] for (x1, x2) in X]# 神经网络模型，单层，没有隐含层x = tf.placeholder(tf.float32, shape=(None, 2))y_ = tf.placeholder(tf.float32, shape=(None, 1))w1 = tf.Variable(tf.random_normal([2, 1], stddev=1, seed=1))y = tf.matmul(x, w1)# 损失函数为MSE（均方误差）loss_mse = tf.reduce_mean(tf.square(y-y_))# 训练过程为梯度下降法train_step = tf.train.GradientDescentOptimizer(0.001).minimize(loss_mse)# 生成会话，训练STEP轮with tf.Session() as sess:    init_op = tf.global_variables_initializer()    sess.run(init_op)    STEPS = 20000    for i in range(STEPS):        start = (i*BATCH_SIZE) % 32        end = start + BATCH_SIZE        sess.run(train_step, feed_dict={x: X[start:end], y_: Y_[start:end]})        if i % 500 == 0:            total_loss = sess.run(loss_mse, feed_dict={x: X, y_: Y_})            print(&quot;训练%d轮后，损失函数值为%g&quot; % (i, total_loss))            print &quot;w1为：\n&quot;, sess.run(w1)    # 打印训练后的参数    print (&quot;\n&quot;)    print &quot;w1:\n&quot;, sess.run(w1)</code></pre><h4 id="学习率-learning-rate-：每次参数更新的幅度"><a href="#学习率-learning-rate-：每次参数更新的幅度" class="headerlink" title="学习率(learning_rate)：每次参数更新的幅度"></a>学习率(learning_rate)：每次参数更新的幅度</h4><p>$$<br>W_{n_1}=W_{n}-learning_rate*\nabla<br>$$</p><p>​            ▽为损失函数的梯度(倒数)，learning_rate为常数(用户自定义的学习率)</p><p><strong>指数衰减学习率</strong><br>$$<br>learning_rate=LEARNING_RATE_BASE*{LEARNING_RATE_DECAY}^{\frac{global_step}{LEARNING_RATE_STEP}}<br>$$</p><pre><code class="python">#!/usr/bin/python2.7# coding:utf-8# 单神经元，自定义损失函数loss=(w+1)^2，学习率为0.2，w初值为5；为了使loss最小时，w的最终结果应为-1import tensorflow as tfw = tf.Variable(tf.constant(5, dtype=tf.float32))  # 神经网络loss = tf.square(w+1)  # 损失函数# 指数衰减学习率参数LEARNING_RATE_BASE = 0.1  # 最初学习率LEARNING_RATE_DECAY = 0.99  # 学习率的衰减率LEARNING_RATE_STEP = 2  # 每多少轮更新一次学习率，一般为:样本总数/BATCH_SIZEglobal_step = tf.Variable(0, trainable=False)  # 当前是第几轮# 定义学习率learning_rate = tf.train.exponential_decay(    LEARNING_RATE_BASE, global_step, LEARNING_RATE_STEP,    LEARNING_RATE_DECAY, staircase=True)# 反向传播方法train_step = tf.train.GradientDescentOptimizer(    learning_rate).minimize(loss, global_step=global_step)# 定义会话，训练40轮with tf.Session() as sess:    init_op = tf.global_variables_initializer()    sess.run(init_op)    for i in range(40):        sess.run(train_step)        # 数据打印        learning_rate_val = sess.run(learning_rate)        w_val = sess.run(w)        loss_val = sess.run(loss)        learning_rate_val = sess.run(learning_rate)        global_step_val = sess.run(global_step)        print &quot;训练%s轮后，w值为%f，loss值为%f，学习率为%s，step为%s&quot; % (            i, w_val, loss_val, learning_rate_val, global_step_val)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub常用命令</title>
      <link href="/2020/03/06/Linux/GitHub/"/>
      <url>/2020/03/06/Linux/GitHub/</url>
      
        <content type="html"><![CDATA[<h3 id="1-注册和创建储存库"><a href="#1-注册和创建储存库" class="headerlink" title="1. 注册和创建储存库"></a>1. 注册和创建储存库</h3><p><a href="https://www.jianshu.com/p/68b9e463333f" target="_blank" rel="noopener">教程</a></p><p>创建的存储库地址为：<a href="https://github.com/liuly123/ORB-SLAM2。下面以此为背景" target="_blank" rel="noopener">https://github.com/liuly123/ORB-SLAM2。下面以此为背景</a></p><h3 id="2-Ubuntu"><a href="#2-Ubuntu" class="headerlink" title="2. Ubuntu"></a>2. Ubuntu</h3><h4 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h4><pre><code class="sh">#设置用户名和邮箱git config --global user.name &quot;liuly123&quot;git config --global user.email &quot;2240057686@qq.com&quot;#生成keyssh-keygen -t rsa -C &quot;2240057686@qq.com&quot;#复制生成的ssh keycat ~/.ssh/id_rsa.pub#粘贴到网站上：登录github-&gt; Your profile -&gt; 右边Edit profile -&gt; SSH and GPG Keys-&gt; New SSH key添加</code></pre><h4 id="2-2-新建一个本地仓库"><a href="#2-2-新建一个本地仓库" class="headerlink" title="2.2 新建一个本地仓库"></a>2.2 新建一个本地仓库</h4><pre><code class="sh">cd ORB-SLAM2#初始化git init#添加github的地址，使用ssh方式可以避免每次输入密码（打开repository-&gt;clone or download -&gt; Use SSH -&gt; 复制地址）git  remote add origin git@github.com:liuly123/ORB-SLAM2.git#同步本地文件（commit）git add -Agit commit -m &#39;本次commit的说明&#39;git push origin master</code></pre><p><strong>以后每次提交更改</strong></p><pre><code class="sh">cd ORB-SLAM2git add -Agit commit -m &#39;本次commit的说明&#39;git push origin master</code></pre><h3 id="2-3其他说明"><a href="#2-3其他说明" class="headerlink" title="2.3其他说明"></a>2.3其他说明</h3><pre><code class="sh">#查看同步状态git status#强制同步（会覆盖之前的所有版本），第一次一般需要git push -u origin +master#注意：无法上传超过100M的文件#同步大文件出错的解决办法：#查看commit idgit log#回退到之前版本（本地文件也会别修改、删除）git reset --hard 9ff7cad52bce71a0fb7a57928e1673f1a4f536f1#本地与远程保持同步git pull origin master#抓取远程仓库git clone git@github.com:liuly123/Note.git</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu常用命令</title>
      <link href="/2020/03/06/Linux/Ubuntu%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/03/06/Linux/Ubuntu%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h4 id="安装Typora"><a href="#安装Typora" class="headerlink" title="安装Typora"></a>安装Typora</h4><p>地址<a href="https://support.typora.io/Typora-on-Linux/" target="_blank" rel="noopener">https://support.typora.io/Typora-on-Linux/</a></p><pre><code class="sh">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key addsudo add-apt-repository &#39;deb https://typora.io/linux ./&#39;sudo apt-get updatesudo apt-get install typora</code></pre><p>另一款remarkable</p><h4 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h4><p><a href="https://blog.csdn.net/seniusen/article/details/79815107" target="_blank" rel="noopener">链接</a></p><h4 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h4><p><a href="https://github.com/qingshuisiyuan/electron-ssr-backup" target="_blank" rel="noopener">教程</a></p><h4 id="安装搜狗拼音"><a href="#安装搜狗拼音" class="headerlink" title="安装搜狗拼音"></a>安装搜狗拼音</h4><p>地址<a href="https://pinyin.sogou.com/linux/" target="_blank" rel="noopener">https://pinyin.sogou.com/linux/</a></p><p>不要从系统设置里修改，在任务栏上修改</p><h4 id="设置rtc时间"><a href="#设置rtc时间" class="headerlink" title="设置rtc时间"></a>设置rtc时间</h4><pre><code class="sh">timedatectl set-local-rtc true</code></pre><h4 id="安装CLion"><a href="#安装CLion" class="headerlink" title="安装CLion"></a>安装CLion</h4><p><a href="https://blog.csdn.net/u010925447/article/details/73251780" target="_blank" rel="noopener">教程</a>，<a href="https://www.jetbrains.com/clion/download/#section=linux" target="_blank" rel="noopener">下载地址</a></p><p>账号：<a href="mailto:2240057686@qq.com">2240057686@qq.com</a></p><p>密码：abc12345@</p><p><a href="https://github.com/pingfangx/jetbrains-in-chinese/tree/master/CLion" target="_blank" rel="noopener">汉化</a></p><p><strong>修改字体：</strong>设置&gt;编辑器&gt;切换配色方案&gt;Color Scheme Font&gt;备用字体&gt;SimSun(已经安装windows字体)。（其他的备用字体最好也换，如Console Font）</p><p><strong>远程调试：</strong></p><p><img src="assets/image-20200113102243144.png" alt="image-20200113102243144"></p><p><strong>乱码问题：</strong>帮助-&gt;编辑自定义VM选项，添加</p><pre><code class="ini">-Dconsole.encoding=UTF-8-Dfile.encoding=UTF-8</code></pre><h4 id="添加设备文件读写权限"><a href="#添加设备文件读写权限" class="headerlink" title="添加设备文件读写权限"></a>添加设备文件读写权限</h4><pre><code class="sh">sudo usermod -a -G dialout $USERsudo chmod a+rw /dev/ttyUSB0</code></pre><h4 id="安装wps"><a href="#安装wps" class="headerlink" title="安装wps"></a>安装wps</h4><p>下载地址<a href="http://linux.wps.cn/" target="_blank" rel="noopener">http://linux.wps.cn/</a></p><h4 id="安装录屏软件"><a href="#安装录屏软件" class="headerlink" title="安装录屏软件"></a>安装录屏软件</h4><pre><code class="sh">sudo add-apt-repository ppa:maarten-baert/simplescreenrecordersudo apt updatesudo apt install simplescreenrecorder</code></pre><h4 id="安装chrome"><a href="#安装chrome" class="headerlink" title="安装chrome"></a>安装chrome</h4><pre><code class="sh">wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -echo &#39;deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main&#39; | sudo tee /etc/apt/sources.list.d/google-chrome.listsudo apt-get update sudo apt-get install google-chrome-stable</code></pre><p>或者直接<a href="https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb" target="_blank" rel="noopener">下载</a></p><h4 id="安装中国版火狐"><a href="#安装中国版火狐" class="headerlink" title="安装中国版火狐"></a>安装中国版火狐</h4><p><a href="http://www.firefox.com.cn/download/" target="_blank" rel="noopener">下载</a>，解压</p><pre><code class="sh">sudo apt remove firefoxsudo mv firefox /opt #firefox是解压得到的文件夹cd /usr/share/applicationssudo gedit firefox.desktop</code></pre><p>内容为</p><pre><code>[Desktop Entry]Name=firefoxName[zh_CN]=火狐浏览器Comment=火狐浏览器Exec=/opt/firefox/firefoxIcon=/opt/firefox/browser/chrome/icons/default/default128.pngTerminal=falseType=ApplicationCategories=Appliction;Encoding=UTF-8StartupNotify=true</code></pre><h4 id="状态栏网速"><a href="#状态栏网速" class="headerlink" title="状态栏网速"></a>状态栏网速</h4><pre><code class="sh">sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitorsudo apt-get updatesudo apt-get install indicator-sysmonitorindicator-sysmonitor &amp;#设置开机启动</code></pre><h4 id="Understand代码分析"><a href="#Understand代码分析" class="headerlink" title="Understand代码分析"></a>Understand代码分析</h4><p><a href="https://scitools.com/download/all-builds/" target="_blank" rel="noopener">https://scitools.com/download/all-builds/</a></p><p><strong>添加环境变量</strong></p><pre><code class="sh">export PATH=&quot;$PATH:/home/liuly/snap/scitools/bin/linux64&quot;</code></pre><p><strong>输入license</strong></p><p>enter liscense &gt; option &gt; use lagacy licensing &gt; 输入09E58CD1FB79</p><p><strong>添加快捷方式</strong></p><pre><code class="sh">[Desktop Entry]Name=understandType=ApplicationComment=scitools understandIcon=/home/liuly/snap/scitools/bin/linux64/understand_64.pngExec=/home/liuly/snap/scitools/bin/linux64/understand %FTerminal=falseCategories=Development;</code></pre><h4 id="安装VScode"><a href="#安装VScode" class="headerlink" title="安装VScode"></a>安装VScode</h4><p><a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">https://code.visualstudio.com/Download</a></p><p><strong>设置中文</strong></p><p>商店搜索Chinese，安装<code>适用于 VS Code 的中文（简体）语言包</code>，并设置<code>locale.json</code></p><p><strong>扩展</strong></p><p><code>C/C++</code> <code>Python</code> <code>ROS</code></p><h4 id="RoboWare"><a href="#RoboWare" class="headerlink" title="RoboWare"></a>RoboWare</h4><p><a href="https://github.com/TonyRobotics/RoboWare/tree/master/Studio" target="_blank" rel="noopener">https://github.com/TonyRobotics/RoboWare/tree/master/Studio</a></p><h4 id="修改grub主题"><a href="#修改grub主题" class="headerlink" title="修改grub主题"></a>修改grub主题</h4><p><a href="https://blog.csdn.net/w84963568/article/details/78884003" target="_blank" rel="noopener">https://blog.csdn.net/w84963568/article/details/78884003</a></p><h4 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h4><p>字体<a href="https://www.cnblogs.com/Dylansuns/p/7648002.html" target="_blank" rel="noopener">参考</a>，还有time和simhei</p><pre><code class="sh">cd /usr/share/fonts/winfontscp ~/msyh.ttf ./sudo chmod 644 *sudo mkfontscale #创建雅黑字体的fonts.scale文件，它用来控制字体旋转缩放sudo mkfontdir #创建雅黑字体的fonts.dir文件，它用来控制字体粗斜体产生sudo fc-cache -fv #建立字体缓存信息，也就是让系统认识雅黑</code></pre><h4 id="终端分屏"><a href="#终端分屏" class="headerlink" title="终端分屏"></a>终端分屏</h4><pre><code class="bash">sudo apt install terminator</code></pre><p>使用</p><pre><code>Ctrl+Shift+E    垂直分割窗口Ctrl+Shift+O    水平分割窗口    F11         全屏Ctrl+Shift+C    复制Ctrl+Shift+V    粘贴Ctrl+Shift+N    或者 Ctrl+Tab 在分割的各窗口之间切换Ctrl+Shift+X    将分割的某一个窗口放大至全屏使用Ctrl+Shift+Z    从放大至全屏的某一窗口回到多窗格界面</code></pre><h4 id="双系统蓝牙鼠标"><a href="#双系统蓝牙鼠标" class="headerlink" title="双系统蓝牙鼠标"></a>双系统蓝牙鼠标</h4><p><a href="https://www.jianshu.com/p/56f6b0dc231e" target="_blank" rel="noopener">https://www.jianshu.com/p/56f6b0dc231e</a></p><h4 id="批量修改文件夹-文件权限"><a href="#批量修改文件夹-文件权限" class="headerlink" title="批量修改文件夹/文件权限"></a>批量修改文件夹/文件权限</h4><pre><code class="sh">#当前目录下及递归find -type d|xargs chmod 755find -type f|xargs chmod 664</code></pre><h4 id="源码安装cmake"><a href="#源码安装cmake" class="headerlink" title="源码安装cmake"></a>源码安装cmake</h4><p><a href="https://cmake.org/download/" target="_blank" rel="noopener">下载</a></p><pre><code class="sh">#编译安装，不要卸载原来的tar -xzvf cmake-3.14.5.tar.gzcd cmake-3.14.5./bootstrapmakesudo make install</code></pre><h4 id="安装rtk8811cu驱动"><a href="#安装rtk8811cu驱动" class="headerlink" title="安装rtk8811cu驱动"></a>安装rtk8811cu驱动</h4><pre><code class="sh">git clone https://github.com/whitebatman2/rtl8821CUcd rtl8821CUmakesudo make installsudo modprobe 8821cu</code></pre><h4 id="修改ROS源"><a href="#修改ROS源" class="headerlink" title="修改ROS源"></a>修改ROS源</h4><pre><code class="sh">sudo sh -c &#39;echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#39;wget https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -O - | sudo apt-key add -</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB Robots Toobox</title>
      <link href="/2020/03/06/Windows/MATLAB-Robots-Toobox/"/>
      <url>/2020/03/06/Windows/MATLAB-Robots-Toobox/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li><a href="http://petercorke.com/wordpress/toolboxes/robotics-toolbox" target="_blank" rel="noopener">主页</a></li><li>R2014a安装的是RTB 9.10</li><li>解压，把<code>rvctools</code>文件夹放到<code>C:\Program Files\MATLAB\R2014a\toolbox</code></li><li>打开MATLAB&gt;设置路径&gt;添加并包含子文件夹&gt;选中<code>rvctools</code>文件夹&gt;保存</li></ol><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><pre><code class="matlab">rtbdemo</code></pre><p>或者查看<code>C:\Program Files\MATLAB\R2014a\toolbox\rvctools\robot\demos</code>和<code>C:\Program Files\MATLAB\R2014a\toolbox\rvctools\robot\examples</code></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h3 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h3><pre><code class="matlab">n=[1 1 1]; %法向量nr=1; %圆的半径为1c=[1 1 1]; %圆心的坐标theta=(0:2*pi/100:2*pi)&#39;; %theta角从0到2*pia=cross(n,[1 0 0]); %n与i叉乘，求取a向量if ~any(a) %如果a为零向量，将n与j叉乘    a=cross(n,[0 1 0]);endb=cross(n,a); %求取b向量a=a/norm(a); %单位化a向量b=b/norm(b); %单位化b向量c1=c(1)*ones(size(theta,1),1);c2=c(2)*ones(size(theta,1),1);c3=c(3)*ones(size(theta,1),1);x=c1+r*a(1)*cos(theta)+r*b(1)*sin(theta);%圆上各点的x坐标y=c2+r*a(2)*cos(theta)+r*b(2)*sin(theta);%圆上各点的y坐标z=c3+r*a(3)*cos(theta)+r*b(3)*sin(theta);%圆上各点的z坐标plot3(x,y,z)xlabel(&#39;x轴&#39;)ylabel(&#39;y轴&#39;)zlabel(&#39;z轴&#39;)</code></pre><h3 id="robot1"><a href="#robot1" class="headerlink" title="robot1"></a>robot1</h3><pre><code class="matlab">L1 = 0.1; L2 = 0.1;% 基于D-H参数创建腿关节%                    theta   d     a  alpha  links(1) = Link([    0       0    0   pi/2 ], &#39;standard&#39;);links(2) = Link([    0       0    L1   0   ], &#39;standard&#39;);links(3) = Link([    0       0   -L2   0   ], &#39;standard&#39;);% 现在创建一个机器人来代表一条腿leg = SerialLink(links, &#39;name&#39;, &#39;leg&#39;, &#39;offset&#39;, [pi/2   0  -pi/2]);% 定义步态轨迹的关键参数，沿x方向行走xf = 5; xb = -xf;   % 脚踏在地面上的前后限制y = 5;              % 脚与身体沿y轴的距离zu = 2; zd = 5;     % 上下时脚的高度% 定义脚所采用的矩形路径segments = [xf y zd; xb y zd; xb y zu; xf y zu] * 0.01;segments = [segments; segments];%pose列表tseg = [3 0.25 0.5 0.25]&#39;;tseg = [1; tseg; tseg];x = mstraj(segments, [], tseg, segments(1,:), 0.01, 0.1);%   TRAJ = MSTRAJ(P, QDMAX, TSEG, Q0, DT, TACC, OPTIONS)%   多段多轴轨迹% -  P（MxN）是通过点的矩阵，每个通过点1行，每个轴一列。最后一个点是目的地。% -  QDMAX（1xN）是轴速限制，不能超过，% -  TSEG（1xM）是每个K段的持续时间% -  Q0（1xN）是初始坐标% -  DT是时间步长% -  TACC（1x1）此加速时间应用于所有段转换% - 每个段的TACC（1xM）加速时间，TACC（i）是从段i到段i + 1的转换的加速时间。 TACC（1）也是段1开始时的加速时间。xcycle = x(100:500,:);qcycle = leg.ikine( transl(xcycle), [], [1 1 1 0 0 0], &#39;pinv&#39; );%机器人身体的矩形，宽度和高度尺寸，腿在每个角落。W = 0.1; L = 0.2;% 一点优化。我们使用了很多绘图选项来快速制作动画：关闭注释，如手腕轴、地面阴影、关节轴，没有平滑的阴影。%我们不是在每个循环中解析开关，而是在这里将它们预分解为一个plotop结构。 plotopt = {&#39;noraise&#39;, &#39;nobase&#39;, &#39;noshadow&#39;, &#39;nowrist&#39;, &#39;nojaxes&#39;, &#39;delay&#39;, 0};% 创建4条腿的机器人。每一个都是我们在上面构建的腿部机器人的克隆体，%有一个独特的名称，以及一个表示它在行走机器人身体上位置的基本变换。legs(1) = SerialLink(leg, &#39;name&#39;, &#39;leg1&#39;);legs(2) = SerialLink(leg, &#39;name&#39;, &#39;leg2&#39;, &#39;base&#39;, transl(-L, 0, 0));legs(3) = SerialLink(leg, &#39;name&#39;, &#39;leg3&#39;, &#39;base&#39;, transl(-L, -W, 0)*trotz(pi));legs(4) = SerialLink(leg, &#39;name&#39;, &#39;leg4&#39;, &#39;base&#39;, transl(0, -W, 0)*trotz(pi));% 为机器人创建固定大小的轴，并将Z正向向下设置clf; axis([-0.3 0.1 -0.2 0.2 -0.15 0.05]); set(gca,&#39;Zdir&#39;, &#39;reverse&#39;)hold on% 画出机器人的身体% patch是个底层的图形函数，用来创建补片图形对象。%一个补片对象是由其顶点坐标确定的一个或多个多边形。用户可以指定补片对象的颜色和灯光。patch([0 -L -L 0], [0 0 -W -W], [0 0 0 0], ...    &#39;FaceColor&#39;, &#39;r&#39;, &#39;FaceAlpha&#39;, 0.5)% 在轴上实例化每个机器人for i=1:4    legs(i).plot(qcycle(1,:), plotopt{:});endhold off% walk!k = 1;%A = Animate(&#39;walking&#39;);%while 1for i=1:500    legs(1).animate( gait(qcycle, k, 0,   0));    legs(2).animate( gait(qcycle, k, 100, 0));    legs(3).animate( gait(qcycle, k, 200, 1));    legs(4).animate( gait(qcycle, k, 300, 1));    drawnow    k = k+1;    %A.add();end</code></pre><h3 id="robot2"><a href="#robot2" class="headerlink" title="robot2"></a>robot2</h3><pre><code class="matlab">%串行链接操纵器包括一系列链接。 每个Link由四个D-H参数描述。%让我们定义一个简单的2链接操纵器。 第一个Link是（Link的参数为d、a、alpha）L1 = Link(&#39;d&#39;, 1, &#39;a&#39;, 2, &#39;alpha&#39;, pi/2);%可以这样引用或定义：%L1.a;% 我们确定它是一个旋转关节L1.isrevolute% 对于给定的关节角度，假设q=0.2 rad，我们可以确定链接变换矩阵L1.A(0.2)% 第二个LinkL2 = Link(&#39;d&#39;, 3, &#39;a&#39;, 4, &#39;alpha&#39;, 0)% 第三个LinkL3 = Link(&#39;d&#39;, 2, &#39;a&#39;, 3, &#39;alpha&#39;, 0)% 现在我们需要将它们连接到一个串行链接机器人操纵器bot = SerialLink([L1 L2 L3], &#39;name&#39;, &#39;my robot&#39;)% 显示的机器人对象显示了很多细节。它还具有许多特性，例如关节数bot.n% 机器人的正向运动学bot.fkine([0.2 0.3 0.4])% 最后我们可以画出我们机器人的简笔画bot.plot([0.4 0.5 0.6])</code></pre><h3 id="baxter1"><a href="#baxter1" class="headerlink" title="baxter1"></a>baxter1</h3><pre><code class="matlab">clc;clear;links = [        Revolute(&#39;d&#39;, 0.27,        &#39;a&#39;, 0.069, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2, &#39;offset&#39;, pi/2)        Revolute(&#39;d&#39;, 0.102+0.262, &#39;a&#39;, 0.069, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2)        Revolute(&#39;d&#39;, 0.103+0.271, &#39;a&#39;, 0.010, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2)        Revolute(&#39;d&#39;, 0.28,        &#39;a&#39;, 0, &#39;alpha&#39;, 0)];left =  SerialLink(links, &#39;name&#39;, &#39;Baxter LEFT&#39;, &#39;manufacturer&#39;, &#39;Rethink Robotics&#39;);right = SerialLink(links, &#39;name&#39;, &#39;Baxter RIGHT&#39;, &#39;manufacturer&#39;, &#39;Rethink Robotics&#39;);left.base = transl(0.064614, 0.25858, 0.119)*rpy2tr(0, 0, pi/4, &#39;xyz&#39;);right.base = transl(0.063534, -0.25966, 0.119)*rpy2tr(0, 0, -pi/4, &#39;xyz&#39;);%4个不同姿态的关节角qz = [0 0 0 0 0 0 0]; qr = [0 -pi/2 -pi/2 0 0 0 0]; qs = [0 0 -pi/2 0 0 0 0];qn = [0 pi/4 pi/2 0 pi/4  0 0];% left.plot(qz);% hold on;% right.plot(qz);t = [0:0.05:1];path = jtraj(qz,qr,t);%计算两种配置之间的关节空间轨迹path= [path;jtraj(qr,qs,t)];path= [path;jtraj(qs,qn,t)];path= [path;jtraj(qn,qz,t)];for q = path&#39;    hold on;    left.plot(q&#39;);    hold on;    right.plot(q&#39;);enda=0;for i = 1:1:20    a=[a;(path(i+1,2)-path(i,2))/0.05];endplot(t,a, &#39;r&#39;);hold on;    plot(t,path(:,2));</code></pre><h3 id="baxter2"><a href="#baxter2" class="headerlink" title="baxter2"></a>baxter2</h3><pre><code class="matlab">clc;clear;%加载机器人模型mdl_baxter;bot_left = left;bot_right = right;%显示（关节角度都是0）left_theta = [0 0 0 0 0 0 0];right_theta = [0 0 0 0 0 0 0];bot_left.plot(left_theta);hold on;bot_right.plot(right_theta);%正运动学（齐次变换）disp(&#39;左手末端位姿：&#39;);left_p0=bot_left.fkine(left_theta)%关节状态插值t = [0:0.05:1];%时间%qz、qr、qs、qn是已经定义好的关节状态%left_path是关节状态的插值，形成连贯动作q1=[0.1 0.2 0.3 0.4 0.5 0.6 0.7];q2=[0.3 0.4 0.5 0.6 0.7 0.3 0.2];q3=[0.5 0.6 0.7 0.1 0.5 0.9 1.0];left_path = jtraj(qz,qr,t);left_path= [left_path;jtraj(q1,q2,t)];left_path= [left_path;jtraj(q2,q3,t)];left_path= [left_path;jtraj(q3,q1,t)];for q = left_path&#39;    hold on;    left.plot(q&#39;);    hold on;    right.plot(q&#39;);end</code></pre><h3 id="避障"><a href="#避障" class="headerlink" title="避障"></a>避障</h3><pre><code class="matlab">%末端直线运动，并避开障碍点clc;clear;L1 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L2 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.4318, &#39;alpha&#39;, 0);L3 = Link(&#39;d&#39;, 0.15005, &#39;a&#39;, 0.0203, &#39;alpha&#39;, -pi/2);L4 = Link(&#39;d&#39;, 0.4318, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L5 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.2, &#39;alpha&#39;, -pi/2);bot = SerialLink([L1 L2 L3 L4 L5], &#39;name&#39;, &#39;my robot&#39;);T1 = transl(0.2, -0.3, 0.0);T2 = transl(0.4, 0.3, 0.2);Tx = transl(0.3, 0.0, 0.1);T = ctraj(T1, T2, 50);for i=1:1:50    d=sqrt((T(1,4,i)-0.3).^2+(T(2,4,i)-0).^2+(T(3,4,i)-0.1).^2); if(d&lt;0.014)     T(1,4,i)=T(1,4,i)+sqrt(0.0002-d.^2);     T(2,4,i)=T(2,4,i)+sqrt(0.0002-d.^2);     T(3,4,i)=T(3,4,i)+sqrt(0.0002-d.^2); endendq0=[0 0 0 0 0];M=[1 1 1 1 1 0];q = ikine(bot,T,q0,M);aplot=zeros(50,3); aa=bot.fkine(q); for i=1:1:50     aaa=aa(:,:,i);     aplot(i,:)=[aaa(1,4),aaa(2,4),aaa(3,4)]; endplot3(aplot(2:50,1),aplot(2:50,2),aplot(2:50,3) ); hold on;bot.plot(q);hold onplot3(0.3 ,0 ,0.1,&#39;r*&#39;);</code></pre><h3 id="w3"><a href="#w3" class="headerlink" title="w3"></a>w3</h3><pre><code class="matlab">%单机械臂末端直线运动，并避开障碍点使用pid控制方法clc;clear;L1 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L2 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.4318, &#39;alpha&#39;, 0);L3 = Link(&#39;d&#39;, 0.11505, &#39;a&#39;, 0.0203, &#39;alpha&#39;, -pi/2);L4 = Link(&#39;d&#39;, 0.4318, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L5 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.2, &#39;alpha&#39;, -pi/2);r1 = SerialLink([L1 L2 L3 L4 L5], &#39;name&#39;, &#39;机械臂1&#39;);T1 = transl(0.2, -0.3, 0.0);        %起始坐标矩阵T2 = transl(0.6, 0.3, 0.2);         %终点坐标矩阵Tx = transl(0.3, 0.0, 0.1);         %假定中点为障碍，需要绕过T = ctraj(T1, T2, 150);              % 直线轨迹规划，150个控制点kp=1;ki=0.7;kd=0; sum=0;d1 = zeros(150,1);%d2 = zeros(150,1);d3 = zeros(150,1);d4 = zeros(150,1);          %存储误差量 for i=1:1:150    d=sqrt((T(1,4,i)-0.6).^2+(T(2,4,i)-0).^2+(T(3,4,i)-0.1).^2);    d1(i,:) = d;  %记录整个规划过程距离障碍物距离    if(d &lt;= 0.07)        d3(i,:) = i;            %存在障碍物的范围    end endd3(d3==0) = [];  [m1,n1] = size(d3);m2 = d3(1,:);m3 = d3(m1,:);          %108-153障碍物范围% d2 = zeros(m1+1,1);     %创建空向量，存储避障信息for i=1:1:150 if((m2&lt;= i)&amp;&amp;(i &lt;= m3))             %进入避障过程    d=sqrt((T(1,4,i)-0.6).^2+(T(2,4,i)-0).^2+(T(3,4,i)-0.1).^2);    n1 = [0.04,-0.02,0];                 %方向向量    n2 = [-0.04,0.02,0];     error = d - 0.07;                                   % 误差 输入-输出    d1(i,:) = d;        %距障碍距离    d4(i,:)=error;    if(error &lt;= 0)           %内%        d2(1,:) = 0;%        d2(i-m2+2,:) = error;%        delta = d2(i-m2+2,:)-d2(i-m2+1,:);    %        sum = sum + error;%        out=(kp*error+ki*sum+kd*delta)*n;                   sum = sum + error;         out=(kp*error+ki*sum)*n1;%          T(1,4,i)=T(1,4,i)+out(1);%          T(2,4,i)=T(2,4,i)+out(2);%          T(3,4,i)=T(3,4,i)+out(3);            %修正    end    if(error &gt; 0)           %外         sum = sum + error;         out=(kp*error+ki*sum)*n2;%          T(1,4,i)=T(1,4,i)+out(1);%          T(2,4,i)=T(2,4,i)+out(2);%          T(3,4,i)=T(3,4,i)+out(3);               end    T(1,4,i+1)=T(1,4,i)+out(1);    T(2,4,i+1)=T(2,4,i)+out(2);    T(3,4,i+1)=T(3,4,i)+out(3);   %将修正后的点储存               endendq0=[0 0 0 0 0];M=[1 1 1 1 1 0];theta = ikine(r1,T,q0,M);        %反向运动学，关节角度矩阵aplot=zeros(150,3);aa=r1.fkine(theta);                     %正解，末端姿态坐标矩阵 for i=1:1:150    position = transl(aa);          %末端空间坐标矩阵（xyz）    aplot(i,:)=[position(i,1),position(i,2),position(i,3)];  end plot3(aplot(:,1),aplot(:,2),aplot(:,3),&#39;LineWidth&#39;,2 );  hold on; plot3(0.6 ,0 ,0.1,&#39;r*&#39;); hold on; r1.plot(theta); hold on figure(2); plot(d1,&#39;b&#39;); title(&#39;末端距障碍物距离&#39;); hold on; figure(3); plot(d4,&#39;r&#39;); title(&#39;理想轨迹误差&#39;);</code></pre><h3 id="匀减速"><a href="#匀减速" class="headerlink" title="匀减速"></a>匀减速</h3><pre><code class="matlab">%匀加速运动clc;clear;links = [        Revolute(&#39;d&#39;, 0.27,        &#39;a&#39;, 0.069, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2, &#39;offset&#39;, pi/2)        Revolute(&#39;d&#39;, 0.102+0.262, &#39;a&#39;, 0.069, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2)        Revolute(&#39;d&#39;, 0.103+0.271, &#39;a&#39;, 0.010, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2)        Revolute(&#39;d&#39;, 0.28,        &#39;a&#39;, 0, &#39;alpha&#39;, 0)];left =  SerialLink(links, &#39;name&#39;, &#39;Baxter LEFT&#39;, &#39;manufacturer&#39;, &#39;Rethink Robotics&#39;);right = SerialLink(links, &#39;name&#39;, &#39;Baxter RIGHT&#39;, &#39;manufacturer&#39;, &#39;Rethink Robotics&#39;);left.base = transl(0.064614, 0.25858, 0.119)*rpy2tr(0, 0, pi/4, &#39;xyz&#39;);right.base = transl(0.063534, -0.25966, 0.119)*rpy2tr(0, 0, -pi/4, &#39;xyz&#39;);%4个不同姿态的关节角qz = [0 0 0 0 0 0 0]; qr = [0 -pi/2 -pi/2 0 0 0 0]; qs = [0 0 -pi/2 0 0 0 0];qn = [0 pi/4 pi/2 0 pi/4  0 0];t = [0:0.01:1];[,len]=length(t);path=zeros(len,7);a1=2*(qr(1,2)-qz(1,2));%角加速度a2=2*(qr(1,3)-qz(1,3));ddd=zeros(len,3);bbb=zeros(len,3);for i = 1:1:len    tt=t(1,i);    q=[0 (a1*tt*tt)/2 (a2*tt*tt)/2 0 0 0 0];%每过1/100s更新的角度量    path(i,:)=q;    zz=left.fkine(q);   ddd(i,:)=[zz(1,4),zz(2,4),zz(3,4)];    xx=right.fkine(q);   bbb(i,:)=[xx(1,4),xx(2,4),xx(3,4)];endplot3(ddd(:,1),ddd(:,2),ddd(:,3));hold on;plot3(bbb(:,1),bbb(:,2),bbb(:,3));hold on;% plot(t,path(:,2));% figure(2);for q = path&#39;    hold on;    left.plot(q&#39;);    hold on;    right.plot(q&#39;);end</code></pre><h3 id="匀速"><a href="#匀速" class="headerlink" title="匀速"></a>匀速</h3><pre><code class="matlab">%匀速运动clc;clear;links = [        Revolute(&#39;d&#39;, 0.27,        &#39;a&#39;, 0.069, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2, &#39;offset&#39;, pi/2)        Revolute(&#39;d&#39;, 0.102+0.262, &#39;a&#39;, 0.069, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2)        Revolute(&#39;d&#39;, 0.103+0.271, &#39;a&#39;, 0.010, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2)        Revolute(&#39;d&#39;, 0.28,        &#39;a&#39;, 0, &#39;alpha&#39;, 0)];left =  SerialLink(links, &#39;name&#39;, &#39;Baxter LEFT&#39;, &#39;manufacturer&#39;, &#39;Rethink Robotics&#39;);right = SerialLink(links, &#39;name&#39;, &#39;Baxter RIGHT&#39;, &#39;manufacturer&#39;, &#39;Rethink Robotics&#39;);left.base = transl(0.064614, 0.25858, 0.119)*rpy2tr(0, 0, pi/4, &#39;xyz&#39;);right.base = transl(0.063534, -0.25966, 0.119)*rpy2tr(0, 0, -pi/4, &#39;xyz&#39;);%4个不同姿态的关节角qz = [0 0 -pi/2 0 0 0 0]; qr = [0 -pi/2 0 0 0 0 0]; qs = [0 0 -pi/2 0 0 0 0];qn = [0 pi/4 pi/2 0 pi/4  0 0];t = [0:0.01:1];[,len]=length(t);path=zeros(len,7);a1=(qr(1,2)-qz(1,2))/len;%角速度a2=(qr(1,3)-qz(1,3))/len;for i = 1:1:len    q=[0 a1*i a2*i 0 0 0 0];%每过1/100s更新的角度量    path(i,:)=q;    %path= [path;q];endfor q = path&#39;    hold on;    left.plot(q&#39;);    hold on;    right.plot(q&#39;);endfigure(2);plot(t,path(:,2));</code></pre><h3 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h3><pre><code class="matlab">%末端直线运动clc;clear;L1 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L2 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.4318, &#39;alpha&#39;, 0);L3 = Link(&#39;d&#39;, 0.15005, &#39;a&#39;, 0.0203, &#39;alpha&#39;, -pi/2);L4 = Link(&#39;d&#39;, 0.4318, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L5 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.2, &#39;alpha&#39;, -pi/2);bot = SerialLink([L1 L2 L3 L4 L5], &#39;name&#39;, &#39;my robot&#39;);T1 = transl(0.2, -0.3, 0.0);T2 = transl(0.4, 0.3, 0.2);T = ctraj(T1, T2, 50);q0=[0 0 0 0 0];M=[1 1 1 1 1 0];q = ikine(bot,T,q0,M);aplot=zeros(50,3); aa=bot.fkine(q); for i=1:1:50     aaa=aa(:,:,i);     aplot(i,:)=[aaa(1,4),aaa(2,4),aaa(3,4)]; endplot3(aplot(2:50,1),aplot(2:50,2),aplot(2:50,3) ); hold on;bot.plot(q);</code></pre><h3 id="作业1"><a href="#作业1" class="headerlink" title="作业1"></a>作业1</h3><pre><code class="matlab">%末端直线运动，在障碍点处做圆弧运动clc;clear;L1 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L2 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.4318, &#39;alpha&#39;, 0);L3 = Link(&#39;d&#39;, 0.15005, &#39;a&#39;, 0.0203, &#39;alpha&#39;, -pi/2);L4 = Link(&#39;d&#39;, 0.4318, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L5 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.2, &#39;alpha&#39;, -pi/2);bot = SerialLink([L1 L2 L3 L4 L5], &#39;name&#39;, &#39;my robot&#39;);T1 = transl(0.2, -0.3, 0.0);T2 = transl(0.4, 0.3, 0.2);Tx = transl(0.3, 0.0, 0.1);T = ctraj(T1, T2, 50);%判断离障碍点的距离index1=0;index2=0;%待修正轨迹的起点和终点for i=1:1:50    d=sqrt((T(1,4,i)-0.3).^2+(T(2,4,i)-0).^2+(T(3,4,i)-0.1).^2);    if(d&lt;0.014)        if index1==0           index1=i;        end        index2=i;     endend%替换成圆弧n=[0 1 -3]; %法向量n（与直线叉积为0即可）r=0.014; %圆的半径为1c=[0.3, 0.0, 0.1]; %圆心的坐标theta1=pi/10;theta=(theta1:pi/20:theta1+pi)&#39;; %theta角从0到2*pia=cross(n,[1 0 0]); %n与i叉乘，求取a向量if ~any(a) %如果a为零向量，将n与j叉乘    a=cross(n,[0 1 0]);endb=cross(n,a); %求取b向量a=a/norm(a); %单位化a向量b=b/norm(b); %单位化b向量c1=c(1)*ones(size(theta,1),1);c2=c(2)*ones(size(theta,1),1);c3=c(3)*ones(size(theta,1),1);x=c1+r*a(1)*cos(theta)+r*b(1)*sin(theta);%圆上各点的x坐标y=c2+r*a(2)*cos(theta)+r*b(2)*sin(theta);%圆上各点的y坐标z=c3+r*a(3)*cos(theta)+r*b(3)*sin(theta);%圆上各点的z坐标TT=T(:,:,1:index1-1);%TT赋值前一段线段for i =1:1:size(x,1)%TT赋值圆弧段    TT(:,:,index1-1+i)=transl(x(i),y(i),z(i));endzz=size(TT,3);for i=1:1:(50-index2)%TT赋值后一段线段    TT(:,:,zz+i)=T(:,:,index2+i);end%逆运动学q0=[0 0 0 0 0];M=[1 1 1 1 1 0];q = ikine(bot,TT,q0,M);%画出末端轨迹线T_size=size(TT,3);%姿态数量bot_end=zeros(T_size,3);%用于存放末端位置 T_f=bot.fkine(q);%正运动学计算 for i=1:1:T_size%计算的位姿结果赋值     tmp=T_f(:,:,i);     bot_end(i,:)=[tmp(1,4),tmp(2,4),tmp(3,4)]; endplot3(bot_end(2:T_size,1),bot_end(2:T_size,2),bot_end(2:T_size,3));%画出轨迹线 hold on; %画出障碍点plot3(0.3 ,0 ,0.1,&#39;r*&#39;); hold on; %画出运动过程bot.plot(q);</code></pre><h3 id="作业2"><a href="#作业2" class="headerlink" title="作业2"></a>作业2</h3><pre><code class="matlab">clc;clear;L1 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L2 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.4318, &#39;alpha&#39;, 0);L3 = Link(&#39;d&#39;, 0.15005, &#39;a&#39;, 0.0203, &#39;alpha&#39;, -pi/2);L4 = Link(&#39;d&#39;, 0.4318, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L5 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.2, &#39;alpha&#39;, -pi/2);bot = SerialLink([L1 L2 L3 L4 L5], &#39;name&#39;, &#39;my robot&#39;);%目标轨迹是一条线段T1 = transl(0.2, -0.3, 0.0);%起始点T2 = transl(0.4, 0.3, 0.2);%目标点%障碍轨迹是穿过目标轨迹的线段，障碍点沿障碍点轨迹匀速穿过目标轨迹T3 = transl(0.28, 0.01, 0.1);%障碍起始点T4 = transl(0.32, -0.01, 0.1);%障碍目标点%假设时间序列有120个%障碍轨迹线，来回运动Tb=ctraj(T4,T3,20);Tb2=ctraj(T3,T4,20);Tb3=ctraj(T4,T3,20);Tb4=ctraj(T3,T4,20);Tb5=ctraj(T4,T3,20);Tb6=ctraj(T3,T4,20);for i=1:1:20    Tb(:,:,20+i)=Tb2(:,:,i);endfor i=1:1:20    Tb(:,:,40+i)=Tb3(:,:,i);endfor i=1:1:20    Tb(:,:,60+i)=Tb4(:,:,i);endfor i=1:1:20    Tb(:,:,80+i)=Tb5(:,:,i);endfor i=1:1:20    Tb(:,:,100+i)=Tb6(:,:,i);end Tb_size=size(Tb,3); for i=1:1:Tb_size     tmp=Tb(:,:,i);     Tb_end(i,:)=[tmp(1,4),tmp(2,4),tmp(3,4)]; end%目标轨迹线 T=ctraj(T1,T2,120); %避障过程 Kp=8; Ki=0.3; sum=0;%pid的积分项 for i=1:1:120    d=sqrt((T(1,4,i)-Tb(1,4,i)).^2+(T(2,4,i)-Tb(2,4,i)).^2+(T(3,4,i)-Tb(3,4,i)).^2);%末端离障碍点的距离    if(d&lt;0.06)        n=[0.04,-0.02,0];%避障方向向量        %pid控制，跟踪量为以障碍点为圆心的球体面        error=d-0.06;        sum=sum+error;        out=(Kp*error+Ki*sum)*n;        T(1,4,i)=T(1,4,i)+out(1);        T(2,4,i)=T(2,4,i)+out(2);        T(3,4,i)=T(3,4,i)+out(3);     endend%逆运动学解算q0=[0 0 0 0 0];M=[1 1 1 1 1 0];q = ikine(bot,T,q0,M);%显示机械臂和障碍物的运动过程for i=1:1:119    %hold off;    bot.plot(q(i,:));    plot3(Tb_end(i,1),Tb_end(i,2),Tb_end(i,3) ,&#39;r*&#39;);endhold on;bot.plot(q(120,:));plot3(Tb_end(120,1),Tb_end(120,2),Tb_end(120,3) ,&#39;r*&#39;);%画出末端曲线T_end=zeros(size(T,3),3); T_f=bot.fkine(q); for i=1:1:size(T,3)     tmp=T_f(:,:,i);     T_end(i,:)=[tmp(1,4),tmp(2,4),tmp(3,4)]; endplot3(T_end(2:size(T,3),1),T_end(2:size(T,3),2),T_end(2:size(T,3),3) );plot3(Tb_end(2:size(T,3),1),Tb_end(2:size(T,3),2),Tb_end(2:size(T,3),3),&#39;r&#39; ); hold on;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
