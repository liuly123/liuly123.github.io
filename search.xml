<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开源库</title>
      <link href="/2020/03/08/Linux/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
      <url>/2020/03/08/Linux/%E5%BC%80%E6%BA%90%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-OpenCV"><a href="#1-OpenCV" class="headerlink" title="1.OpenCV"></a>1.OpenCV</h3><h4 id="1-1源码包"><a href="#1-1源码包" class="headerlink" title="1.1源码包"></a>1.1源码包</h4><p><a href="https://codeload.github.com/opencv/opencv/tar.gz/3.4.5" target="_blank" rel="noopener">opencv</a>，<a href="https://codeload.github.com/opencv/opencv_contrib/tar.gz/3.4.5" target="_blank" rel="noopener">opencv_contrib</a></p><h4 id="1-2编译安装"><a href="#1-2编译安装" class="headerlink" title="1.2编译安装"></a>1.2编译安装</h4><pre><code class="sh">sudo apt-get install build-essentialsudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-devsudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff5-dev #处理图像所需的包sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev liblapacke-devsudo apt-get install libxvidcore-dev libx264-dev #处理视频所需的包sudo apt-get install libatlas-base-dev gfortran #优化opencv功能sudo apt-get install ffmpeg#安装包解压到~目录cd ~/opencv-3.4.5mkdir buildcmake -DOPENCV_EXTRA_MODULES_PATH=/home/liuly/opencv_contrib-3.4.5/modules ..make -j3sudo make install</code></pre><h3 id="2-Eigen"><a href="#2-Eigen" class="headerlink" title="2.Eigen"></a>2.Eigen</h3><pre><code class="sh">sudo apt install libeigen3-dev</code></pre><p>3.Pangolin</p><pre><code class="sh">sudo apt install libglew-devsudo apt install ffmpeg libavcodec-dev libavutil-dev libavformat-dev libswscale-dev libavdevice-devsudo apt install libjpeg-dev libpng12-dev libtiff5-dev libopenexr-devgit clone https://github.com/stevenlovegrove/Pangolin.gitcd Pangolinmkdir buildcd buildcmake ..make -j3sudo make install</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tensorflow笔记</title>
      <link href="/2020/03/06/%E5%85%B6%E4%BB%96/Tensorflow%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/03/06/%E5%85%B6%E4%BB%96/Tensorflow%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/tensorflow/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/tensorflow/</a></p><p>需要先安装pip： <code>sudo apt install python-pip</code></p><p>选择<code>Linux</code>，<code>cp27</code>，<code>1.3.0</code>，复制代码安装</p><pre><code class="sh">pip install \  -i https://pypi.tuna.tsinghua.edu.cn/simple/ \  https://mirrors.tuna.tsinghua.edu.cn/tensorflow/linux/cpu/tensorflow-1.3.0-cp27-none-linux_x86_64.whl</code></pre><p>测试</p><pre><code class="python">pythonimport tensorflow as tftf.__version__</code></pre><p>设置vim</p><pre><code class="sh">vim ~/.vimrcset ts=4set nu</code></pre><h1 id="Tensorflow框架"><a href="#Tensorflow框架" class="headerlink" title="Tensorflow框架"></a>Tensorflow框架</h1><h4 id="计算图和会话"><a href="#计算图和会话" class="headerlink" title="计算图和会话"></a>计算图和会话</h4><pre><code class="python">#coding:utf-8import tensorflow as tfx = tf.constant([[1.0,2.0]])w = tf.constant([[3.0],[4.0]])y = tf.matmul(x,w)#x与w相乘print ywith tf.Session() as sess:#（这是一个用来计算的会话）不带with后面的，就不计算结果，就只是网络框架    print sess.run(y)</code></pre><h4 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h4><pre><code class="python">#coding:utf-8#两层简单神经网络（全连接），两输入，一输出，隐含层三个神经元import tensorflow as tf#输入层，一行两列x = tf.constant([[0.7,0.5]])#网络层的权值，一层神经元有两组连接，权值用随机数生成w1 = tf.Variable(tf.random_normal([2,3],stddev=1,seed=1))w2 = tf.Variable(tf.random_normal([3,1],stddev=1,seed=1))#前向传播过程a = tf.matmul(x,w1)#x与w1矩阵乘y = tf.matmul(a,w2)#a与w2乘#用会话计算结果with tf.Session() as sess:    init_op = tf.global_variables_initializer()    sess.run(init_op)    print sess.run(y)</code></pre><h4 id="反向传播（训练）"><a href="#反向传播（训练）" class="headerlink" title="反向传播（训练）"></a>反向传播（训练）</h4><pre><code class="python">#!/usr/bin/python2.7# coding:utf-8# 喂数据，并训练，共有32组样本# 学习目标：输入为两个随机数，两数和&lt;1时，输出1，否则输出0import tensorflow as tfimport numpyBATCH_SIZE = 8seed = 23455# 基于seed产生随机数：实例化一个随机数生成器rdm = numpy.random.RandomState(seed)# 生成32行2列的随机数作为输入X = rdm.rand(32, 2)# 从X输入的两个数小于1时，Y输出1Y = [[int(x0 + x1 &lt; 1)] for (x0, x1) in X]# 打印样本print &quot;X:\n&quot;, Xprint &quot;Y:\n&quot;, Y# 神经网络的输入输出占位x = tf.placeholder(tf.float32, shape=(None, 2))y_ = tf.placeholder(tf.float32, shape=(None, 1))# 随机生成网络权值w1 = tf.Variable(tf.random_normal([2, 3], stddev=1, seed=1))w2 = tf.Variable(tf.random_normal([3, 1], stddev=1, seed=1))# 相乘a = tf.matmul(x, w1)y = tf.matmul(a, w2)# 损失函数loss = tf.reduce_mean(tf.square(y-y_))# 反向传播（训练）方法，步长=0.001，损失函数值=losstrain_step = tf.train.GradientDescentOptimizer(0.001).minimize(loss)#train_step = tf.train.MomentumOptimizer(0.001, 0.9).minimize(loss)#train_step = tf.train.AdamOptimizer(0.001).minimize(loss)# 生成会话来用样本训练模型with tf.Session() as sess:    init_op = tf.global_variables_initializer()  # 初始化参数    sess.run(init_op)    # 打印出未经训练的模型    print&quot;w1:\n&quot;, sess.run(w1)    print&quot;w2:\n&quot;, sess.run(w2)    # 训练模型    STEPS = 3000    for i in range(STEPS):        start = (i*BATCH_SIZE) % 32  # 每次喂8组数据:0～8,8~16,16~24,24~32        end = start + BATCH_SIZE        # 喂数据训练，使用X[start,end]方式可以超出列表范围，使用X[place]不能超出索引        sess.run(train_step, feed_dict={x: X[start:end], y_: Y[start:end]})        if i % 500 == 0:            total_loss = sess.run(loss, feed_dict={x: X, y_: Y})            print(&quot;训练%d轮后，损失函数值为%g&quot; % (i, total_loss))    # 打印训练后的参数    print&quot;\n&quot;    print&quot;w1:\n&quot;, sess.run(w1)    print&quot;w2:\n&quot;, sess.run(w2)</code></pre><h2 id="神经网络优化"><a href="#神经网络优化" class="headerlink" title="神经网络优化"></a>神经网络优化</h2><h4 id="损失函数-loss-：预测值-y-与已知答案-y-的差距"><a href="#损失函数-loss-：预测值-y-与已知答案-y-的差距" class="headerlink" title="损失函数(loss)：预测值(y)与已知答案(y_)的差距"></a>损失函数(loss)：预测值(y)与已知答案(y_)的差距</h4><p>主流的有三种：</p><ul><li><strong>均方误差mes(Mean Squared Error)</strong><br>$$<br>MSE(y_,y)=\frac{\sum_{i=1}^n(y-y_)^2}{n}<br>$$</li></ul><pre><code class="python">loss_mse = tf.reduce_mean(tf.square(y-y_))</code></pre><ul><li><p><strong>交叉熵ce(Cross Entropy)</strong></p><p>表征两个概率分布之间的距离<br>$$<br>H(y_,y)=-\sum_{i=1}^n(y_*logy)<br>$$</p><pre><code class="python">loss_ce = -tf.reduce_mean(y_*tf.log(tf.clip_by_value(y, 1e-12, 1.0)))#1e-12防止值为0</code></pre><p>当y有n个可能的输出值（即n分类）时，y_与每个y的ce符合概率分布（概率的和为1），使用softmax()函数<br>$$<br>softmax(y_{i})=\frac{e^{y_{i}}}{\sum_{j=1}^{n}e^{y_{i}}}<br>$$</p><pre><code class="python">ce = tf.nn.sparse_softmax_cross_entropy_with_logits(    logits=y, labels=tf.argmax(y_, 1))lose_ce = tf.reduce_mean(ce)</code></pre></li><li><p><strong>自定义损失函数</strong></p><p>例如<br>$$<br>loss(y_,y)=\sum_{i=1}^{n}f(y_,y)<br>$$</p><p>$$<br>f(y_,y) = \left{ {\begin{array}{<em>{20}{c}}<br>{PROFIT</em>(y_ - y)\quad y &lt; y_\quad 预测值小于实际值时，误差乘上PROFIT}\<br>{COST*(y - y_)\quad y &gt;  = y_\quad {\rm{ }} 预测值大于实际值时，误差乘以COST}\end{array}} \right.<br>$$</p><pre><code class="python">loss = tf.reduce_mean(tf.where(tf.grater(y, y_), COST*(y-y_), PROFIT*(y_-y)))</code></pre></li></ul><p><strong>一个训练的示例，损失函数采用均方误差</strong></p><pre><code class="python">#!/usr/bin/python2.7# coding:utf-8# 喂数据，并训练，共有32组样本# 学习目标：Y=x1+x2，并加入随机噪声-0.05~0.05import tensorflow as tfimport numpyBATCH_SIZE = 8seed = 23455rdm = numpy.random.RandomState(seed)# 目标模型X = rdm.rand(32, 2)Y_ = [[x1+x2+(rdm.rand()/10.0-0.05)] for (x1, x2) in X]# 神经网络模型，单层，没有隐含层x = tf.placeholder(tf.float32, shape=(None, 2))y_ = tf.placeholder(tf.float32, shape=(None, 1))w1 = tf.Variable(tf.random_normal([2, 1], stddev=1, seed=1))y = tf.matmul(x, w1)# 损失函数为MSE（均方误差）loss_mse = tf.reduce_mean(tf.square(y-y_))# 训练过程为梯度下降法train_step = tf.train.GradientDescentOptimizer(0.001).minimize(loss_mse)# 生成会话，训练STEP轮with tf.Session() as sess:    init_op = tf.global_variables_initializer()    sess.run(init_op)    STEPS = 20000    for i in range(STEPS):        start = (i*BATCH_SIZE) % 32        end = start + BATCH_SIZE        sess.run(train_step, feed_dict={x: X[start:end], y_: Y_[start:end]})        if i % 500 == 0:            total_loss = sess.run(loss_mse, feed_dict={x: X, y_: Y_})            print(&quot;训练%d轮后，损失函数值为%g&quot; % (i, total_loss))            print &quot;w1为：\n&quot;, sess.run(w1)    # 打印训练后的参数    print (&quot;\n&quot;)    print &quot;w1:\n&quot;, sess.run(w1)</code></pre><h4 id="学习率-learning-rate-：每次参数更新的幅度"><a href="#学习率-learning-rate-：每次参数更新的幅度" class="headerlink" title="学习率(learning_rate)：每次参数更新的幅度"></a>学习率(learning_rate)：每次参数更新的幅度</h4><p>$$<br>W_{n_1}=W_{n}-learning_rate*\nabla<br>$$</p><p>​            ▽为损失函数的梯度(倒数)，learning_rate为常数(用户自定义的学习率)</p><p><strong>指数衰减学习率</strong><br>$$<br>learning_rate=LEARNING_RATE_BASE*{LEARNING_RATE_DECAY}^{\frac{global_step}{LEARNING_RATE_STEP}}<br>$$</p><pre><code class="python">#!/usr/bin/python2.7# coding:utf-8# 单神经元，自定义损失函数loss=(w+1)^2，学习率为0.2，w初值为5；为了使loss最小时，w的最终结果应为-1import tensorflow as tfw = tf.Variable(tf.constant(5, dtype=tf.float32))  # 神经网络loss = tf.square(w+1)  # 损失函数# 指数衰减学习率参数LEARNING_RATE_BASE = 0.1  # 最初学习率LEARNING_RATE_DECAY = 0.99  # 学习率的衰减率LEARNING_RATE_STEP = 2  # 每多少轮更新一次学习率，一般为:样本总数/BATCH_SIZEglobal_step = tf.Variable(0, trainable=False)  # 当前是第几轮# 定义学习率learning_rate = tf.train.exponential_decay(    LEARNING_RATE_BASE, global_step, LEARNING_RATE_STEP,    LEARNING_RATE_DECAY, staircase=True)# 反向传播方法train_step = tf.train.GradientDescentOptimizer(    learning_rate).minimize(loss, global_step=global_step)# 定义会话，训练40轮with tf.Session() as sess:    init_op = tf.global_variables_initializer()    sess.run(init_op)    for i in range(40):        sess.run(train_step)        # 数据打印        learning_rate_val = sess.run(learning_rate)        w_val = sess.run(w)        loss_val = sess.run(loss)        learning_rate_val = sess.run(learning_rate)        global_step_val = sess.run(global_step)        print &quot;训练%s轮后，w值为%f，loss值为%f，学习率为%s，step为%s&quot; % (            i, w_val, loss_val, learning_rate_val, global_step_val)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub常用命令</title>
      <link href="/2020/03/06/Linux/GitHub/"/>
      <url>/2020/03/06/Linux/GitHub/</url>
      
        <content type="html"><![CDATA[<h3 id="1-注册和创建储存库"><a href="#1-注册和创建储存库" class="headerlink" title="1. 注册和创建储存库"></a>1. 注册和创建储存库</h3><p><a href="https://www.jianshu.com/p/68b9e463333f" target="_blank" rel="noopener">教程</a></p><p>创建的存储库地址为：<a href="https://github.com/liuly123/ORB-SLAM2。下面以此为背景" target="_blank" rel="noopener">https://github.com/liuly123/ORB-SLAM2。下面以此为背景</a></p><h3 id="2-Ubuntu"><a href="#2-Ubuntu" class="headerlink" title="2. Ubuntu"></a>2. Ubuntu</h3><h4 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h4><pre><code class="sh">#设置用户名和邮箱git config --global user.name &quot;liuly123&quot;git config --global user.email &quot;2240057686@qq.com&quot;#生成keyssh-keygen -t rsa -C &quot;2240057686@qq.com&quot;#复制生成的ssh keycat ~/.ssh/id_rsa.pub#粘贴到网站上：登录github-&gt; Your profile -&gt; 右边Edit profile -&gt; SSH and GPG Keys-&gt; New SSH key添加</code></pre><h4 id="2-2-新建一个本地仓库"><a href="#2-2-新建一个本地仓库" class="headerlink" title="2.2 新建一个本地仓库"></a>2.2 新建一个本地仓库</h4><pre><code class="sh">cd ORB-SLAM2#初始化git init#添加github的地址，使用ssh方式可以避免每次输入密码（打开repository-&gt;clone or download -&gt; Use SSH -&gt; 复制地址）git  remote add origin git@github.com:liuly123/ORB-SLAM2.git#同步本地文件（commit）git add -Agit commit -m &#39;本次commit的说明&#39;git push origin master</code></pre><p><strong>以后每次提交更改</strong></p><pre><code class="sh">cd ORB-SLAM2git add -Agit commit -m &#39;本次commit的说明&#39;git push origin master</code></pre><h3 id="2-3其他说明"><a href="#2-3其他说明" class="headerlink" title="2.3其他说明"></a>2.3其他说明</h3><pre><code class="sh">#查看同步状态git status#强制同步（会覆盖之前的所有版本），第一次一般需要git push -u origin +master#注意：无法上传超过100M的文件#同步大文件出错的解决办法：#查看commit idgit log#回退到之前版本（本地文件也会别修改、删除）git reset --hard 9ff7cad52bce71a0fb7a57928e1673f1a4f536f1#本地与远程保持同步git pull origin master#抓取远程仓库git clone git@github.com:liuly123/Note.git</code></pre><h3 id="2-3简化脚本"><a href="#2-3简化脚本" class="headerlink" title="2.3简化脚本"></a>2.3简化脚本</h3><pre><code class="sh">#!/bin/bashtime=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)git add -Agit commit -m &quot;$time&quot;git push origin master</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu配置</title>
      <link href="/2020/03/06/Linux/Ubuntu%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/03/06/Linux/Ubuntu%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h4 id="安装Typora"><a href="#安装Typora" class="headerlink" title="安装Typora"></a>安装Typora</h4><p>地址<a href="https://support.typora.io/Typora-on-Linux/" target="_blank" rel="noopener">https://support.typora.io/Typora-on-Linux/</a></p><pre><code class="sh">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key addsudo add-apt-repository &#39;deb https://typora.io/linux ./&#39;sudo apt-get updatesudo apt-get install typora</code></pre><p>另一款remarkable</p><h4 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h4><p><a href="https://blog.csdn.net/seniusen/article/details/79815107" target="_blank" rel="noopener">链接</a></p><h4 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h4><p><a href="https://github.com/qingshuisiyuan/electron-ssr-backup" target="_blank" rel="noopener">教程</a></p><h4 id="安装搜狗拼音"><a href="#安装搜狗拼音" class="headerlink" title="安装搜狗拼音"></a>安装搜狗拼音</h4><p>地址<a href="https://pinyin.sogou.com/linux/" target="_blank" rel="noopener">https://pinyin.sogou.com/linux/</a></p><p>不要从系统设置里修改，在任务栏上修改</p><h4 id="设置rtc时间"><a href="#设置rtc时间" class="headerlink" title="设置rtc时间"></a>设置rtc时间</h4><pre><code class="sh">timedatectl set-local-rtc true</code></pre><h4 id="安装CLion"><a href="#安装CLion" class="headerlink" title="安装CLion"></a>安装CLion</h4><p><a href="https://blog.csdn.net/u010925447/article/details/73251780" target="_blank" rel="noopener">教程</a>，<a href="https://www.jetbrains.com/clion/download/#section=linux" target="_blank" rel="noopener">下载地址</a></p><p>账号：<a href="mailto:2240057686@qq.com">2240057686@qq.com</a></p><p>密码：abc12345@</p><p><a href="https://github.com/pingfangx/jetbrains-in-chinese/tree/master/CLion" target="_blank" rel="noopener">汉化</a></p><p><strong>修改字体：</strong>设置&gt;编辑器&gt;切换配色方案&gt;Color Scheme Font&gt;备用字体&gt;SimSun(已经安装windows字体)。（其他的备用字体最好也换，如Console Font）</p><p><strong>远程调试：</strong></p><p><img src="/images/Ubuntu%E9%85%8D%E7%BD%AE/image-20200310101158919.png" alt="image-20200310101158919"></p><p><strong>乱码问题：</strong>帮助-&gt;编辑自定义VM选项，添加</p><pre><code class="ini">-Dconsole.encoding=UTF-8-Dfile.encoding=UTF-8</code></pre><h4 id="添加设备文件读写权限"><a href="#添加设备文件读写权限" class="headerlink" title="添加设备文件读写权限"></a>添加设备文件读写权限</h4><pre><code class="sh">sudo usermod -a -G dialout $USERsudo chmod a+rw /dev/ttyUSB0</code></pre><h4 id="安装wps"><a href="#安装wps" class="headerlink" title="安装wps"></a>安装wps</h4><p>下载地址<a href="http://linux.wps.cn/" target="_blank" rel="noopener">http://linux.wps.cn/</a></p><h4 id="安装录屏软件"><a href="#安装录屏软件" class="headerlink" title="安装录屏软件"></a>安装录屏软件</h4><pre><code class="sh">sudo add-apt-repository ppa:maarten-baert/simplescreenrecordersudo apt updatesudo apt install simplescreenrecorder</code></pre><h4 id="安装chrome"><a href="#安装chrome" class="headerlink" title="安装chrome"></a>安装chrome</h4><pre><code class="sh">wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -echo &#39;deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main&#39; | sudo tee /etc/apt/sources.list.d/google-chrome.listsudo apt-get update sudo apt-get install google-chrome-stable</code></pre><p>或者直接<a href="https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb" target="_blank" rel="noopener">下载</a></p><h4 id="安装中国版火狐"><a href="#安装中国版火狐" class="headerlink" title="安装中国版火狐"></a>安装中国版火狐</h4><p><a href="http://www.firefox.com.cn/download/" target="_blank" rel="noopener">下载</a>，解压</p><pre><code class="sh">sudo apt remove firefoxsudo mv firefox /opt #firefox是解压得到的文件夹cd /usr/share/applicationssudo gedit firefox.desktop</code></pre><p>内容为</p><pre><code class="ini">[Desktop Entry]Name=firefoxName[zh_CN]=火狐浏览器Comment=火狐浏览器Exec=/opt/firefox/firefoxIcon=/opt/firefox/browser/chrome/icons/default/default128.pngTerminal=falseType=ApplicationCategories=Appliction;Encoding=UTF-8StartupNotify=true</code></pre><h4 id="状态栏网速"><a href="#状态栏网速" class="headerlink" title="状态栏网速"></a>状态栏网速</h4><pre><code class="sh">sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitorsudo apt-get updatesudo apt-get install indicator-sysmonitorindicator-sysmonitor &amp;#设置开机启动</code></pre><h4 id="Understand代码分析"><a href="#Understand代码分析" class="headerlink" title="Understand代码分析"></a>Understand代码分析</h4><p><a href="https://scitools.com/download/all-builds/" target="_blank" rel="noopener">https://scitools.com/download/all-builds/</a></p><p><strong>添加环境变量</strong></p><pre><code class="sh">export PATH=&quot;$PATH:/home/liuly/snap/scitools/bin/linux64&quot;</code></pre><p><strong>输入license</strong></p><p>enter liscense &gt; option &gt; use lagacy licensing &gt; 输入09E58CD1FB79</p><p><strong>添加快捷方式</strong></p><pre><code class="sh">[Desktop Entry]Name=understandType=ApplicationComment=scitools understandIcon=/home/liuly/snap/scitools/bin/linux64/understand_64.pngExec=/home/liuly/snap/scitools/bin/linux64/understand %FTerminal=falseCategories=Development;</code></pre><h4 id="安装VScode"><a href="#安装VScode" class="headerlink" title="安装VScode"></a>安装VScode</h4><p><a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">https://code.visualstudio.com/Download</a></p><p><strong>设置中文</strong></p><p>商店搜索Chinese，安装<code>适用于 VS Code 的中文（简体）语言包</code>，并设置<code>locale.json</code></p><p><strong>扩展</strong></p><p><code>C/C++</code> <code>Python</code> <code>ROS</code></p><h4 id="RoboWare"><a href="#RoboWare" class="headerlink" title="RoboWare"></a>RoboWare</h4><p><a href="https://github.com/TonyRobotics/RoboWare/tree/master/Studio" target="_blank" rel="noopener">https://github.com/TonyRobotics/RoboWare/tree/master/Studio</a></p><h4 id="修改grub主题"><a href="#修改grub主题" class="headerlink" title="修改grub主题"></a>修改grub主题</h4><p><a href="https://blog.csdn.net/w84963568/article/details/78884003" target="_blank" rel="noopener">https://blog.csdn.net/w84963568/article/details/78884003</a></p><h4 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h4><p>字体<a href="https://www.cnblogs.com/Dylansuns/p/7648002.html" target="_blank" rel="noopener">参考</a>，还有time和simhei</p><pre><code class="sh">cd /usr/share/fonts/winfontscp ~/msyh.ttf ./sudo chmod 644 *sudo mkfontscale #创建雅黑字体的fonts.scale文件，它用来控制字体旋转缩放sudo mkfontdir #创建雅黑字体的fonts.dir文件，它用来控制字体粗斜体产生sudo fc-cache -fv #建立字体缓存信息，也就是让系统认识雅黑</code></pre><h4 id="终端分屏"><a href="#终端分屏" class="headerlink" title="终端分屏"></a>终端分屏</h4><pre><code class="bash">sudo apt install terminator</code></pre><p>使用</p><pre><code>Ctrl+Shift+E    垂直分割窗口Ctrl+Shift+O    水平分割窗口    F11         全屏Ctrl+Shift+C    复制Ctrl+Shift+V    粘贴Ctrl+Shift+N    或者 Ctrl+Tab 在分割的各窗口之间切换Ctrl+Shift+X    将分割的某一个窗口放大至全屏使用Ctrl+Shift+Z    从放大至全屏的某一窗口回到多窗格界面</code></pre><h4 id="双系统蓝牙鼠标"><a href="#双系统蓝牙鼠标" class="headerlink" title="双系统蓝牙鼠标"></a>双系统蓝牙鼠标</h4><p><a href="https://www.jianshu.com/p/56f6b0dc231e" target="_blank" rel="noopener">https://www.jianshu.com/p/56f6b0dc231e</a></p><h4 id="批量修改文件夹-文件权限"><a href="#批量修改文件夹-文件权限" class="headerlink" title="批量修改文件夹/文件权限"></a>批量修改文件夹/文件权限</h4><pre><code class="sh">#当前目录下及递归find -type d|xargs chmod 755find -type f|xargs chmod 664</code></pre><h4 id="源码安装cmake"><a href="#源码安装cmake" class="headerlink" title="源码安装cmake"></a>源码安装cmake</h4><p><a href="https://cmake.org/download/" target="_blank" rel="noopener">下载</a></p><pre><code class="sh">#编译安装，不要卸载原来的tar -xzvf cmake-3.14.5.tar.gzcd cmake-3.14.5./bootstrapmakesudo make install</code></pre><h4 id="安装rtk8811cu驱动"><a href="#安装rtk8811cu驱动" class="headerlink" title="安装rtk8811cu驱动"></a>安装rtk8811cu驱动</h4><pre><code class="sh">git clone https://github.com/whitebatman2/rtl8821CUcd rtl8821CUmakesudo make installsudo modprobe 8821cu</code></pre><h4 id="修改ROS源"><a href="#修改ROS源" class="headerlink" title="修改ROS源"></a>修改ROS源</h4><pre><code class="sh">sudo sh -c &#39;echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#39;wget https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -O - | sudo apt-key add -</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code class="sh">sudo sudo apt install build-essential #安装gcc g++</code></pre><h3 id="蓝牙断开不重连"><a href="#蓝牙断开不重连" class="headerlink" title="蓝牙断开不重连"></a>蓝牙断开不重连</h3><pre><code class="sh">bluetoothctltrust 70:F0:87:23:FB:F4 #信任设备</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>D435-ROS</title>
      <link href="/2020/03/06/ROS/D435-ROS/"/>
      <url>/2020/03/06/ROS/D435-ROS/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/IntelRealSense/librealsense/blob/master/doc/installation.md" target="_blank" rel="noopener">官方说明</a>,<a href="https://blog.csdn.net/Carminljm/article/details/86353775" target="_blank" rel="noopener">参考</a></p><h3 id="安装SDK"><a href="#安装SDK" class="headerlink" title="安装SDK"></a>安装SDK</h3><pre><code class="sh">#更新系统内核到最新版，并安装依赖sudo apt-get update &amp;&amp; sudo apt-get upgrade &amp;&amp; sudo apt-get dist-upgradesudo apt-get install --install-recommends linux-generic-lts-xenial xserver-xorg-core-lts-xenial xserver-xorg-lts-xenial xserver-xorg-video-all-lts-xenial xserver-xorg-input-all-lts-xenial libwayland-egl1-mesa-lts-xenial#重启sudo update-grub &amp;&amp; sudo reboot#下载源码git clone https://github.com/IntelRealSense/librealsense.gitcd librealsense#安装依赖sudo apt-get install git libssl-dev libusb-1.0-0-dev pkg-config libgtk-3-devsudo apt-get install libglfw3-dev    #针对16.04#编译并安装uvc的内核驱动./scripts/setup_udev_rules.sh./scripts/patch-realsense-ubuntu-lts.sh#cmake编译安装SDKmkdir build &amp;&amp; cd buildcmake ..makesudo make install</code></pre><h3 id="安装ROS包"><a href="#安装ROS包" class="headerlink" title="安装ROS包"></a>安装ROS包</h3><pre><code class="sh">#安装依赖sudo apt install ros-kinetic-ddynamic-reconfigure#克隆ROS包并编译cd ~/catkin_ws/srcgit clone https://github.com/IntelRealSense/realsense-ros/cd ~/catkin_wscatkin_make</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="sh">roslaunch realsense2_camera rs_camera.launch#RGB-D测试sudo apt install ros-kinetic-rgbd-launchroslaunch realsense2_camera rs_rgbd.launch#打开rviz，add要显示的topic&gt;: /camera/depth_registered/points#获取内参矩阵krostopic echo /camera/color/camera_info#K = [fx 0 cx 0 fy cy 0 0 1 ]#双目摄像头的基线为55mm</code></pre><h3 id="ORB-SLAM2测试"><a href="#ORB-SLAM2测试" class="headerlink" title="ORB-SLAM2测试"></a>ORB-SLAM2测试</h3><p><strong>创建配置文件</strong></p><pre><code class="yaml">%~/ORB-SLAM2/Examples/ROS/ORB_SLAM2/D435.yaml%YAML:1.0#--------------------------------------------------------------------------------------------# Camera Parameters. Adjust them!#--------------------------------------------------------------------------------------------# Camera calibration and distortion parameters (OpenCV) Camera.fx: 613.893310546875Camera.fy: 613.830810546875Camera.cx: 315.91748046875Camera.cy: 249.05508422851562Camera.k1: 0.0Camera.k2: 0.0Camera.p1: 0.0Camera.p2: 0.0Camera.width: 640Camera.height: 480# Camera frames per second Camera.fps: 30.0# IR projector baseline times fx (aprox.)Camera.bf: 30.720571899# Color order of the images (0: BGR, 1: RGB. It is ignored if images are grayscale)Camera.RGB: 1# Close/Far threshold. Baseline times.ThDepth: 50.0# Deptmap values factorDepthMapFactor: 1000.0#--------------------------------------------------------------------------------------------# ORB Parameters#--------------------------------------------------------------------------------------------# ORB Extractor: Number of features per imageORBextractor.nFeatures: 1000# ORB Extractor: Scale factor between levels in the scale pyramid     ORBextractor.scaleFactor: 1.2# ORB Extractor: Number of levels in the scale pyramid    ORBextractor.nLevels: 8# ORB Extractor: Fast threshold# Image is divided in a grid. At each cell FAST are extracted imposing a minimum response.# Firstly we impose iniThFAST. If no corners are detected we impose a lower value minThFAST# You can lower these values if your images have low contrast            ORBextractor.iniThFAST: 20ORBextractor.minThFAST: 7#--------------------------------------------------------------------------------------------# Viewer Parameters#--------------------------------------------------------------------------------------------Viewer.KeyFrameSize: 0.05Viewer.KeyFrameLineWidth: 1Viewer.GraphLineWidth: 0.9Viewer.PointSize:2Viewer.CameraSize: 0.08Viewer.CameraLineWidth: 3Viewer.ViewpointX: 0Viewer.ViewpointY: -0.7Viewer.ViewpointZ: -1.8Viewer.ViewpointF: 500</code></pre><p><strong>修改源文件中订阅的topic</strong></p><pre><code class="c++">    message_filters::Subscriber&lt;sensor_msgs::Image&gt; rgb_sub(nh, &quot;/camera/rgb/image_raw&quot;, 1);    message_filters::Subscriber&lt;sensor_msgs::Image&gt; depth_sub(nh, &quot;camera/depth_registered/image_raw&quot;, 1);</code></pre><p>改为</p><pre><code class="c++">    message_filters::Subscriber&lt;sensor_msgs::Image&gt; rgb_sub(nh, &quot;/camera/color/image_raw&quot;, 1);    message_filters::Subscriber&lt;sensor_msgs::Image&gt; depth_sub(nh, &quot;/camera/depth/image_rect_raw&quot;, 1);</code></pre><p><strong>重新编译</strong></p><pre><code class="sh">./build_ros.sh</code></pre><p><strong>运行</strong></p><pre><code class="sh">roslaunch realsense2_camera rs_camera.launchrosrun ORB_SLAM2 RGBD ~/ORB-SLAM2/Vocabulary/ORBvoc.txt ~/ORB-SLAM2/Examples/ROS/ORB_SLAM2/D435.yaml</code></pre><h3 id="RTAB-Map测试"><a href="#RTAB-Map测试" class="headerlink" title="RTAB-Map测试"></a>RTAB-Map测试</h3><p>RTAB-Map安装参考<code>ZED-ROS-RTAB.md</code></p><p><strong>测试</strong></p><pre><code class="sh">#启动d435roslaunch realsense2_camera rs_camera.launch align_depth:=true#启动rtabroslaunch rtabmap_ros rtabmap.launch rtabmap_args:=&quot;--delete_db_on_start&quot; depth_topic:=/camera/aligned_depth_to_color/image_raw rgb_topic:=/camera/color/image_raw camera_info_topic:=/camera/color/camera_info approx_sync:=false</code></pre>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>D435参数</title>
      <link href="/2020/03/06/ROS/D435%E5%8F%82%E6%95%B0/"/>
      <url>/2020/03/06/ROS/D435%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>rgb内参K<code>/camera/color/camera_info</code></p><pre><code class="yaml">613.893310546875, 0.0, 315.91748046875, 0.0, 613.830810546875, 249.05508422851562, 0.0, 0.0, 1.0</code></pre><p>depth内参K<code>/camera/depth/camera_info</code></p><pre><code class="yaml">383.59088134765625, 0.0, 321.16314697265625, 0.0, 383.59088134765625, 242.30032348632812, 0.0, 0.0, 1.0</code></pre><p>外参<code>/camera/extrinsics/depth_to_color</code></p><pre><code class="yaml">#旋转0.9999907612800598, 0.00014307590026874095, -0.004291828256100416, -0.00013257611135486513, 0.9999970197677612, 0.002446645637974143, 0.004292165394872427, -0.002446054248139262, 0.999987781047821#平移0.014698687009513378, 9.26993670873344e-05, -8.568778866901994e-06</code></pre>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gazebo</title>
      <link href="/2020/03/06/ROS/Gazebo/"/>
      <url>/2020/03/06/ROS/Gazebo/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/wangchao7281" target="_blank" rel="noopener">https://blog.csdn.net/wangchao7281</a></p><h2 id="1-下载Gazebo模型"><a href="#1-下载Gazebo模型" class="headerlink" title="1.下载Gazebo模型"></a>1.下载Gazebo模型</h2><p>首次运行Gazebo，加载模型会出现非常缓慢，原因可能是不能正确下载模型。所以要手动下载模型：</p><pre><code class="bash">cd ~/.gazebo/modelswget http://file.ncnynl.com/ros/gazebo_models.txtwget -i gazebo_models.txtls model.tar.g* | xargs -n1 tar xzvf</code></pre><h2 id="2-urdf文件"><a href="#2-urdf文件" class="headerlink" title="2. urdf文件"></a>2. urdf文件</h2><p><strong>创建urdf文件</strong></p><pre><code class="bash">cd ~/catkin_ws/srccatkin_create_pkg robot_urdfcd robot_urdfgedit urdf/robot1.urdf</code></pre><p><strong>文件内容<a href="https://github.com/ros/urdf_tutorial/blob/master/urdf/07-physics.urdf" target="_blank" rel="noopener">robot1.urdf</a></strong></p><p>注意不能有中文，注释也不行。节选内容：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;robot name=&quot;robot1&quot;&gt;    &lt;material name=&quot;blue&quot;&gt;&lt;color rgba=&quot;0 0 0.8 1&quot;/&gt;&lt;/material&gt;    &lt;material name=&quot;white&quot;&gt;&lt;color rgba=&quot;1 1 1 1&quot;/&gt;&lt;/material&gt;    &lt;link name=&quot;base_link&quot;&gt;        &lt;visual&gt;            &lt;geometry&gt;                &lt;cylinder length=&quot;0.6&quot; radius=&quot;0.2&quot;/&gt;            &lt;/geometry&gt;            &lt;material name=&quot;blue&quot;/&gt;        &lt;/visual&gt;        &lt;collision&gt;            &lt;geometry&gt;                &lt;cylinder length=&quot;0.6&quot; radius=&quot;0.2&quot;/&gt;            &lt;/geometry&gt;        &lt;/collision&gt;        &lt;inertial&gt;            &lt;mass value=&quot;10&quot;/&gt;            &lt;inertia ixx=&quot;1.0&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot; iyy=&quot;1.0&quot; iyz=&quot;0.0&quot; izz=&quot;1.0&quot;/&gt;        &lt;/inertial&gt;    &lt;/link&gt;    &lt;link name=&quot;head&quot;&gt;        &lt;visual&gt;            &lt;geometry&gt;                &lt;sphere radius=&quot;0.2&quot;/&gt;            &lt;/geometry&gt;            &lt;material name=&quot;white&quot;/&gt;        &lt;/visual&gt;        &lt;collision&gt;            &lt;geometry&gt;                &lt;sphere radius=&quot;0.2&quot;/&gt;            &lt;/geometry&gt;        &lt;/collision&gt;        &lt;inertial&gt;            &lt;mass value=&quot;2&quot;/&gt;        &lt;inertia ixx=&quot;1.0&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot; iyy=&quot;1.0&quot; iyz=&quot;0.0&quot; izz=&quot;1.0&quot;/&gt;        &lt;/inertial&gt;    &lt;/link&gt;    &lt;joint name=&quot;head_swivel&quot; type=&quot;continuous&quot;&gt;        &lt;parent link=&quot;base_link&quot;/&gt;        &lt;child link=&quot;head&quot;/&gt;        &lt;axis xyz=&quot;0 0 1&quot;/&gt;        &lt;origin xyz=&quot;0 0 0.3&quot;/&gt;    &lt;/joint&gt;&lt;/robot&gt;</code></pre><p><code>link</code>零件，<code>joint</code>零件的连接方式，<code>visual</code>外观，<code>collision</code>碰撞，<code>inertial</code>加速度</p><p><strong>在rviz中查看模型</strong></p><p>查看.xaco文件一样</p><pre><code class="bash">roslaunch urdf_tutorial  display.launch  model:=`rospack find robot_urdf`/urdf/robot1.urdf</code></pre><h2 id="3-xacro文件"><a href="#3-xacro文件" class="headerlink" title="3. xacro文件"></a>3. xacro文件</h2><p>xacro文件与urdf文件是等价的，xacro是宏定义的，编写大文件时便于理解</p><p><strong>创建.xacro文件并转换</strong></p><pre><code class="bash">gedit /urdf/robot.urdf.xacro#转换为.urdf文件xacro --inorder robot.xacro &gt; robot.urdf#在rviz中加载roslaunch urdf_tutorial  display.launch  model:=`rospack find robot_urdf`/urdf/robot.urdf.xacro</code></pre><p><strong>文件内容<a href="https://github.com/ros/urdf_tutorial/blob/master/urdf/08-macroed.urdf.xacro" target="_blank" rel="noopener">robot.urdf.xacro</a></strong></p><p>节选内容：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;robot name=&quot;robot&quot; xmlns:xacro=&quot;http://ros.org/wiki/xacro&quot;&gt;    &lt;xacro:property name=&quot;width&quot; value=&quot;0.2&quot; /&gt;    &lt;xacro:property name=&quot;polelen&quot; value=&quot;0.2&quot; /&gt;    &lt;xacro:property name=&quot;bodylen&quot; value=&quot;0.6&quot; /&gt;    &lt;material name=&quot;blue&quot;&gt;&lt;color rgba=&quot;0 0 0.8 1&quot;/&gt;&lt;/material&gt;    &lt;material name=&quot;white&quot;&gt;&lt;color rgba=&quot;1 1 1 1&quot;/&gt;&lt;/material&gt;    &lt;xacro:macro name=&quot;default_inertial&quot; params=&quot;mass&quot;&gt;        &lt;inertial&gt;            &lt;mass value=&quot;${mass}&quot; /&gt;            &lt;inertia ixx=&quot;1.0&quot; ixy=&quot;0.0&quot; ixz=&quot;0.0&quot; iyy=&quot;1.0&quot; iyz=&quot;0.0&quot; izz=&quot;1.0&quot; /&gt;        &lt;/inertial&gt;    &lt;/xacro:macro&gt;    &lt;link name=&quot;base_link&quot;&gt;        &lt;visual&gt;            &lt;geometry&gt;            &lt;cylinder radius=&quot;${width}&quot; length=&quot;${bodylen}&quot;/&gt;            &lt;/geometry&gt;            &lt;material name=&quot;blue&quot;/&gt;        &lt;/visual&gt;        &lt;collision&gt;            &lt;geometry&gt;                &lt;cylinder radius=&quot;${width}&quot; length=&quot;${bodylen}&quot;/&gt;            &lt;/geometry&gt;        &lt;/collision&gt;        &lt;xacro:default_inertial mass=&quot;10&quot;/&gt;    &lt;/link&gt;    &lt;link name=&quot;head&quot;&gt;        &lt;visual&gt;            &lt;geometry&gt;                &lt;sphere radius=&quot;${width}&quot;/&gt;            &lt;/geometry&gt;            &lt;material name=&quot;white&quot;/&gt;        &lt;/visual&gt;        &lt;collision&gt;            &lt;geometry&gt;                &lt;sphere radius=&quot;${width}&quot;/&gt;            &lt;/geometry&gt;        &lt;/collision&gt;        &lt;xacro:default_inertial mass=&quot;2&quot;/&gt;    &lt;/link&gt;    &lt;joint name=&quot;head_swivel&quot; type=&quot;continuous&quot;&gt;        &lt;parent link=&quot;base_link&quot;/&gt;        &lt;child link=&quot;head&quot;/&gt;        &lt;axis xyz=&quot;0 0 1&quot;/&gt;        &lt;origin xyz=&quot;0 0 ${bodylen/2}&quot;/&gt;    &lt;/joint&gt;    &lt;joint name=&quot;gripper_extension&quot; type=&quot;prismatic&quot;&gt;        &lt;parent link=&quot;base_link&quot;/&gt;        &lt;child link=&quot;gripper_pole&quot;/&gt;        &lt;limit effort=&quot;1000.0&quot; lower=&quot;-${width*2-.02}&quot; upper=&quot;0&quot; velocity=&quot;0.5&quot;/&gt;        &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;${width-.01} 0 0.2&quot;/&gt;    &lt;/joint&gt;    &lt;link name=&quot;gripper_pole&quot;&gt;        &lt;visual&gt;            &lt;geometry&gt;                &lt;cylinder length=&quot;${polelen}&quot; radius=&quot;0.01&quot;/&gt;            &lt;/geometry&gt;            &lt;origin xyz=&quot;${polelen/2} 0 0&quot; rpy=&quot;0 ${pi/2} 0 &quot;/&gt;        &lt;/visual&gt;        &lt;collision&gt;            &lt;geometry&gt;                &lt;cylinder length=&quot;${polelen}&quot; radius=&quot;0.01&quot;/&gt;            &lt;/geometry&gt;            &lt;origin xyz=&quot;${polelen/2} 0 0&quot; rpy=&quot;0 ${pi/2} 0 &quot;/&gt;        &lt;/collision&gt;        &lt;xacro:default_inertial mass=&quot;0.05&quot;/&gt;    &lt;/link&gt;    &lt;xacro:macro name=&quot;gripper&quot; params=&quot;prefix reflect&quot;&gt;        &lt;link name=&quot;${prefix}_gripper&quot;&gt;            &lt;visual&gt;                &lt;origin rpy=&quot;${(reflect-1)/2*pi} 0 0&quot; xyz=&quot;0 0 0&quot;/&gt;                &lt;geometry&gt;                    &lt;mesh filename=&quot;package://urdf_tutorial/meshes/l_finger.dae&quot;/&gt;                &lt;/geometry&gt;            &lt;/visual&gt;            &lt;collision&gt;                &lt;geometry&gt;                    &lt;mesh filename=&quot;package://urdf_tutorial/meshes/l_finger.dae&quot;/&gt;                &lt;/geometry&gt;                &lt;origin rpy=&quot;${(reflect-1)/2*pi} 0 0&quot; xyz=&quot;0 0 0&quot;/&gt;            &lt;/collision&gt;            &lt;xacro:default_inertial mass=&quot;0.05&quot;/&gt;        &lt;/link&gt;        &lt;joint name=&quot;${prefix}_gripper_joint&quot; type=&quot;revolute&quot;&gt;            &lt;axis xyz=&quot;0 0 ${reflect}&quot;/&gt;            &lt;limit effort=&quot;1000.0&quot; lower=&quot;0.0&quot; upper=&quot;0.548&quot; velocity=&quot;0.5&quot;/&gt;            &lt;origin rpy=&quot;0 0 0&quot; xyz=&quot;${polelen} ${reflect*0.01} 0&quot;/&gt;            &lt;parent link=&quot;gripper_pole&quot;/&gt;            &lt;child link=&quot;${prefix}_gripper&quot;/&gt;        &lt;/joint&gt;        &lt;link name=&quot;${prefix}_tip&quot;&gt;            &lt;visual&gt;                &lt;origin rpy=&quot;${(reflect-1)/2*pi} 0 0&quot; xyz=&quot;0.09137 0.00495 0&quot;/&gt;                &lt;geometry&gt;                    &lt;mesh filename=&quot;package://urdf_tutorial/meshes/l_finger_tip.dae&quot;/&gt;                &lt;/geometry&gt;            &lt;/visual&gt;            &lt;collision&gt;                &lt;geometry&gt;                    &lt;mesh filename=&quot;package://urdf_tutorial/meshes/l_finger_tip.dae&quot;/&gt;                &lt;/geometry&gt;                &lt;origin rpy=&quot;${(reflect-1)/2*pi} 0 0&quot; xyz=&quot;0.09137 0.00495 0&quot;/&gt;            &lt;/collision&gt;            &lt;xacro:default_inertial mass=&quot;0.05&quot;/&gt;        &lt;/link&gt;        &lt;joint name=&quot;${prefix}_tip_joint&quot; type=&quot;fixed&quot;&gt;            &lt;parent link=&quot;${prefix}_gripper&quot;/&gt;            &lt;child link=&quot;${prefix}_tip&quot;/&gt;        &lt;/joint&gt;    &lt;/xacro:macro&gt;    &lt;xacro:gripper prefix=&quot;left&quot; reflect=&quot;1&quot; /&gt;    &lt;xacro:gripper prefix=&quot;right&quot; reflect=&quot;-1&quot; /&gt;&lt;/robot&gt;</code></pre><h2 id="4-加载机器人"><a href="#4-加载机器人" class="headerlink" title="4. 加载机器人"></a>4. 加载机器人</h2><p>创建launch文件</p><pre><code class="bash">roscd rabot_urdfgedit urdf/gazebo.launch</code></pre><p>launch文件内容：</p><pre><code class="xml">&lt;launch&gt;    &lt;!-- 参数 --&gt;    &lt;arg name=&quot;paused&quot; default=&quot;false&quot;/&gt;    &lt;arg name=&quot;use_sim_time&quot; default=&quot;true&quot;/&gt;    &lt;arg name=&quot;gui&quot; default=&quot;true&quot;/&gt;    &lt;arg name=&quot;headless&quot; default=&quot;false&quot;/&gt;    &lt;arg name=&quot;debug&quot; default=&quot;false&quot;/&gt;    &lt;arg name=&quot;model&quot; default=&quot;$(find robot_urdf)/urdf/robot.urdf.xacro&quot;/&gt;    &lt;arg name=&quot;rvizconfig&quot; default=&quot;$(find urdf_tutorial)/rviz/urdf.rviz&quot; /&gt;    &lt;param name=&quot;robot_description&quot; command=&quot;xacro --inorder $(arg model)&quot; /&gt;    &lt;!-- 打开gazebo并加载一个空的世界 --&gt;    &lt;include file=&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;&gt;        &lt;arg name=&quot;debug&quot; value=&quot;$(arg debug)&quot; /&gt;        &lt;arg name=&quot;gui&quot; value=&quot;$(arg gui)&quot; /&gt;        &lt;arg name=&quot;paused&quot; value=&quot;$(arg paused)&quot;/&gt;        &lt;arg name=&quot;use_sim_time&quot; value=&quot;$(arg use_sim_time)&quot;/&gt;        &lt;arg name=&quot;headless&quot; value=&quot;$(arg headless)&quot;/&gt;    &lt;/include&gt;    &lt;!-- 在gazebo中加载机器人模型 --&gt;    &lt;node name=&quot;urdf_spawner&quot; pkg=&quot;gazebo_ros&quot; type=&quot;spawn_model&quot; args=&quot;-z 1.0 -unpause -urdf -model robot -param robot_description&quot; respawn=&quot;false&quot; output=&quot;screen&quot; /&gt;    &lt;!-- 将机器人模型的state发布到ros --&gt;    &lt;node pkg=&quot;robot_state_publisher&quot; type=&quot;robot_state_publisher&quot;  name=&quot;robot_state_publisher&quot;&gt;        &lt;param name=&quot;publish_frequency&quot; type=&quot;double&quot; value=&quot;30.0&quot; /&gt;    &lt;/node&gt;    &lt;!-- 启动rviz --&gt;    &lt;node name=&quot;rviz&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; args=&quot;-d $(arg rvizconfig)&quot; /&gt;&lt;/launch&gt;</code></pre><h2 id="5-添加插件"><a href="#5-添加插件" class="headerlink" title="5. 添加插件"></a>5. 添加插件</h2><p>在urdf.xacro文件中添加</p><p><strong>摩擦系数</strong></p><pre><code class="xml">    &lt;gazebo reference=&quot;left_wheel&quot;&gt;        &lt;mu1&gt;1&lt;/mu1&gt;        &lt;mu2&gt;1&lt;/mu2&gt;        &lt;material&gt;Gazebo/Black&lt;/material&gt;    &lt;/gazebo&gt;</code></pre><p><strong>差分驱动</strong></p><pre><code class="xml"> &lt;gazebo&gt;    &lt;plugin name=&quot;differential_drive_controller&quot; filename=&quot;libgazebo_ros_diff_drive.so&quot;&gt;        &lt;alwaysOn&gt;true&lt;/alwaysOn&gt;        &lt;updateRate&gt;50.0&lt;/updateRate&gt;        &lt;leftJoint&gt;car_base_left_wheel&lt;/leftJoint&gt;        &lt;rightJoint&gt;car_base_right_wheel&lt;/rightJoint&gt;        &lt;wheelSeparation&gt;1.0&lt;/wheelSeparation&gt;        &lt;wheelDiameter&gt;0.5&lt;/wheelDiameter&gt;        &lt;torque&gt;1.0&lt;/torque&gt;        &lt;commandTopic&gt;cmd_vel&lt;/commandTopic&gt;        &lt;odometryTopic&gt;odom&lt;/odometryTopic&gt;        &lt;odometryFrame&gt;odom&lt;/odometryFrame&gt;        &lt;robotBaseFrame&gt;base_link&lt;/robotBaseFrame&gt;        &lt;publishWheelTF&gt;true&lt;/publishWheelTF&gt;        &lt;publishWheelJointState&gt;true&lt;/publishWheelJointState&gt;        &lt;wheelAcceleration&gt;1&lt;/wheelAcceleration&gt;    &lt;/plugin&gt; &lt;/gazebo&gt;</code></pre><p><strong>IMU</strong></p><pre><code class="xml">&lt;gazebo reference=&quot;imu_link&quot;&gt;    &lt;gravity&gt;true&lt;/gravity&gt;    &lt;sensor name=&quot;imu_sensor&quot; type=&quot;imu&quot;&gt;        &lt;always_on&gt;true&lt;/always_on&gt;        &lt;update_rate&gt;100&lt;/update_rate&gt;        &lt;visualize&gt;true&lt;/visualize&gt;        &lt;topic&gt;__default_topic__&lt;/topic&gt;        &lt;plugin filename=&quot;libgazebo_ros_imu_sensor.so&quot; name=&quot;imu_plugin&quot;&gt;            &lt;topicName&gt;imu&lt;/topicName&gt;            &lt;bodyName&gt;imu_link&lt;/bodyName&gt;            &lt;updateRateHZ&gt;100.0&lt;/updateRateHZ&gt;            &lt;gaussianNoise&gt;0.0&lt;/gaussianNoise&gt;            &lt;xyzOffset&gt;0 0 0&lt;/xyzOffset&gt;            &lt;rpyOffset&gt;0 0 0&lt;/rpyOffset&gt;            &lt;frameName&gt;imu_link&lt;/frameName&gt;        &lt;/plugin&gt;        &lt;pose&gt;0 0 0 0 0 0&lt;/pose&gt;    &lt;/sensor&gt;&lt;/gazebo&gt;</code></pre><p><strong>激光</strong></p><pre><code class="xml">&lt;gazebo reference=&quot;hokuyo_link&quot;&gt;    &lt;material&gt;Gazebo/Blue&lt;/material&gt;    &lt;turnGravityOff&gt;false&lt;/turnGravityOff&gt;    &lt;sensor type=&quot;ray&quot; name=&quot;head_hokuyo_sensor&quot;&gt;        &lt;pose&gt;0.0 ${car_length*0.3} ${(hokuyo_length+car_height)/2.0} 0 0 ${PI/2}&lt;/pose&gt;        &lt;visualize&gt;true&lt;/visualize&gt;        &lt;update_rate&gt;40&lt;/update_rate&gt;        &lt;ray&gt;            &lt;scan&gt;                &lt;horizontal&gt;                    &lt;samples&gt;720&lt;/samples&gt;                    &lt;resolution&gt;1&lt;/resolution&gt;                    &lt;min_angle&gt;-1.570796&lt;/min_angle&gt;                    &lt;max_angle&gt;1.570796&lt;/max_angle&gt;                &lt;/horizontal&gt;            &lt;/scan&gt;            &lt;range&gt;                &lt;min&gt;0.3&lt;/min&gt;                &lt;max&gt;10.0&lt;/max&gt;                &lt;resolution&gt;0.001&lt;/resolution&gt;            &lt;/range&gt;        &lt;/ray&gt;        &lt;plugin name=&quot;gazebo_ros_head_hokuyo_controller&quot; filename=&quot;libgazebo_ros_laser.so&quot;&gt;            &lt;topicName&gt;/scan&lt;/topicName&gt;            &lt;frameName&gt;hokuyo_link&lt;/frameName&gt;        &lt;/plugin&gt;    &lt;/sensor&gt;&lt;/gazebo&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Karto_SLAM</title>
      <link href="/2020/03/06/ROS/Karto_SLAM/"/>
      <url>/2020/03/06/ROS/Karto_SLAM/</url>
      
        <content type="html"><![CDATA[<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p><strong>源码安装</strong></p><p>ROS包：<a href="https://github.com/ros-perception/slam_karto" target="_blank" rel="noopener">slam_karto</a>、<a href="https://github.com/ros-perception/open_karto" target="_blank" rel="noopener">open_carto</a>、<a href="https://github.com/ros-perception/sparse_bundle_adjustment" target="_blank" rel="noopener">sba包</a></p><p>大型稀疏矩阵运算库：<code>sudo apt install libsuitesparse-dev</code></p><p><strong>或apt安装</strong></p><pre><code class="bash">sudo apt install ros-kinetic-slam-karto</code></pre><h3 id="2-运行"><a href="#2-运行" class="headerlink" title="2. 运行"></a>2. 运行</h3><p>节点参数很少</p><pre><code class="xml">&lt;launch&gt;  &lt;node pkg=&quot;slam_karto&quot; type=&quot;slam_karto&quot; name=&quot;slam_karto&quot; output=&quot;screen&quot;&gt;    &lt;remap from=&quot;scan&quot; to=&quot;base_scan&quot;/&gt;    &lt;param name=&quot;odom_frame&quot; value=&quot;odom_combined&quot;/&gt;    &lt;param name=&quot;map_update_interval&quot; value=&quot;25&quot;/&gt;    &lt;param name=&quot;resolution&quot; value=&quot;0.025&quot;/&gt;  &lt;/node&gt;&lt;/launch&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LSD-SLAM</title>
      <link href="/2020/03/06/ROS/LSD-SLAM/"/>
      <url>/2020/03/06/ROS/LSD-SLAM/</url>
      
        <content type="html"><![CDATA[<p>原程序为 <a href="https://github.com/YaoZhiwen/lsd_slam_catkin_16.04" target="_blank" rel="noopener">https://github.com/YaoZhiwen/lsd_slam_catkin_16.04</a> </p><h4 id="安装方法见原说明，但无法编译通过，修改的地方如下："><a href="#安装方法见原说明，但无法编译通过，修改的地方如下：" class="headerlink" title="安装方法见原说明，但无法编译通过，修改的地方如下："></a>安装方法见原说明，但无法编译通过，修改的地方如下：</h4><ol><li><p>因无法正常生成ros消息的头文件，我在另一个package里生成了之后复制到<code>~/catkin_ws/src/lsd_slam/lsd_slam_viewer/src</code>，这两个文件为<code>keyframeMsg.h、keyframeGraphMsg.h</code>。</p></li><li><p>原程序总是有#include错误，如<code>#include &quot;lsd_slam_viewer/KeyFrameDisplay.h&quot;</code>，我把所有的<code>lsd_slam_viewer/</code>都删掉了。</p></li><li><p>OpenCV路径不对，我根据系统中的路径修改<code>~/catkin_ws/src/lsd_slam/lsd_slam_core/CMakeLists.txt</code>文件为：</p></li><li><pre><code class="cmake">set(OpenCV_INCLUDE_DIRS /opt/ros/kinetic/include/opencv-3.3.1-dev)set(OpenCV_LIBS /opt/ros/kinetic/lib/x86_64-linux-gnu/libopencv_core3.so.3.3.1 /opt/ros/kinetic/lib/x86_64-linux-gnu/libopencv_imgproc3.so.3.3.1 /opt/ros/kinetic/lib/x86_64-linux-gnu/libopencv_highgui3.so.3.3.1 /opt/ros/kinetic/lib/x86_64-linux-gnu/libopencv_calib3d3.so.3.3.1)set(OpenCV_DIR /opt/ros/kinetic/share/OpenCV-3.3.1-dev)</code></pre></li><li><p>编译完后，运行报错<code>QObject::startTimer: Timers cannot be started from another thread</code>，将<code>/home/liuly/catkin_ws/src/lsd_slam/lsd_slam_core/src/util/settings.h</code>中的<code>bool displayDepthMap = true;</code>改为<code>bool displayDepthMap = false;</code>。</p></li></ol><h4 id="bag测试"><a href="#bag测试" class="headerlink" title="bag测试"></a>bag测试</h4><pre><code class="sh">roscorerosrun lsd_slam_core live_slam image:=/image_raw camera_info:=/camera_inforosbag play /mnt/hgfs/dataset/LSD_room.bagrosrun lsd_slam_viewer viewer</code></pre><h4 id="D435测试"><a href="#D435测试" class="headerlink" title="D435测试"></a>D435测试</h4><pre><code class="sh">roslaunch realsense2_camera rs_camera.launchrosrun lsd_slam_core live_slam image:=/camera/color/image_raw camera_info:=/camera/color/camera_inforosrun lsd_slam_viewer viewer</code></pre>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ORB-SLAM</title>
      <link href="/2020/03/06/ROS/ORB-SLAM/"/>
      <url>/2020/03/06/ROS/ORB-SLAM/</url>
      
        <content type="html"><![CDATA[<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><pre><code class="sh">git clone https://github.com/raulmur/ORB_SLAM2cd ORB_SLAM2./build.sh#依赖：Pangolin、OpenCV、Eigen3#DBoW2和g2o（ORB-SLAM自带）</code></pre><h3 id="单目测试"><a href="#单目测试" class="headerlink" title="单目测试"></a>单目测试</h3><pre><code class="sh">#下载TMU数据集https://vision.in.tum.de/data/datasets/rgbd-dataset/downloadcd ~/ORB_SLAM./Examples/Monocular/mono_tum ./Vocabulary/ORBvoc.txt ./Examples/Monocular/TUM1.yaml ~/dataset/rgbd_dataset_freiburg1_xyz</code></pre><h3 id="双目测试"><a href="#双目测试" class="headerlink" title="双目测试"></a>双目测试</h3><pre><code class="sh">#EuRoC数据集https://projects.asl.ethz.ch/datasets/doku.php?id=kmavvisualinertialdatasetscd ORB-SLAM./Examples/Stereo/stereo_euroc ./Vocabulary/ORBvoc.txt ./Examples/Stereo/EuRoC.yaml ~/dataset/mav0/cam0/data ~/dataset/mav0/cam1/data ./Examples/Stereo/EuRoC_TimeStamps/MH01.txt</code></pre><h3 id="RGB-D测试"><a href="#RGB-D测试" class="headerlink" title="RGB-D测试"></a>RGB-D测试</h3><pre><code class="sh">#下载TUM数据集https://vision.in.tum.de/data/datasets/rgbd-dataset/downloadcd ~/ORB_SLAM2./Examples/RGB-D/rgbd_tum ./Vocabulary/ORBvoc.txt ./Examples/RGB-D/TUM1.yaml ~/dataset/rgbd_dataset_freiburg1_room/ ~/dataset/rgbd_dataset_freiburg1_room/associate.txt</code></pre><h3 id="ROS安装"><a href="#ROS安装" class="headerlink" title="ROS安装"></a>ROS安装</h3><ul><li><p>把ORB_SLAM2路径添加到ROS包的PATH中</p><pre><code class="sh">echo &quot;export ROS_PACKAGE_PATH=${ROS_PACKAGE_PATH}:~/ORB-SLAM2/Examples/ROS/ORB_SLAM2&quot; &gt;&gt; ~/.bashrc</code></pre></li><li><p>编译</p><pre><code class="sh">cd ~/ORB-SLAM2/Examples/ROS/ORB_SLAM2mkdir buildcd buildcmake .. -DROS_BUILD_TYPE=Releasemake</code></pre></li><li><p>解决<code>_ZN5boost6system15system_categoryEv</code>错误</p><p>修改CMakeLists.txt的LIB设置，尾行添加<code>-lboost_system</code>，变为：</p><pre><code class="makefile">set(LIBS ${OpenCV_LIBS} ${EIGEN3_LIBS}${Pangolin_LIBRARIES}${PROJECT_SOURCE_DIR}/../../../Thirdparty/DBoW2/lib/libDBoW2.so${PROJECT_SOURCE_DIR}/../../../Thirdparty/g2o/lib/libg2o.so${PROJECT_SOURCE_DIR}/../../../lib/libORB_SLAM2.so-lboost_system)</code></pre><p>重新编译</p></li></ul><h3 id="D435-RGB-D测试"><a href="#D435-RGB-D测试" class="headerlink" title="D435 RGB-D测试"></a>D435 RGB-D测试</h3><p>参考<code>D435-ROS.md</code></p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ROS16.04</title>
      <link href="/2020/03/06/ROS/ROS16.04/"/>
      <url>/2020/03/06/ROS/ROS16.04/</url>
      
        <content type="html"><![CDATA[<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p><a href="http://wiki.ros.org/kinetic/Installation/Ubuntu" target="_blank" rel="noopener">http://wiki.ros.org/kinetic/Installation/Ubuntu</a></p><p><strong>设置软件源</strong></p><pre><code class="sh">sudo sh -c &#39;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#39;</code></pre><p><strong>设置key</strong></p><pre><code class="sh">sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116</code></pre><p><strong>安装</strong></p><pre><code class="sh">sudo apt-get updatesudo apt-get install ros-kinetic-desktop-full</code></pre><p><strong>安装软件包</strong></p><pre><code class="sh">sudo apt-get install ros-kinetic-&lt;package&gt;</code></pre><p><strong>搜索软件包</strong></p><pre><code class="sh">apt-cache search ros-kinetic</code></pre><p><strong>初始化rosdp</strong><br>rosdep使您可以轻松地为要编译的源安装系统依赖项，并且需要在ROS中运行一些核心组件</p><pre><code class="sh">sudo rosdep initrosdep update</code></pre><p><strong>设置环境变量</strong></p><pre><code class="sh">echo &quot;source /opt/ros/kinetic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc</code></pre><p><strong>安装工具包</strong></p><pre><code class="sh">sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential</code></pre><h3 id="2-教程"><a href="#2-教程" class="headerlink" title="2. 教程"></a>2. 教程</h3><p><strong>查看环境配置</strong></p><pre><code class="sh">printenv | grep ROS</code></pre><p><strong>创建一个ROS工作区</strong></p><pre><code class="sh">mkdir -p ~/catkin_ws/srccd ~/catkin_ws/catkin_make</code></pre><p><strong>将工作区加入到PATH</strong></p><pre><code class="sh">source ~/catkin_ws/devel/setup.bashecho $ROS_PACKAGE_PATH</code></pre><p><strong>安装示例程序</strong></p><pre><code class="sh">sudo apt-get install ros-kinetic-ros-tutorials</code></pre><h3 id="Filesystem-Tools"><a href="#Filesystem-Tools" class="headerlink" title="Filesystem Tools"></a>Filesystem Tools</h3><p><strong>查找package</strong></p><pre><code class="sh">rospack find roscpp</code></pre><p><strong>进入package目录</strong></p><pre><code class="sh">roscd roscpproscd roscpp/cmakeroscd log</code></pre><p><strong>列出package的文件</strong></p><pre><code class="sh">rosls roscpp_tutorials</code></pre><h3 id="3-创建一个catkin包"><a href="#3-创建一个catkin包" class="headerlink" title="3. 创建一个catkin包"></a>3. 创建一个catkin包</h3><p><strong>进入src目录</strong></p><pre><code class="sh">cd ~/catkin_ws/src</code></pre><p><strong>用catkin_create_pkg创建一个package(后面是依赖)</strong></p><pre><code class="sh">catkin_create_pkg test std_msgs rospy roscppbuild一个catkin工作区并source安装文件cd ~/catkin_wscatkin_make</code></pre><p><strong>package依赖关系</strong></p><pre><code class="sh">rospack depends1 beginner_tutorials    #一阶依赖rospack depends beginner_tutorials    #全部依赖，包含间接依赖</code></pre><p><strong>定制package.xml和CMakeLists.xml</strong><br><a href="http://wiki.ros.org/ROS/Tutorials/CreatingPackage" target="_blank" rel="noopener">http://wiki.ros.org/ROS/Tutorials/CreatingPackage</a><br><strong>build package</strong></p><pre><code class="sh">cd ~/catkin_ws/catkin_make#可以自定义源代码所在目录catkin_make --source my_srccatkin_make install --source my_src</code></pre><h3 id="4-node"><a href="#4-node" class="headerlink" title="4. node"></a>4. node</h3><p><strong>第一步</strong></p><pre><code class="sh">roscore</code></pre><p><strong>显示节点</strong></p><pre><code class="sh">rosnode listrosnode info /rosout</code></pre><p><strong>运行节点</strong></p><pre><code class="sh">rosrun turtlesim turtlesim_noderosrun turtlesim turtlesim_node __name:=my_turtle //启动时修改节点名称</code></pre><p><strong>ping节点</strong></p><pre><code class="sh">rosnode ping my_turtle</code></pre><h3 id="5-topic"><a href="#5-topic" class="headerlink" title="5. topic"></a>5. topic</h3><p><strong>使用rqt_graph</strong></p><pre><code class="sh">sudo apt-get install ros-kinetic-rqtsudo apt-get install ros-kinetic-rqt-common-pluginsrosrun rqt_graph rqt_graph</code></pre><p><strong>实时显示topic中的message</strong></p><pre><code class="sh">rostopic echo /turtle1/cmd_vel</code></pre><p><strong>显示message类型</strong></p><pre><code class="sh">rostopic listrostopic list -vrostopic type /turtle1/cmd_velrosmsg show geometry_msgs/Twistrostopic type /turtle1/cmd_vel | rosmsg show</code></pre><p><strong>发送message到topic</strong></p><pre><code class="sh">#一次rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- &#39;[2.0, 0.0, 0.0]&#39; &#39;[0.0, 0.0, 1.8]&#39;#频率为1Hzrostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- &#39;[2.0, 0.0, 0.0]&#39; &#39;[0.0, 0.0, -1.8]&#39;#数据发送速率rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- &#39;[2.0, 0.0, 0.0]&#39; &#39;[0.0, 0.0, -1.8]&#39;</code></pre><p><strong>数据的滚动时间图</strong></p><pre><code class="sh">rosrun rqt_plot rqt_plot</code></pre><h3 id="6-service"><a href="#6-service" class="headerlink" title="6. service"></a>6. service</h3><p><strong>查看服务</strong></p><pre><code class="sh">rosservice listrosservice type /clear</code></pre><p><strong>调用服务</strong></p><pre><code class="sh">rosservice call /clear</code></pre><p><strong>service的信息</strong></p><pre><code class="sh">rosservice type /spawn | rossrv show</code></pre><p><strong>查找service</strong></p><pre><code class="sh">rosservice find</code></pre><p><strong>查看service的地址</strong></p><pre><code class="sh">rosservice uri</code></pre><h3 id="7-参数"><a href="#7-参数" class="headerlink" title="7. 参数"></a>7. 参数</h3><pre><code class="sh">rosparam list</code></pre><p><strong>修改参数</strong></p><pre><code class="sh">rosparam set /background_r 150</code></pre><p><strong>获取参数值</strong></p><pre><code class="sh">rosparam get /background_grosparam get /</code></pre><p><strong>存储参数</strong></p><pre><code class="sh">rosparam dump params.yaml</code></pre><p><strong>加载参数</strong></p><pre><code class="sh">rosparam load params.yamlrosparam load params.yaml copy</code></pre><h3 id="8-调试"><a href="#8-调试" class="headerlink" title="8. 调试"></a>8. 调试</h3><p><strong>查看日志</strong></p><pre><code class="sh">rosrun rqt_console rqt_console</code></pre><p><strong>修改记录级别</strong></p><pre><code class="sh">rosrun rqt_logger_level rqt_logger_level</code></pre><h3 id="9-roslaunch"><a href="#9-roslaunch" class="headerlink" title="9. roslaunch"></a>9. roslaunch</h3><p><strong>创建启动文件</strong></p><pre><code class="sh">roscd beginner_tutorialsmkdir launchnano launch/abc.launch</code></pre><p><strong>运行启动文件</strong></p><pre><code class="sh">roslaunch beginner_tutorials abc.launch</code></pre><h3 id="10-默认编辑器"><a href="#10-默认编辑器" class="headerlink" title="10. 默认编辑器"></a>10. 默认编辑器</h3><p><strong>设置默认编辑器</strong></p><pre><code class="sh">#在 ~/.bashrc中添加export EDITOR=&#39;nano -w&#39;</code></pre><h3 id="11-创建msg消息文件"><a href="#11-创建msg消息文件" class="headerlink" title="11. 创建msg消息文件"></a>11. 创建msg消息文件</h3><p><strong>创建msg文件</strong></p><pre><code class="sh">roscd beginner_tutorialsmkdir msgecho &quot;int64 num&quot; &gt; msg/Num.msg</code></pre><h3 id="12-修改package-xml"><a href="#12-修改package-xml" class="headerlink" title="12. 修改package.xml"></a>12. 修改package.xml</h3><pre><code class="sh">#package.xml加入以下两行&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;run_depend&gt;message_runtime&lt;/run_depend&gt;</code></pre><h3 id="13-修改CMakeLists-txt文件"><a href="#13-修改CMakeLists-txt文件" class="headerlink" title="13. 修改CMakeLists.txt文件"></a>13. 修改CMakeLists.txt文件</h3><pre><code class="sh">#在fand_package()里加入依赖message_generation#取消注释，加入msg文件 add_message_files(   FILES   Num.msg )#取消注释 generate_messages(   DEPENDENCIES   std_msgs )#编译后测试消息类型cd ~/catkin_ws catkin_makerosmsg show test/Num</code></pre><h3 id="14-创建srv服务文件"><a href="#14-创建srv服务文件" class="headerlink" title="14. 创建srv服务文件"></a>14. 创建srv服务文件</h3><p><strong>创建srv文件</strong></p><pre><code class="sh">nano ~/catkin_ws/srv/test/add.srv</code></pre><p><strong>package.xml不用修改</strong></p><p><strong>修改CMakeLists.txt文件</strong></p><pre><code class="sh">#在fand_package()里加入依赖message_generation#取消注释，增加srv文件 add_service_files(   FILES   sum.srv )#取消注释 generate_messages(   DEPENDENCIES   std_msgs )#检测srvcd ~/catkin_wscatkin_makerossrv show test/sum</code></pre><h3 id="15-发布者和订阅者-Python"><a href="#15-发布者和订阅者-Python" class="headerlink" title="15. 发布者和订阅者(Python)"></a>15. 发布者和订阅者(Python)</h3><pre><code class="sh">roscd beginner_tutorialsmkdir scriptscd scripts</code></pre><p><strong>创建发布者文件</strong></p><pre><code class="sh">nano talker.pychmod +x talker.py</code></pre><p><strong>创建订阅者文件</strong></p><pre><code class="sh">nano listener.pychmod +x listener.py</code></pre><p><strong>build节点</strong></p><pre><code class="sh">cd ~/catkin_wscatkin_make</code></pre><p><strong>测试</strong></p><pre><code class="sh">rosrun beginner_tutorials talker.pyrosrun beginner_tutorials listener.py</code></pre><h3 id="16-发布者和订阅者-C"><a href="#16-发布者和订阅者-C" class="headerlink" title="16. 发布者和订阅者(C++)"></a>16. 发布者和订阅者(C++)</h3><pre><code class="sh">roscd beginner_tutorials</code></pre><p><strong>创建发布者文件</strong></p><pre><code class="sh">nano src/talker1.cpp</code></pre><p><strong>创建订阅者文件</strong></p><pre><code class="sh">nano src/listener1.cpp</code></pre><p><strong>修改CMakeLists.txt，添加…</strong></p><pre><code></code></pre><p><strong>build节点</strong></p><pre><code class="sh">cd ~/catkin_wscatkin_make</code></pre><p>#测试</p><pre><code class="sh">rosrun beginner_tutorials talker1rosrun beginner_tutorials listener1</code></pre><h3 id="17-服务和客户端-Python"><a href="#17-服务和客户端-Python" class="headerlink" title="17. 服务和客户端(Python)"></a>17. 服务和客户端(Python)</h3><pre><code class="sh">roscd beginner_tutorialscd scripts</code></pre><p><strong>编写server node</strong></p><pre><code class="sh">nano add_two_ints_server.pychmod +x add_two_ints_server.py</code></pre><p><strong>编写client node</strong></p><pre><code class="sh">nano add_two_ints_client.pychmod +x add_two_ints_client.py</code></pre><p><strong>build 节点</strong></p><pre><code class="sh">cd ~/catkin_wscatkin_make</code></pre><p><strong>测试</strong></p><pre><code class="sh">rosrun beginner_tutorials add_two_ints_server.pyrosrun beginner_tutorials add_two_ints_client.py 1 3</code></pre><p>#C++略</p><h3 id="18-记录和回放数据"><a href="#18-记录和回放数据" class="headerlink" title="18. 记录和回放数据"></a>18. 记录和回放数据</h3><p><strong>记录所有数据</strong></p><pre><code class="sh">mkdir ~/bagfilescd ~/bagfilesrosbag record -a</code></pre><p><strong>查看数据信息</strong></p><pre><code class="sh">rosbag info 2018-06-22-12-19-01.bag</code></pre><p><strong>播放bag数据</strong></p><pre><code class="sh">rosbag play 2018-06-22-12-19-01.bag#空格暂停，s继续</code></pre><p><strong>两倍速率播放</strong></p><pre><code class="sh">-r 2</code></pre><p><strong>设置起始</strong></p><pre><code class="sh">-s</code></pre><p><strong>仅记录特定的数据(subset为.bag名，后面为topics)</strong></p><pre><code class="sh">rosbag record -O subset /turtle1/cmd_vel /turtle1/pose</code></pre><p>rosbag局限性：时间不准确</p><h3 id="19-rosservice服务"><a href="#19-rosservice服务" class="headerlink" title="19. rosservice服务"></a>19. rosservice服务</h3><p><strong>查看服务</strong></p><pre><code class="sh">rosservice list</code></pre><p><strong>服务信息</strong></p><pre><code class="sh">roservice info /RosAria/set_parameters</code></pre><p><strong>服务的类型信息</strong></p><pre><code class="sh">rossrv show `rosservice type /RosAria/set_parameters`#或rosservice type /RosAria/set_parameters | rossrv show</code></pre>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Package-Cmake</title>
      <link href="/2020/03/06/ROS/Package-Cmake/"/>
      <url>/2020/03/06/ROS/Package-Cmake/</url>
      
        <content type="html"><![CDATA[<h3 id="1-package-xml"><a href="#1-package-xml" class="headerlink" title="1. package.xml"></a>1. package.xml</h3><pre><code class="xml">&lt;buildtool_depend&gt;</code></pre><p>编译工具的依赖包，不需要改</p><pre><code class="xml">&lt;build_depend&gt;</code></pre><p>构建此包所需的包。在构建时需要来自这些包的任何文件时就是这种情况。<br>这可以在编译时include来自这些包的头文件，link来自这些包的库或在构建时需要的任何其他资源</p><pre><code class="xml">&lt;build_export_depend&gt;</code></pre><p>指定针对此包构建库所需的包。如果您将其标头可传递地包含在此程序包的公共标头中，则会出现这种情况<br>一般和<code>&lt;build_depend&gt;</code>一样</p><pre><code class="xml">&lt;exec_depend&gt;</code></pre><p>指定在此包中运行代码所需的包。当您依赖此包中的共享库时就是这种情况<br>一般和<code>&lt;build_depend&gt;</code>一样</p><p>所有包都至少有一个依赖项，一个构建工具依赖于catkin</p><hr><p>可以将<code>&lt;build_depend&gt;</code>、<code>&lt;build_export_depend&gt;</code>、<code>&lt;exec_depend&gt;</code>用一个<code>&lt;depend&gt;</code>代替<br>不推荐用<code>&lt;depend&gt;</code>，因为它会强制您的包的二进制安装依赖于“开发”包，这通常不是必需或不可取的，<code>package.xml</code>的依赖项是在发布的时候有用，不用于编译</p><h3 id="2-CmakeList-txt"><a href="#2-CmakeList-txt" class="headerlink" title="2. CmakeList.txt"></a>2. CmakeList.txt</h3><p><code>CMake</code>不了解<code>package.xml</code>依赖关系。要编译代码，<code>CMakeLists.txt</code>必须明确声明如何解析所有头和库引用</p><h4 id="2-1-查找包的依赖项"><a href="#2-1-查找包的依赖项" class="headerlink" title="2.1 查找包的依赖项"></a>2.1 查找包的依赖项</h4><pre><code class="xml">find_package(catkin REQUIRED COMPONENTS std_msgs rospy roscpp)</code></pre><h4 id="2-2-include路径"><a href="#2-2-include路径" class="headerlink" title="2.2 include路径"></a>2.2 include路径</h4><p>仅当包的子目录包含用于编译程序的头时，才需要include参数</p><pre><code class="xml">include_directories(include ${catkin_INCLUDE_DIRS})</code></pre>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RosAria</title>
      <link href="/2020/03/06/ROS/RosAria/"/>
      <url>/2020/03/06/ROS/RosAria/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前提是已安装ros"><a href="#1-前提是已安装ros" class="headerlink" title="1. 前提是已安装ros"></a>1. 前提是已安装ros</h3><p><a href="http://wiki.ros.org/Robots/AMR_Pioneer_Compatible#Launch_Files_and_Other_Configuration" target="_blank" rel="noopener">http://wiki.ros.org/Robots/AMR_Pioneer_Compatible#Launch_Files_and_Other_Configuration</a></p><p><a href="https://blog.csdn.net/qq_35508344/article/details/77096177" target="_blank" rel="noopener">https://blog.csdn.net/qq_35508344/article/details/77096177</a></p><p><a href="https://blog.csdn.net/David_Han008/article/details/53966532" target="_blank" rel="noopener">https://blog.csdn.net/David_Han008/article/details/53966532</a></p><h3 id="2-安装rosaria"><a href="#2-安装rosaria" class="headerlink" title="2. 安装rosaria"></a>2. 安装rosaria</h3><h4 id="2-1-建立workspace"><a href="#2-1-建立workspace" class="headerlink" title="2.1 建立workspace"></a>2.1 建立workspace</h4><pre><code class="sh">source /opt/ros/kinetic/setup.bashmkdir -p ~/catkin_ws/srccd ~/catkin_wscatkin_makesource ~/catkin_ws/devel/setup.bash</code></pre><h4 id="2-2-下载rosaria源码"><a href="#2-2-下载rosaria源码" class="headerlink" title="2.2 下载rosaria源码"></a>2.2 下载rosaria源码</h4><pre><code class="sh">cd ~/catkin_ws/srcgit clone https://github.com/amor-ros-pkg/rosaria.git</code></pre><h4 id="2-3安装libaria"><a href="#2-3安装libaria" class="headerlink" title="2.3安装libaria"></a>2.3安装libaria</h4><p>下载地址<a href="http://robots.mobilerobots.com/ARIA/download/archives/" target="_blank" rel="noopener">http://robots.mobilerobots.com/ARIA/download/archives/</a></p><pre><code class="sh">sudo dpkg -i libaria_2.9.4+ubuntu16_amd64.deb</code></pre><h4 id="2-4-Build-rosaria"><a href="#2-4-Build-rosaria" class="headerlink" title="2.4 Build rosaria"></a>2.4 Build rosaria</h4><pre><code class="sh">cd ~/catkin_wscatkin_make    #这将构建catkin工作区中的所有包</code></pre><h4 id="2-5-安装MobileSim"><a href="#2-5-安装MobileSim" class="headerlink" title="2.5 安装MobileSim"></a>2.5 安装MobileSim</h4><p><a href="http://robots.mobilerobots.com/wiki/MobileSim" target="_blank" rel="noopener">http://robots.mobilerobots.com/wiki/MobileSim</a></p><h4 id="2-6-运行rosaria节点连接机器人"><a href="#2-6-运行rosaria节点连接机器人" class="headerlink" title="2.6 运行rosaria节点连接机器人"></a>2.6 运行rosaria节点连接机器人</h4><pre><code class="sh">roscorerosrun rosaria RosAriarosrun rosaria RosAria _port:=/dev/ttyUSB0 _baud:=57600 #lx实体机</code></pre><p><strong>注意：</strong>使用rosrun指定参数时，ROS参数系统会自动存储此设置以供将来使用，如果省略该参数，将使用先前设置的值。</p><h4 id="2-7-使用示例程序"><a href="#2-7-使用示例程序" class="headerlink" title="2.7 使用示例程序"></a>2.7 使用示例程序</h4><pre><code class="sh">cd ~/catkin_ws/srcgit clone https://github.com/pengtang/rosaria_client.gitcd ~/catkin_wscatkin_makeroscoreroslaunch rosaria_client rosaria_client_launcher.launch</code></pre><h3 id="3-RosAria的说明"><a href="#3-RosAria的说明" class="headerlink" title="3. RosAria的说明"></a>3. RosAria的说明</h3><h4 id="3-1-查看姿态"><a href="#3-1-查看姿态" class="headerlink" title="3.1 查看姿态"></a>3.1 查看姿态</h4><pre><code class="sh">rostopic echo /RosAria/pose</code></pre><h4 id="3-2-设定速度"><a href="#3-2-设定速度" class="headerlink" title="3.2 设定速度"></a>3.2 设定速度</h4><pre><code class="sh">rostopic pub -1 /RosAria/cmd_vel geometry_msgs/Twist &#39;[0.1, 0.0, 0.0]&#39; &#39;[0.0, 0.0, 0.0]&#39;</code></pre><h4 id="3-3-打开laser"><a href="#3-3-打开laser" class="headerlink" title="3.3 打开laser"></a>3.3 打开laser</h4><p>下次启动会记住设置</p><pre><code class="sh">rosrun rosaria RosAria _publish_aria_lasers:=true</code></pre>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ZED-ROS-RTAB</title>
      <link href="/2020/03/06/ROS/ZED-ROS-RTAB/"/>
      <url>/2020/03/06/ROS/ZED-ROS-RTAB/</url>
      
        <content type="html"><![CDATA[<h2 id="ZED-Ubuntu16-04-ROS"><a href="#ZED-Ubuntu16-04-ROS" class="headerlink" title="ZED Ubuntu16.04 ROS"></a>ZED Ubuntu16.04 ROS</h2><p><a href="https://www.stereolabs.com/docs/ros/" target="_blank" rel="noopener">https://www.stereolabs.com/docs/ros/</a></p><p><a href="https://www.cnblogs.com/zhencv/p/6739061.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhencv/p/6739061.html</a></p><h3 id="安装ZED的ROS包"><a href="#安装ZED的ROS包" class="headerlink" title="安装ZED的ROS包"></a>安装ZED的ROS包</h3><ol><li><p>切换到NV显卡（用的是nvidia-384，重启会自动把显卡切换到840M）</p></li><li><p>安装CUDA</p><p><a href="http://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">下载</a>x86_64/16.04/deb(network)</p><pre><code class="sh">sudo dpkg -i cuda-repo-ubuntu1604_10.1.168-1_amd64.deb#官方添加key的命令不能用，要手动下载再添加#下载地址#http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/7fa2af80.pubsudo apt-key add 7fa2af80.pubsudo apt-get update#安装10.0版本，否则默认的cuda是10.1不能用sudo apt-get install cuda-10-0</code></pre></li><li><p>安装<a href="https://www.stereolabs.com/developers/release/" target="_blank" rel="noopener">ZED SDK</a></p></li><li><p>安装ROS包</p><pre><code class="sh">cd ~/catkin_ws/src/git clone https://github.com/stereolabs/zed-ros-wrapper.gitcd ..catkin_make -DCMAKE_BUILD_TYPE=Release</code></pre></li><li><p>测试</p><pre><code class="sh">#这启动zed节点发布数据供用户使用roslaunch zed_wrapper zed.launch#这是用来演示的启动文件，和上面的冲突roslaunch zed_display_rviz display_zed.launch</code></pre></li></ol><h3 id="安装RTAB-Map"><a href="#安装RTAB-Map" class="headerlink" title="安装RTAB-Map"></a>安装RTAB-Map</h3><p><a href="https://github.com/introlab/rtabmap_ros，参考markdown文件" target="_blank" rel="noopener">https://github.com/introlab/rtabmap_ros，参考markdown文件</a></p><h3 id="apt方式安装"><a href="#apt方式安装" class="headerlink" title="apt方式安装"></a>apt方式安装</h3><pre><code class="sh">sudo apt-get install ros-kinetic-rtabmap-ros</code></pre><h3 id="源码方式安装"><a href="#源码方式安装" class="headerlink" title="源码方式安装"></a>源码方式安装</h3><p><strong>安装依赖</strong></p><pre><code class="sh">sudo apt-get install ros-kinetic-rtabmap ros-kinetic-rtabmap-rossudo apt-get remove ros-kinetic-rtabmap ros-kinetic-rtabmap-ros</code></pre><p><strong>安装RTAB-Map的库</strong></p><pre><code class="sh">cd ~git clone https://github.com/introlab/rtabmap.gitcd rtabmap/buildcmake ..makesudo make install</code></pre><p><strong>安装ros-pkg</strong></p><pre><code class="sh">cd ~/catkin_wsgit clone https://github.com/introlab/rtabmap_ros.git src/rtabmap_roscatkin_make -j1 #单线程编译，不然爆内存</code></pre><h3 id="测试RTAB-Map"><a href="#测试RTAB-Map" class="headerlink" title="测试RTAB-Map"></a>测试RTAB-Map</h3><pre><code class="sh">roslaunch zed_rtabmap_example  zed_rtabmap.launch</code></pre>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gmapping</title>
      <link href="/2020/03/06/ROS/gmapping/"/>
      <url>/2020/03/06/ROS/gmapping/</url>
      
        <content type="html"><![CDATA[<h3 id="1-安装gmapping"><a href="#1-安装gmapping" class="headerlink" title="1. 安装gmapping"></a>1. 安装gmapping</h3><p>直接apt<strong>安装</strong></p><pre><code class="sh">sudo apt install ros-kinetic-gmapping</code></pre><p><strong>或下载源码编译</strong></p><p><em>openslam_gmapping</em> <a href="https://github.com/ros-perception/openslam_gmapping.git" target="_blank" rel="noopener">https://github.com/ros-perception/openslam_gmapping.git</a></p><p><em>gmapping</em> <a href="https://github.com/ros-perception/slam_gmapping.git" target="_blank" rel="noopener">https://github.com/ros-perception/slam_gmapping.git</a></p><p>openslam_gmapping是实现具体算法的包，gmapping对它进行了封装</p><h3 id="2-launch文件"><a href="#2-launch文件" class="headerlink" title="2. launch文件"></a>2. launch文件</h3><pre><code class="xml">  &lt;node name=&quot;gmapping&quot; pkg=&quot;gmapping&quot; type=&quot;slam_gmapping&quot;&gt;    &lt;param name=&quot;base_frame&quot; value=&quot;base_link&quot;/&gt;    &lt;param name=&quot;odom_frame&quot; value=&quot;odom&quot;/&gt;    &lt;param name=&quot;map_frame&quot; value=&quot;map&quot;/&gt;    &lt;param name=&quot;xmin&quot; value=&quot;-10&quot;/&gt;    &lt;param name=&quot;ymin&quot; value=&quot;-10&quot;/&gt;    &lt;param name=&quot;xmax&quot; value=&quot;10&quot;/&gt;    &lt;param name=&quot;ymax&quot; value=&quot;10&quot;/&gt;    &lt;!--本来订阅的是/scan节点，让它订阅/RosAria/sim_S3Series_1_laserscan节点--&gt;    &lt;remap from=&quot;scan&quot; to=&quot;/RosAria/sim_S3Series_1_laserscan&quot;/&gt;  &lt;/node&gt; </code></pre><h3 id="3-参数说明"><a href="#3-参数说明" class="headerlink" title="3. 参数说明"></a>3. 参数说明</h3><p><strong>GMapping包装器使用的参数：</strong></p><pre><code class="jade">&quot;~throttle_scans&quot;: [int] 扔掉每第n次激光扫描&quot;~base_frame&quot;: [string] 用于机器人基础姿势的tf frame_id&quot;~map_frame&quot;: [string] 发布地图上机器人姿势的tf frame_id&quot;~odom_frame&quot;: [string] 从中读取odometry的tf frame_id&quot;~map_update_interval&quot;: [double] 两次重新计算地图之间的时间</code></pre><p><strong>GMapping本身使用的参数：</strong></p><p>激光参数</p><pre><code class="jade">&quot;~/maxRange&quot; [double] 激光扫描的最大范围（默认值：第一条LaserScan消息减1cm）&quot;~/maxUrange&quot; [double] 用于地图构建的激光扫描仪的最大范围（默认值：与maxRange相同）&quot;~/sigma&quot; [double] 扫描匹配过程的标准偏差（单元格）&quot;~/kernelSize&quot; [int] 扫描匹配过程的搜索窗口&quot;~/lstep&quot; [double] 扫描匹配的初始搜索步（线性）&quot;~/astep&quot; [double] 扫描匹配的初始搜索步骤（角度）&quot;~/iterations&quot; [int] ]扫描匹配中的细化步骤数。匹配的最终“精度”分别是lstep * 2 ^（ -  iterations）或astep * 2 ^（ -  iterations）。&quot;~/lsigma&quot; [double] 扫描匹配过程的标准偏差（单激光束）&quot;~/ogain&quot; [double] 平滑可能性的增益&quot;~/lskip&quot; [int] 只拍摄第（n + 1）条激光以计算匹配（0 =拍摄所有光线）&quot;~/minimumScore&quot; [double] 考虑扫描匹配物品结果的最低分数。当使用有限范围（例如5米）的激光扫描仪时，可以避免在大型开放空间中“跳跃”姿势估计（0=默认。分数上升到600+，当遇到“跳跃”估计问题尝试例如50）</code></pre><p>运动模型参数（高斯噪声模型的所有标准偏差）</p><pre><code class="jade">&quot;~/srr&quot; [double] 线性噪声分量（x和y）&quot;~/stt&quot; [double] 角度噪声分量（θ）&quot;~/srt&quot; [double] 线性 -&gt; 角度噪声分量&quot;~/str&quot; [double] 角度 -&gt; 线性噪声分量</code></pre><p>其他</p><pre><code class="jade">&quot;~/linearUpdate&quot; [double] 如果机器人至少移动了这么多米，机器人仅仅处理新的测量值&quot;~/angularUpdate&quot; [double] 如果机器人至少转动了这么多的rad，机器人仅仅处理新的测量值&quot;~/resampleThreshold&quot; [double] 粒子在此处重新采样的阈值。更高意味着更频繁的重采样&quot;~/particles&quot; [int] （固定）粒子数。每个粒子代表机器人行进的可能轨迹</code></pre><p>可能性采样（用于扫描匹配）</p><pre><code class="jade">&quot;~/llsamplerange&quot; [double] 线性范围&quot;~/lasamplerange&quot; [double] 角度范围&quot;~/llsamplestep&quot; [double] 线性步长&quot;~/lasamplestep&quot; [double] 角度步长</code></pre><p>初始地图尺寸和分辨率</p><pre><code class="jade">&quot;~/xmin&quot; [double] 地图中的最小位置[m]&quot;~/ymin&quot; [double] 地图中的最小y位置[m]&quot;~/xmax&quot; [double] 地图中的最大x位置[m]&quot;~/ymax&quot; [double] 地图中的最大y位置[m]&quot;~/delta&quot; [double] 一个像素的大小[m]</code></pre>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>lx总结</title>
      <link href="/2020/03/06/ROS/lx%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/06/ROS/lx%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="1-安装Ubuntu16-04-64位"><a href="#1-安装Ubuntu16-04-64位" class="headerlink" title="1. 安装Ubuntu16.04 64位"></a>1. 安装Ubuntu16.04 64位</h4><ol><li><p>f11选择临时启动项</p></li><li><p>u盘启动后没有操作界面，按Alt+F4会弹出退出界面，点退出会进入试用界面，这时能正常显示桌面</p></li><li><p>系统装好后，设置<a href="https://www.cnblogs.com/xuliangxing/p/7642650.html" target="_blank" rel="noopener">远程桌面</a>。</p><p>由于内置了lvds显示器，分辨率为800x600，远程桌面无法调高分辨率，所以无法运行rviz。</p><p>安装Ubuntu时不显示安装界面，也是由于内置显示器的原因</p></li><li><p>设置ssh：<code>sudo apt install openssh-server</code></p></li></ol><h4 id="2-安装ROS等软件"><a href="#2-安装ROS等软件" class="headerlink" title="2. 安装ROS等软件"></a>2. 安装ROS等软件</h4><ol><li><p><a href="http://wiki.ros.org/cn/kinetic/Installation/Ubuntu" target="_blank" rel="noopener">安装</a>ROS并初始化和建立工作区</p></li><li><p>安装libaria：<code>sudo dpkg -i libaria_2.9.4+ubuntu16_amd64.deb</code></p></li><li><p>安装机器人描述文件：<code>git clone https://github.com/MobileRobots/amr-ros-config</code></p></li><li><p>安装RosAria：<code>git clone https://github.com/amor-ros-pkg/rosaria.git</code></p></li><li><p>安装gmapping：<code>sudo apt install ros-kinetic-gmapping</code></p></li><li><p>launch文件</p><pre><code class="xml">&lt;launch&gt;  &lt;arg name=&quot;urdf&quot; default=&quot;$(find test)/launch/pioneer-lx.urdf&quot; /&gt;  &lt;arg name=&quot;joint_state_gui&quot; default=&quot;False&quot; /&gt;  &lt;param name=&quot;robot_description&quot; textfile=&quot;$(arg urdf)&quot; /&gt;  &lt;node name=&quot;RosAria&quot; pkg=&quot;rosaria&quot; type=&quot;RosAria&quot; args=&quot;_port:=/dev/ttyUSB0 _baud:=57600 _publish_aria_lasers:=true&quot;/&gt;   &lt;node name=&quot;joint_state_publisher&quot; pkg=&quot;joint_state_publisher&quot; type=&quot;joint_state_publisher&quot; /&gt;  &lt;node name=&quot;robot_state_publisher&quot; pkg=&quot;robot_state_publisher&quot; type=&quot;state_publisher&quot; /&gt;  &lt;node name=&quot;gmapping&quot; pkg=&quot;gmapping&quot; type=&quot;slam_gmapping&quot;&gt;    &lt;remap from=&quot;scan&quot; to=&quot;/RosAria/S3Series_1_laserscan&quot;/&gt;    &lt;param name=&quot;base_frame&quot; value=&quot;base_link&quot;/&gt;    &lt;param name=&quot;odom_frame&quot; value=&quot;odom&quot;/&gt;    &lt;param name=&quot;map_frame&quot; value=&quot;map&quot;/&gt;    &lt;param name=&quot;xmin&quot; value=&quot;-10&quot;/&gt;    &lt;param name=&quot;ymin&quot; value=&quot;-10&quot;/&gt;    &lt;param name=&quot;xmax&quot; value=&quot;10&quot;/&gt;    &lt;param name=&quot;ymax&quot; value=&quot;10&quot;/&gt;  &lt;/node&gt; &lt;/launch&gt;</code></pre></li><li><p>相关命令</p><p>demo程序：<code>/usr/local/Aria/examples/demo -robotPort /dev/ttyUSB0 -robotBaud 57600</code></p><p>RosAria连接：<code>rosrun rosaria RosAria _port:=/dev/ttyUSB0 _baud:=57600</code></p></li></ol><h4 id="3-主从机通信的配置"><a href="#3-主从机通信的配置" class="headerlink" title="3. 主从机通信的配置"></a>3. 主从机通信的配置</h4><p><strong>lx修改</strong></p><p><code>/etc/hosts</code>中添加</p><pre><code>10.113.55.152    liuly-ubuntu</code></pre><p><strong>笔记本修改</strong></p><p><code>~/.bashrc</code>中添加</p><pre><code>ROS_MASTER_URI=http://lx-ubuntu:11311</code></pre><p><code>/etc/hosts</code>中添加</p><pre><code>10.113.38.26    lx-ubuntu</code></pre><h4 id="4-rviz中无法显示laserscan"><a href="#4-rviz中无法显示laserscan" class="headerlink" title="4. rviz中无法显示laserscan"></a>4. rviz中无法显示<code>laserscan</code></h4><p>​    RosAria发布两个激光topics（不知道为什么有两个）：<code>/RosAria/S3Series_1_laserscan</code>和<code>/RosAria/tim3XX_2_laserscan</code></p><p>​    这两个laserscan数据中的坐标系都是<code>laser_frame</code>，而<code>/tf</code>中的坐标系是<code>laser\x01_frame</code>和<code>laser\x02_frame</code>，应该是RosAria的bug</p><p>解决办法是只使用<code>S3Series_1_laserscan</code>中的数据：修改文件<code>~/catkin_ws/src/rosaria/LaserPublisher.cpp</code>，将<code>laser_frame</code>替换为<code>laser\x01_frame</code></p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>map_server</title>
      <link href="/2020/03/06/ROS/map_server/"/>
      <url>/2020/03/06/ROS/map_server/</url>
      
        <content type="html"><![CDATA[<p><a href="http://wiki.ros.org/map_server" target="_blank" rel="noopener">http://wiki.ros.org/map_server</a></p><h3 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h3><p>map_server提供<code>map_server</code> 节点，它提供地图数据作为service可以被调用。它还提供了<code>map_saver</code>命令行实用程序，它允许将动态生成的映射保存到文件中。</p><p>需要先安装</p><pre><code class="sh">sudo apt install ros-kinetic-map-server</code></pre><h3 id="2-地图格式"><a href="#2-地图格式" class="headerlink" title="2. 地图格式"></a>2. 地图格式</h3><p>由此包中的工具操纵的地图存储在一对文件中。<strong>YAML</strong>文件描述了地图元数据，并命名了图像文件。<strong>图像文件</strong>对占用数据进行编码。</p><h4 id="2-1-YAML格式"><a href="#2-1-YAML格式" class="headerlink" title="2.1 YAML格式"></a>2.1 YAML格式</h4><pre><code class="yaml">image: testmap.png #图像文件路径resolution: 0.1 #分辨率，meters / pixel （米/像素）origin: [0.0, 0.0, 0.0] #原点，地图中左下角像素的二维姿态(x,y,yaw)，yaw表示逆时针旋转occupied_thresh: 0.65 #占用概率大于此阈值的像素被视为完全占用free_thresh: 0.196 #占用概率小于此阈值的像素被认为是没占用(自由)negate: 0 #是否应该反转 白/黑 自由/占用 的语义(阈值的解释不受影响)mode: trinary #三种模式可选：trinary,scale或raw</code></pre><h4 id="2-2-数值解释"><a href="#2-2-数值解释" class="headerlink" title="2.2 数值解释"></a>2.2 数值解释</h4><p>如果像素的COLOR(颜色)值<code>x</code>在<code>[0,256]</code>范围内，那么在放入ROS消息时我们应该如何解释这个值？首先，我们将整数<code>x</code>转换为浮点数<code>p</code>，具体取决于yaml 对<code>negate</code>标志的解释：</p><ul><li><p>如果<code>negative: 0</code>，则<code>p = (255 - x) / 255.0</code>，即黑色(0)对应<code>1.0</code>，白色(255)对应<code>0.0</code></p></li><li><p>如果<code>negative: 1</code>，则<code>p = x / 255.0</code>，这是图像的非标准解释，这就是为什么它被称为否定</p></li></ul><p><strong>trinary</strong></p><ul><li><p><code>p &gt; occupied_thresh</code>时，输出值为<code>100</code>，表示完全占用</p></li><li><p><code>p &lt; free_thresh</code>时，输出值为<code>0</code>，表示空闲</p></li><li><p>否则，输出<code>-1</code>或<code>255</code>(unsigned char)，表示未知</p></li></ul><p><strong>scale</strong></p><p>这将调整上述解释，以允许比三元组更多的输出值</p><ul><li><p>如前所述，如果<code>p&gt; occupied_thresh</code>，则输出值<code>100</code>；如果<code>p &lt;free_thresh</code>，则输出值<code>0</code></p></li><li><p>否则，输出<code>99 * (p - free_thresh) / (occupied_thresh - free_thresh)</code>，将输出范围为<code>[0,100]</code>的完整渐变值</p></li></ul><p><strong>raw</strong></p><p>此模式将为每个像素输出<code>x</code>，因此输出范围为<code>[0,255]</code></p><h3 id="3-命令行工具"><a href="#3-命令行工具" class="headerlink" title="3. 命令行工具"></a>3. 命令行工具</h3><h4 id="3-1-map-server"><a href="#3-1-map-server" class="headerlink" title="3.1 map_server"></a>3.1 map_server</h4><p><code>map_server</code>是一个ROS节点，它从磁盘读取地图并通过ROS服务提供它。<code>map_server</code>的当前实现将地图图像数据中的颜色值转换为三元占用值：free (0),occupied(100)和unknown(-1)。此工具的未来版本可以使用0到100之间的值来传达更精细的占用等级。</p><pre><code class="sh">rosrun map_server map_server mymap.yaml</code></pre><p><strong>Topics</strong></p><pre><code class="yaml">map_metadata (nav_msgs/MapMetaData) #地图元数据map (nav_msgs/OccupancyGrid) #地图</code></pre><p><strong>Services</strong></p><pre><code class="yaml">static_map (nav_msgs/GetMap) #通过此服务检索地图</code></pre><p><strong>Parameters</strong></p><pre><code class="yaml">~frame_id (string, default: &quot;map&quot;) #地图的坐标系</code></pre><h4 id="3-2-map-saver"><a href="#3-2-map-saver" class="headerlink" title="3.2 map_saver"></a>3.2 map_saver</h4><p><code>map_saver</code>将地图保存到磁盘，例如，从SLAM制图服务。</p><pre><code class="sh">rosrun map_server map_saver -f mymap #-f指定名称，默认名称为map</code></pre>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>robot_pose_ekf</title>
      <link href="/2020/03/06/ROS/robot_pose_ekf/"/>
      <url>/2020/03/06/ROS/robot_pose_ekf/</url>
      
        <content type="html"><![CDATA[<h3 id="1-里程计IMU融合robot-pose-ekf"><a href="#1-里程计IMU融合robot-pose-ekf" class="headerlink" title="1. 里程计IMU融合robot_pose_ekf"></a>1. 里程计IMU融合<code>robot_pose_ekf</code></h3><p>订阅的主题：<code>/odom</code>、<code>/imu_data</code></p><p>发布的主题：<code>/robot_pose_ekf/odom_combined</code></p><p>发布的tf：odom_combined<code>→</code>base_footprint</p><h4 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h4><pre><code class="bash">sudo apt install ros-kinetic-robot-pose-ekfrosdep install robot_pose_ekfroscd robot_pose_ekfrosmake</code></pre><h4 id="1-2-launch文件"><a href="#1-2-launch文件" class="headerlink" title="1.2 launch文件"></a>1.2 launch文件</h4><pre><code class="xml">    &lt;node pkg=&quot;robot_pose_ekf&quot; type=&quot;robot_pose_ekf&quot; name=&quot;robot_pose_ekf&quot;&gt;        &lt;param name=&quot;output_frame&quot; value=&quot;odom&quot;/&gt;        &lt;param name=&quot;freq&quot; value=&quot;30.0&quot;/&gt;        &lt;param name=&quot;sensor_timeout&quot; value=&quot;1.0&quot;/&gt;        &lt;param name=&quot;odom_used&quot; value=&quot;true&quot;/&gt;        &lt;param name=&quot;imu_used&quot; value=&quot;true&quot;/&gt;        &lt;param name=&quot;vo_used&quot; value=&quot;false&quot;/&gt;        &lt;param name=&quot;debug&quot; value=&quot;false&quot;/&gt;        &lt;param name=&quot;self_diagnose&quot; value=&quot;false&quot;/&gt;    &lt;/node&gt;</code></pre><h4 id="1-3-odom里程计数据："><a href="#1-3-odom里程计数据：" class="headerlink" title="1.3 /odom里程计数据："></a>1.3 <code>/odom</code>里程计数据：</h4><p>tf只有position和orientation。odom有位姿、速度、协方差。</p><pre><code class="yaml">header:   seq: 1112  stamp:     secs: 22    nsecs: 415000000  frame_id: &quot;odom&quot;child_frame_id: &quot;base_link&quot;pose:   pose:     position:       x: -8.24608844519e-06      y: -0.000178601022118      z: -1.45735762347e-09    orientation:       x: -1.19448094995e-09      y: -4.32005549201e-08      z: 2.01247894141e-06      w: 0.999999999998  covariance: [1e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1000000000000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1000000000000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1000000000000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.001]twist:   twist:     linear:       x: 1.97446405576e-05      y: -8.1309133873e-06      z: 0.0    angular:       x: 0.0      y: 0.0      z: 8.58624585776e-07  covariance: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]---</code></pre><h4 id="1-4-imu数据：（九轴）"><a href="#1-4-imu数据：（九轴）" class="headerlink" title="1.4 imu数据：（九轴）"></a>1.4 <code>imu</code>数据：（九轴）</h4><pre><code class="yaml">header:   seq: 793  stamp:     secs: 79    nsecs: 579000000  frame_id: &quot;imu_link&quot; //IMU的位置orientation:             //磁场方向及协方差  x: -1.29253276193e-09  y: 3.07688575148e-08  z: 4.41769886557e-06  w: 0.99999999999orientation_covariance: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]angular_velocity:         //角加速度及协方差  x: -1.95721709783e-07  y: 0.000147919743856  z: -6.89713308081e-07angular_velocity_covariance: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]linear_acceleration:     //线加速度及协方差  x: -6.03044763088e-07  y: -2.53367623617e-08  z: 9.8linear_acceleration_covariance: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]---</code></pre>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>rosbag</title>
      <link href="/2020/03/06/ROS/rosbag/"/>
      <url>/2020/03/06/ROS/rosbag/</url>
      
        <content type="html"><![CDATA[<h3 id="使用rosbag记录数据"><a href="#使用rosbag记录数据" class="headerlink" title="使用rosbag记录数据"></a>使用<code>rosbag</code>记录数据</h3><pre><code class="bash">MobileSim -m /usr/local/MobileSim/AMROffice.map -r pioneer-lxroscorerosrun rosaria RosAria _publish_aria_lasers:=truerosbag record -a</code></pre><h3 id="播放数据"><a href="#播放数据" class="headerlink" title="播放数据"></a>播放数据</h3><pre><code class="bash">rosbag  play  2019-04-26-18-34-52.bag</code></pre>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>rviz</title>
      <link href="/2020/03/06/ROS/rviz/"/>
      <url>/2020/03/06/ROS/rviz/</url>
      
        <content type="html"><![CDATA[<h1 id="Displays"><a href="#Displays" class="headerlink" title="Displays"></a>Displays</h1><p><strong>Axes</strong><br>显示一组轴<br><strong>Effort</strong><br>显示放入机器人每个旋转关节的力度<br><strong>Camera</strong><br>从相机的角度创建一个新的渲染窗口，并将图像叠加在其上<br><strong>Grid</strong><br>沿平面显示2D或3D网格<br><strong>Grid Cells</strong><br>从网格中绘制单元格，通常是来自导航堆栈的成本映射的障碍物。<br><strong>Image</strong><br>使用Image创建新的渲染窗口。与相机显示器不同，此显示器不使用CameraInfo。版本：Diamondback +<br><strong>InteractiveMarker</strong><br>显示来自一个或多个Interactive Marker服务器的3D对象，并允许鼠标与它们进行交互。 版本：电动+<br><strong>Laser Scan</strong><br>显示激光扫描的数据，具有渲染模式，累积等的不同选项。<br><strong>Map</strong><br>在地平面上显示地图。<br><strong>Markers</strong><br>允许程序员通过主题显示任意原始形状<br><strong>Path</strong><br>显示导航堆栈中的路径。<br><strong>Point</strong><br>绘制一个点作为一个小球体。<br><strong>Pose</strong><br>将姿势绘制为箭头或轴。<br><strong>Pose Array</strong><br>绘制一个箭头的“云”，一个姿势数组中的每个姿势一个<br><strong>Point Cloud(2)</strong><br>显示来自点云的数据，具有渲染模式，累积等的不同选项。<br><strong>Polygon</strong><br>将多边形的轮廓绘制为线条。<br><strong>Odometry</strong><br>随着时间的推移累积里程表姿势。<br><strong>Range</strong>显示表示声纳或红外范围传感器范围测量值的锥体。 版本：电动+<br><strong>RobotModel</strong><br>以正确姿势显示机器人的可视化表示（由当前TF变换定义）。<br><strong>TF</strong><br>显示tf变换层次结构。<br><strong>Wrench</strong><br>绘制扳手为箭头（力）和箭头+圆（扭矩）<br><strong>Oculus</strong><br>将RViz场景渲染到Oculus耳机</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tf基础</title>
      <link href="/2020/03/06/ROS/tf%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/03/06/ROS/tf%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h4 id="http-wiki-ros-org-tf-Tutorials"><a href="#http-wiki-ros-org-tf-Tutorials" class="headerlink" title="http://wiki.ros.org/tf/Tutorials/"></a><a href="http://wiki.ros.org/tf/Tutorials/" target="_blank" rel="noopener">http://wiki.ros.org/tf/Tutorials/</a></h4><h3 id="1-演示"><a href="#1-演示" class="headerlink" title="1. 演示"></a>1. 演示</h3><p><strong>安装Demo</strong></p><pre><code class="sh">sudo apt-get install ros-kinetic-ros-tutorials ros-kinetic-geometry-tutorials ros-kinetic-rviz ros-kinetic-rosbash ros-kinetic-rqt-tf-tree</code></pre><p><strong>运行Demo</strong></p><pre><code class="sh">roslaunch turtle_tf turtle_tf_demo.launch</code></pre><p>可以用方向键控制中心龟运动，另一个龟会跟着它，直到重合。另一只龟一直朝向中心龟，所以运动轨迹是弧形。</p><p><strong>原理</strong></p><p>这个演示使用tf库创建三个框架(坐标系)：世界框架，乌龟1框架和乌龟2框架。本教程使用tf发布器发布乌龟坐标框架和tf监听器来计算乌龟框架的差异，并移动一只乌龟来跟随另一只乌龟。</p><h3 id="2-tf工具"><a href="#2-tf工具" class="headerlink" title="2. tf工具"></a>2. tf工具</h3><p>现在让我们看看如何使用tf来创建这个演示。我们可以使用tf工具来查看幕后的工作。</p><p><strong>使用view_frames</strong></p><pre><code class="sh">rosrun tf view_frames</code></pre><p>会生成pdf文件，在这里我们可以看到由tf广播的三个框架：world，turtle1和turtle2。我们还可以看到world是turtle1和turtle2帧的父级。出于调试目的，view_frames还会报告有关何时收到最旧和最近的帧变换以及将tf帧发布到tf的速度的一些诊断信息。</p><p><strong>使用rqt_tf_tree</strong></p><pre><code class="sh">rosrun rqt_tf_tree rqt_tf_tree</code></pre><p>和刚才图像类似</p><p><strong>使用tf_echo</strong></p><pre><code class="sh">rosrun tf tf_echo [reference_frame] [target_frame]</code></pre><p>例如</p><pre><code class="sh">rosrun tf tf_echo turtle1 turtle2</code></pre><p>显示格式为</p><pre><code>At time 1416409795.450- Translation: [0.000, 0.000, 0.000]- Rotation: in Quaternion [0.000, 0.000, 0.914, 0.405]            in RPY [0.000, -0.000, 2.308]</code></pre><p>当你驾驶你的乌龟时，你会看到变换随着两只乌龟相对移动而变化。</p><p><strong>/tf话题的内容</strong></p><pre><code class="sh">rostopic echo  /tf</code></pre><p>内容如下：</p><pre><code class="sh">transforms:   -     header:       seq: 0      stamp:         secs: 1542251108        nsecs:  27065038      frame_id: &quot;world&quot;    child_frame_id: &quot;turtle1&quot;    transform:       translation:         x: 0.550171077251        y: 3.50581622124        z: 0.0      rotation:         x: 0.0        y: 0.0        z: 0.794140891677        w: 0.607733695105</code></pre><p>会循环播放turtle1和turtle2</p><h3 id="3-rviz和tf"><a href="#3-rviz和tf" class="headerlink" title="3. rviz和tf"></a>3. rviz和tf</h3><p>rviz是一个可视化工具，可用于检查tf帧。让我们用rviz来看看龟框架。让我们使用rviz的-d选项使用turtle_tf配置文件启动rviz：</p><pre><code class="sh">rosrun rviz rviz -d `rospack find turtle_tf`/rviz/turtle_rviz.rviz</code></pre><p>在侧栏中，您将看到由tf广播的帧。当你驾驶乌龟时，你会看到坐标框架在rviz中移动。</p><h3 id="4-编写一个tf广播器-Python"><a href="#4-编写一个tf广播器-Python" class="headerlink" title="4. 编写一个tf广播器(Python)"></a>4. 编写一个tf广播器(Python)</h3><h4 id="创建一个新的ros包"><a href="#创建一个新的ros包" class="headerlink" title="创建一个新的ros包"></a>创建一个新的ros包</h4><pre><code class="sh">cd ~/catkin_ws/srccatkin_create_pkg learning_tf tf roscpp rospy turtlesimcd ~/catkin_wscatkin_make</code></pre><h4 id="创建文件nodes-turtle-tf-broadcaster-py并添加执行权限"><a href="#创建文件nodes-turtle-tf-broadcaster-py并添加执行权限" class="headerlink" title="创建文件nodes/turtle_tf_broadcaster.py并添加执行权限"></a>创建文件<code>nodes/turtle_tf_broadcaster.py</code>并添加执行权限</h4><pre><code class="python">#!/usr/bin/env python#coding=utf-8import roslib#roslib.load_manifest(&#39;learning_tf&#39;)import rospyimport tfimport turtlesim.msg#本程序订阅/turtleX/pose的姿态数据，据此创建/world到/turtleX的坐标变换，发布到/tf主题上# 每收到一次turtleX/pose的消息，运行此函数def handle_turtle_pose(msg, turtlename):    br = tf.TransformBroadcaster()    br.sendTransform((msg.x, msg.y, 0),                     tf.transformations.quaternion_from_euler(0, 0, msg.theta),                     rospy.Time.now(),                     turtlename,#子坐标系                     &quot;world&quot;)#父坐标系if __name__ == &#39;__main__&#39;:    rospy.init_node(&#39;turtle_tf_broadcaster&#39;)# 读取参数（乌龟名称），该节点只有这一个参数    turtlename = rospy.get_param(&#39;~turtle&#39;)# 本节点订阅主题“turtleX/pose”并在每个传入消息上运行函数handle_turtle_pose    rospy.Subscriber(&#39;/%s/pose&#39; % turtlename,                     turtlesim.msg.Pose,                     handle_turtle_pose,                     turtlename)    rospy.spin()</code></pre><h4 id="创建文件launch-start-demo-launch"><a href="#创建文件launch-start-demo-launch" class="headerlink" title="创建文件launch/start_demo.launch"></a>创建文件<code>launch/start_demo.launch</code></h4><pre><code class="xml">&lt;launch&gt;    &lt;!-- Turtlesim Node--&gt;    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;sim&quot;/&gt;    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;teleop&quot; output=&quot;screen&quot;/&gt;    &lt;node name=&quot;turtle1_tf_broadcaster&quot; pkg=&quot;learning_tf&quot; type=&quot;turtle_tf_broadcaster.py&quot; respawn=&quot;false&quot; output=&quot;screen&quot; &gt;      &lt;param name=&quot;turtle&quot; type=&quot;string&quot; value=&quot;turtle1&quot; /&gt;    &lt;/node&gt;    &lt;node name=&quot;turtle2_tf_broadcaster&quot; pkg=&quot;learning_tf&quot; type=&quot;turtle_tf_broadcaster.py&quot; respawn=&quot;false&quot; output=&quot;screen&quot; &gt;      &lt;param name=&quot;turtle&quot; type=&quot;string&quot; value=&quot;turtle2&quot; /&gt;     &lt;/node&gt;  &lt;/launch&gt;</code></pre><h3 id="5-编写一个tf广播器-C"><a href="#5-编写一个tf广播器-C" class="headerlink" title="5. 编写一个tf广播器(C++)"></a>5. 编写一个tf广播器(C++)</h3><h4 id="创建一个新的ros包-1"><a href="#创建一个新的ros包-1" class="headerlink" title="创建一个新的ros包"></a>创建一个新的ros包</h4><p>同上</p><h4 id="创建文件src-turtle-tf-broadcaster-cpp"><a href="#创建文件src-turtle-tf-broadcaster-cpp" class="headerlink" title="创建文件src/turtle_tf_broadcaster.cpp"></a>创建文件<code>src/turtle_tf_broadcaster.cpp</code></h4><pre><code class="c++">#include &lt;ros/ros.h&gt;#include &lt;tf/transform_broadcaster.h&gt;#include &lt;turtlesim/Pose.h&gt;std::string turtle_name;//收到/turtleX/pose的消息时调用该回调函数void poseCallback(const turtlesim::PoseConstPtr&amp; msg){  static tf::TransformBroadcaster br;  tf::Transform transform;  transform.setOrigin( tf::Vector3(msg-&gt;x, msg-&gt;y, 0.0) );//起始位置  tf::Quaternion q;  q.setRPY(0, 0, msg-&gt;theta);  transform.setRotation(q);  br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), &quot;world&quot;, turtle_name));}int main(int argc, char** argv){  ros::init(argc, argv, &quot;my_tf_broadcaster&quot;);  if (argc != 2){ROS_ERROR(&quot;need turtle name as argument&quot;); return -1;};  turtle_name = argv[1];  ros::NodeHandle node;  ros::Subscriber sub = node.subscribe(turtle_name+&quot;/pose&quot;, 10, &amp;poseCallback);  ros::spin();  return 0;};</code></pre><h4 id="在CMakeLists-txt文件中添加"><a href="#在CMakeLists-txt文件中添加" class="headerlink" title="在CMakeLists.txt文件中添加"></a>在<code>CMakeLists.txt</code>文件中添加</h4><pre><code class="cmake">add_executable(turtle_tf_broadcaster src/turtle_tf_broadcaster.cpp)target_link_libraries(turtle_tf_broadcaster ${catkin_LIBRARIES})</code></pre><p>然后编译一下</p><h4 id="创建文件launch-start-demo-launch-1"><a href="#创建文件launch-start-demo-launch-1" class="headerlink" title="创建文件launch/start_demo.launch"></a>创建文件<code>launch/start_demo.launch</code></h4><pre><code class="xml">  &lt;launch&gt;    &lt;!-- Turtlesim Node--&gt;    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;sim&quot;/&gt;    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;teleop&quot; output=&quot;screen&quot;/&gt;    &lt;!-- Axes --&gt;    &lt;param name=&quot;scale_linear&quot; value=&quot;2&quot; type=&quot;double&quot;/&gt;    &lt;param name=&quot;scale_angular&quot; value=&quot;2&quot; type=&quot;double&quot;/&gt;    &lt;node pkg=&quot;learning_tf&quot; type=&quot;turtle_tf_broadcaster&quot;          args=&quot;/turtle1&quot; name=&quot;turtle1_tf_broadcaster&quot; /&gt;    &lt;node pkg=&quot;learning_tf&quot; type=&quot;turtle_tf_broadcaster&quot;          args=&quot;/turtle2&quot; name=&quot;turtle2_tf_broadcaster&quot; /&gt;  &lt;/launch&gt;</code></pre><h3 id="6-编写一个tf监听器-Python"><a href="#6-编写一个tf监听器-Python" class="headerlink" title="6. 编写一个tf监听器(Python)"></a>6. 编写一个tf监听器(Python)</h3><h4 id="创建文件nodes-turtle-tf-listener-py"><a href="#创建文件nodes-turtle-tf-listener-py" class="headerlink" title="创建文件nodes/turtle_tf_listener.py"></a>创建文件<code>nodes/turtle_tf_listener.py</code></h4><pre><code class="python">#!/usr/bin/env python#coding=utf-8import roslibroslib.load_manifest(&#39;learning_tf&#39;)import rospyimport mathimport tfimport geometry_msgs.msgimport turtlesim.srvif __name__ == &#39;__main__&#39;:    rospy.init_node(&#39;turtle_tf_listener&#39;)    listener = tf.TransformListener()#创建一只乌龟，起始位置在(4,2,0)    rospy.wait_for_service(&#39;spawn&#39;)    spawner = rospy.ServiceProxy(&#39;spawn&#39;, turtlesim.srv.Spawn)    spawner(4, 2, 0, &#39;turtle2&#39;)    turtle_vel = rospy.Publisher(&#39;turtle2/cmd_vel&#39;, geometry_msgs.msg.Twist,queue_size=1)    rate = rospy.Rate(10.0)    while not rospy.is_shutdown():        try:            (trans,rot) = listener.lookupTransform(&#39;/turtle2&#39;, &#39;/turtle1&#39;, rospy.Time(0))        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):            continue        angular = 4 * math.atan2(trans[1], trans[0])        linear = 0.5 * math.sqrt(trans[0] ** 2 + trans[1] ** 2)        cmd = geometry_msgs.msg.Twist()        cmd.linear.x = linear        cmd.angular.z = angular        turtle_vel.publish(cmd)        rate.sleep()</code></pre><p>添加执行权限</p><h4 id="在launch文件中添加"><a href="#在launch文件中添加" class="headerlink" title="在launch文件中添加"></a>在<code>launch</code>文件中添加</h4><pre><code class="xml">&lt;node pkg=&quot;learning_tf&quot; type=&quot;turtle_tf_listener.py&quot; name=&quot;listener&quot; /&gt;</code></pre><h3 id="7-编写一个tf监听器-C"><a href="#7-编写一个tf监听器-C" class="headerlink" title="7. 编写一个tf监听器(C++)"></a>7. 编写一个tf监听器(C++)</h3><h4 id="创建文件src-turtle-tf-listener-cpp"><a href="#创建文件src-turtle-tf-listener-cpp" class="headerlink" title="创建文件src/turtle_tf_listener.cpp"></a>创建文件<code>src/turtle_tf_listener.cpp</code></h4><pre><code class="c++">#include &lt;ros/ros.h&gt;#include &lt;tf/transform_listener.h&gt;#include &lt;geometry_msgs/Twist.h&gt;#include &lt;turtlesim/Spawn.h&gt;//本程序先调用turtlesim的服务spawn创建一只乌龟//然后根据/turtle2和/turtle1的坐标变换数据，向/turtle2发布控制指令int main(int argc, char** argv){  ros::init(argc, argv, &quot;my_tf_listener&quot;);  ros::NodeHandle node;//调用spawn服务，添加一致乌龟，未指定起始位置，所以运行时会报错，并将乌龟2放在左下角  ros::service::waitForService(&quot;spawn&quot;);  ros::ServiceClient add_turtle =    node.serviceClient&lt;turtlesim::Spawn&gt;(&quot;spawn&quot;);  turtlesim::Spawn srv;  add_turtle.call(srv);//发布turtle2的控制指令  ros::Publisher turtle_vel =    node.advertise&lt;geometry_msgs::Twist&gt;(&quot;turtle2/cmd_vel&quot;, 10);  tf::TransformListener listener;  ros::Rate rate(10.0);  while (node.ok()){    tf::StampedTransform transform;    try{//读取最近的turtle2坐标系到turtle1坐标系的转换，保存在transform中      listener.lookupTransform(&quot;/turtle2&quot;, &quot;/turtle1&quot;,                               ros::Time(0), transform);//Time(0)表示缓冲区中最新可用的变换    }    catch (tf::TransformException &amp;ex) {      ROS_ERROR(&quot;%s&quot;,ex.what());      ros::Duration(1.0).sleep();      continue;    }//发布消息    geometry_msgs::Twist vel_msg;    vel_msg.angular.z = 4.0 * atan2(transform.getOrigin().y(),//转向角度为误差的4倍                                    transform.getOrigin().x());    vel_msg.linear.x = 0.5 * sqrt(pow(transform.getOrigin().x(), 2) +                                  pow(transform.getOrigin().y(), 2));//前进距离为距离的一半    turtle_vel.publish(vel_msg);    rate.sleep();  }  return 0;};</code></pre><h4 id="在CMakeLists-txt文件中添加-1"><a href="#在CMakeLists-txt文件中添加-1" class="headerlink" title="在CMakeLists.txt文件中添加"></a>在<code>CMakeLists.txt</code>文件中添加</h4><pre><code class="cmake">add_executable(turtle_tf_listener src/turtle_tf_listener.cpp)target_link_libraries(turtle_tf_listener ${catkin_LIBRARIES})</code></pre><p>然后编译一下</p><h4 id="在launch文件中添加-1"><a href="#在launch文件中添加-1" class="headerlink" title="在launch文件中添加"></a>在<code>launch</code>文件中添加</h4><pre><code class="xml">&lt;node pkg=&quot;learning_tf&quot; type=&quot;turtle_tf_listener&quot; name=&quot;listener&quot; /&gt;</code></pre><h3 id="8-添加一个坐标系变换-Python"><a href="#8-添加一个坐标系变换-Python" class="headerlink" title="8. 添加一个坐标系变换(Python)"></a>8. 添加一个坐标系变换(Python)</h3><h4 id="创建文件nodes-fixed-tf-broadcaster-py"><a href="#创建文件nodes-fixed-tf-broadcaster-py" class="headerlink" title="创建文件nodes/fixed_tf_broadcaster.py"></a>创建文件<code>nodes/fixed_tf_broadcaster.py</code></h4><pre><code class="python">#!/usr/bin/env pythonimport roslibimport rospyimport tfif __name__ == &#39;__main__&#39;:    rospy.init_node(&#39;fixed_tf_broadcaster&#39;)    br = tf.TransformBroadcaster()    rate = rospy.Rate(10.0)    while not rospy.is_shutdown():        br.sendTransform((0.0, 2.0, 0.0),#平移                         (0.0, 0.0, 0.0, 1.0),#表示旋转的四元数                         rospy.Time.now(),                         &quot;carrot1&quot;,#子坐标系                         &quot;turtle1&quot;)#父坐标系        rate.sleep()</code></pre><p>在这里，我们创建一个新的转换，从父“turtle1”到新的子“carrot1”。carrot1框架距离turtle1框架偏移2米。</p><h4 id="在launch文件中添加-2"><a href="#在launch文件中添加-2" class="headerlink" title="在launch文件中添加"></a>在<code>launch</code>文件中添加</h4><pre><code class="xml">    &lt;node pkg=&quot;learning_tf&quot; type=&quot;fixed_tf_broadcaster.py&quot; name=&quot;broadcaster_fixed&quot; /&gt;</code></pre><h4 id="随时间变化的坐标变换"><a href="#随时间变化的坐标变换" class="headerlink" title="随时间变化的坐标变换"></a>随时间变化的坐标变换</h4><pre><code class="python">#!/usr/bin/env python  import roslibroslib.load_manifest(&#39;learning_tf&#39;)import rospyimport tfimport mathif __name__ == &#39;__main__&#39;:    rospy.init_node(&#39;dynamic_tf_broadcaster&#39;)    br = tf.TransformBroadcaster()    rate = rospy.Rate(10.0)    while not rospy.is_shutdown():        t = rospy.Time.now().to_sec() * math.pi        br.sendTransform((2.0 * math.sin(t), 2.0 * math.cos(t), 0.0),                         (0.0, 0.0, 0.0, 1.0),                         rospy.Time.now(),                         &quot;carrot1&quot;,                         &quot;turtle1&quot;)        rate.sleep()</code></pre><h3 id="9-添加一个坐标系变换-C"><a href="#9-添加一个坐标系变换-C" class="headerlink" title="9. 添加一个坐标系变换(C++)"></a>9. 添加一个坐标系变换(C++)</h3><h4 id="创建文件src-frame-tf-broadcaster-cpp"><a href="#创建文件src-frame-tf-broadcaster-cpp" class="headerlink" title="创建文件src/frame_tf_broadcaster.cpp"></a>创建文件<code>src/frame_tf_broadcaster.cpp</code></h4><pre><code class="c++">#include &lt;ros/ros.h&gt;#include &lt;tf/transform_broadcaster.h&gt;//carrot1框架距离turtle1框架偏移2米int main(int argc, char** argv){  ros::init(argc, argv, &quot;my_tf_broadcaster&quot;);  ros::NodeHandle node;  tf::TransformBroadcaster br;  tf::Transform transform;  ros::Rate rate(10.0);  while (node.ok()){    transform.setOrigin( tf::Vector3(0.0, 2.0, 0.0) );    transform.setRotation( tf::Quaternion(0, 0, 0, 1) );    br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), &quot;turtle1&quot;, &quot;carrot1&quot;));    rate.sleep();  }  return 0;};</code></pre><h4 id="修改CMakeList-txt"><a href="#修改CMakeList-txt" class="headerlink" title="修改CMakeList.txt"></a>修改<code>CMakeList.txt</code></h4><pre><code class="cmake">add_executable(frame_tf_broadcaster src/frame_tf_broadcaster.cpp)target_link_libraries(frame_tf_broadcaster ${catkin_LIBRARIES})</code></pre><h4 id="随时间改变的坐标变换"><a href="#随时间改变的坐标变换" class="headerlink" title="随时间改变的坐标变换"></a>随时间改变的坐标变换</h4><pre><code class="c++">    transform.setOrigin( tf::Vector3(2.0*sin(ros::Time::now().toSec()), 2.0*cos(ros::Time::now().toSec()), 0.0) );    transform.setRotation( tf::Quaternion(0, 0, 0, 1) );</code></pre><h3 id="10-等待转换-C"><a href="#10-等待转换-C" class="headerlink" title="10. 等待转换(C++)"></a>10. 等待转换(C++)</h3><p>修改文件<code>src/turtle_tf_listener.cpp</code></p><pre><code class="c++">  try{    ros::Time now = ros::Time::now();    listener.waitForTransform(&quot;/turtle2&quot;, &quot;/turtle1&quot;,                              now, ros::Duration(3.0));//超时3s    listener.lookupTransform(&quot;/turtle2&quot;, &quot;/turtle1&quot;,                             now, transform);</code></pre><p>为什么要等待？每个监听器都有一个缓冲区，用于存储来自不同广播器的所有坐标转换。当广播器发出变换时，变换进入缓冲区需要一些时间（通常是几毫秒）。因此，当您在“now”时请求帧变换时，您应该等待几毫秒才能到达该信息。所有在一开始的时候还是会有错误出现，因为最开始的now时刻还没有数据。</p><h3 id="11-使用过去的状态-C"><a href="#11-使用过去的状态-C" class="headerlink" title="11. 使用过去的状态(C++)"></a>11. 使用过去的状态(C++)</h3><p>修改文件<code>src/turtle_tf_listener.cpp</code></p><pre><code class="c++">try{    ros::Time now = ros::Time::now();//现在的时刻(注意此刻的转换还没完成，所以用waitForTran..)    ros::Time past = now - ros::Duration(5.0);//5s前的时刻    listener.waitForTransform(&quot;/turtle2&quot;, now,                              &quot;/turtle1&quot;, past,                              &quot;/world&quot;, ros::Duration(1.0));    listener.lookupTransform(&quot;/turtle2&quot;, now,                             &quot;/turtle1&quot;, past,                             &quot;/world&quot;, transform);</code></pre><p>/world是/turle1和/turle2的父坐标，/turtle1和、turtle2通过/world建立映射关系，在tf监听器中/turtle2到/turtle1的变换未指定/world，只是被省略了。本程序计算/turtle2相对于/turtle1 5s前的位姿，/world未省略。</p><p>刚开始会报错，因为5s前还没有/turtle1到/world的映射</p><h3 id="12-激光数据从base-laser坐标系变换到base-link坐标系"><a href="#12-激光数据从base-laser坐标系变换到base-link坐标系" class="headerlink" title="12. 激光数据从base_laser坐标系变换到base_link坐标系"></a>12. 激光数据从base_laser坐标系变换到base_link坐标系</h3><p><a href="http://wiki.ros.org/navigation/Tutorials/RobotSetup/TF" target="_blank" rel="noopener">http://wiki.ros.org/navigation/Tutorials/RobotSetup/TF</a></p><p>base_link是小车的坐标系，lase_laser是激光器的坐标系。本文先建立一个节点发布两个坐标系的转换，然后建立一个节点读取转换结果。假设激光器安装在小车中心点前方10厘米上方20厘米处</p><h4 id="先创建一个包"><a href="#先创建一个包" class="headerlink" title="先创建一个包"></a>先创建一个包</h4><pre><code class="sh">cd ~/catkin_ws/srccatkin_create_pkg robot_setup_tf roscpp tf geometry_msgs</code></pre><h4 id="创建文件src-tf-broadcaster-cpp"><a href="#创建文件src-tf-broadcaster-cpp" class="headerlink" title="创建文件src/tf_broadcaster.cpp"></a>创建文件<code>src/tf_broadcaster.cpp</code></h4><p>创建一个节点来完成通过ROS广播base_laser→base_link转换的工作</p><pre><code class="c++">#include &lt;ros/ros.h&gt;#include &lt;tf/transform_broadcaster.h&gt;int main(int argc, char** argv){  ros::init(argc, argv, &quot;robot_tf_publisher&quot;);  ros::NodeHandle n;  ros::Rate r(100);  tf::TransformBroadcaster broadcaster;  while(n.ok()){    broadcaster.sendTransform(//只有StampedTransform一个参数      tf::StampedTransform(//有四个参数：旋转、平移、时间、父坐标系、子坐标系        tf::Transform(tf::Quaternion(0, 0, 0, 1), tf::Vector3(0.1, 0.0, 0.2)),        ros::Time::now(),&quot;base_link&quot;, &quot;base_laser&quot;));    r.sleep();  }}</code></pre><h4 id="创建文件src-tf-listener-cpp"><a href="#创建文件src-tf-listener-cpp" class="headerlink" title="创建文件src/tf_listener.cpp"></a>创建文件<code>src/tf_listener.cpp</code></h4><p>编写一个节点，该节点将使用上面创建的变换，在“base_laser”坐标系中取一个点并将其转换为“base_link”坐标系中的一个点</p><pre><code class="c++">#include &lt;ros/ros.h&gt;#include &lt;geometry_msgs/PointStamped.h&gt;#include &lt;tf/transform_listener.h&gt;void transformPoint(const tf::TransformListener&amp; listener){  geometry_msgs::PointStamped laser_point;//定义laser_point点  laser_point.header.frame_id = &quot;base_laser&quot;;  laser_point.header.stamp = ros::Time();  laser_point.point.x = 1.0;  laser_point.point.y = 0.2;  laser_point.point.z = 0.0;  try{    geometry_msgs::PointStamped base_point;//定义base_point点    //启动转换，将base_laser中的laser_point点转换到base_link中的base_point点    listener.transformPoint(&quot;base_link&quot;, laser_point, base_point);    ROS_INFO(&quot;base_laser: (%.2f, %.2f. %.2f) -----&gt; base_link: (%.2f, %.2f, %.2f) at time %.2f&quot;,        laser_point.point.x, laser_point.point.y, laser_point.point.z,        base_point.point.x, base_point.point.y, base_point.point.z, base_point.header.stamp.toSec());  }  catch(tf::TransformException&amp; ex){//ROS_ERROR不支持中文   ROS_ERROR(&quot;Received an exception trying to transform a point from \&quot;base_laser\&quot; to \&quot;base_link\&quot;: %s&quot;, ex.what());  }}int main(int argc, char** argv){  ros::init(argc, argv, &quot;robot_tf_listener&quot;);  ros::NodeHandle n;  tf::TransformListener listener(ros::Duration(10));  //每秒执行一次转换  ros::Timer timer = n.createTimer(ros::Duration(1.0), boost::bind(&amp;transformPoint, boost::ref(listener)));  ros::spin();}</code></pre><h4 id="修改CMakeList-txt-1"><a href="#修改CMakeList-txt-1" class="headerlink" title="修改CMakeList.txt"></a>修改<code>CMakeList.txt</code></h4><pre><code class="cmake">add_executable(tf_broadcaster src/tf_broadcaster.cpp)add_executable(tf_listener src/tf_listener.cpp)target_link_libraries(tf_broadcaster ${catkin_LIBRARIES})target_link_libraries(tf_listener ${catkin_LIBRARIES})</code></pre><h3 id="13-urdf与robot-state-publisher的示例"><a href="#13-urdf与robot-state-publisher的示例" class="headerlink" title="13. urdf与robot_state_publisher的示例"></a>13. urdf与robot_state_publisher的示例</h3><p><a href="http://wiki.ros.org/urdf/Tutorials/Using%20urdf%20with%20robot_state_publisher" target="_blank" rel="noopener">http://wiki.ros.org/urdf/Tutorials/Using%20urdf%20with%20robot_state_publisher</a></p><p>首先创建一个机器人的urdf文件，然后编写机器人关节状态发布程序，通过/tf话题发布机器人关节状态。使用rviz显示机器人的3D模型及其运动。</p><h4 id="创建urdf文件"><a href="#创建urdf文件" class="headerlink" title="创建urdf文件"></a>创建urdf文件</h4><p><a href="http://wiki.ros.org/urdf/Tutorials/Using%20urdf%20with%20robot_state_publisher?action=AttachFile&amp;do=get&amp;target=model.xml">http://wiki.ros.org/urdf/Tutorials/Using%20urdf%20with%20robot_state_publisher?action=AttachFile&amp;do=get&amp;target=model.xml</a></p><h4 id="创建一个包，依赖为roscpp-rospy-tf-sensor-msgs-std-msgs"><a href="#创建一个包，依赖为roscpp-rospy-tf-sensor-msgs-std-msgs" class="headerlink" title="创建一个包，依赖为roscpp rospy tf sensor_msgs std_msgs"></a>创建一个包，依赖为<code>roscpp rospy tf sensor_msgs std_msgs</code></h4><h4 id="创建并编译文件src-state-publisher-cpp"><a href="#创建并编译文件src-state-publisher-cpp" class="headerlink" title="创建并编译文件src/state_publisher.cpp"></a>创建并编译文件<code>src/state_publisher.cpp</code></h4><pre><code class="c++">#include &lt;string&gt;#include &lt;ros/ros.h&gt;#include &lt;sensor_msgs/JointState.h&gt;#include &lt;tf/transform_broadcaster.h&gt;int main(int argc, char** argv) {    ros::init(argc, argv, &quot;state_publisher&quot;);    ros::NodeHandle n;    ros::Publisher joint_pub = n.advertise&lt;sensor_msgs::JointState&gt;(&quot;joint_states&quot;, 1);    tf::TransformBroadcaster broadcaster;    ros::Rate loop_rate(30);    const double degree = M_PI/180;    // 机器人状态    double tilt = 0, tinc = degree, swivel=0, angle=0, height=0, hinc=0.005;    // 消息声明    geometry_msgs::TransformStamped odom_trans;    sensor_msgs::JointState joint_state;    odom_trans.header.frame_id = &quot;odom&quot;;//world坐标系叫odom    odom_trans.child_frame_id = &quot;axis&quot;;//轴坐标系，相当于一个基座    while (ros::ok()) {        //更新关节状态        joint_state.header.stamp = ros::Time::now();        joint_state.name.resize(3);        joint_state.position.resize(3);        joint_state.name[0] =&quot;swivel&quot;;//旋转        joint_state.position[0] = swivel;        joint_state.name[1] =&quot;tilt&quot;;//倾斜        joint_state.position[1] = tilt;        joint_state.name[2] =&quot;periscope&quot;;//潜望镜        joint_state.position[2] = height;        // 更新变换        // (使轴做做圆周运动)        odom_trans.header.stamp = ros::Time::now();        odom_trans.transform.translation.x = cos(angle)*2;        odom_trans.transform.translation.y = sin(angle)*2;        odom_trans.transform.translation.z = .7;        odom_trans.transform.rotation = tf::createQuaternionMsgFromYaw(angle+M_PI/2);        // 发布关节状态和变换        joint_pub.publish(joint_state);        broadcaster.sendTransform(odom_trans);        // 创建新的机器人状态    //用于头的摆动        tilt += tinc;        if (tilt&lt;-.5 || tilt&gt;0) tinc *= -1;//在0.5到0.2度之间        height += hinc;        if (height&gt;.2 || height&lt;0) hinc *= -1;        swivel += degree;//用于轴的旋转        angle += degree/4;//用于计算轴的圆周运动        loop_rate.sleep();    }    return 0;}</code></pre><h4 id="创建launch文件"><a href="#创建launch文件" class="headerlink" title="创建launch文件"></a>创建launch文件</h4><pre><code class="xml">&lt;launch&gt;        &lt;param name=&quot;robot_description&quot; command=&quot;cat $(find r2d2)/launch/model.xml&quot; /&gt;        &lt;node name=&quot;robot_state_publisher&quot; pkg=&quot;robot_state_publisher&quot; type=&quot;state_publisher&quot; /&gt;        &lt;node name=&quot;state_publisher&quot; pkg=&quot;r2d2&quot; type=&quot;state_publisher&quot; /&gt;&lt;/launch&gt;</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>运行该<code>.launch</code>文件，然后打开新窗口，运行<code>rosrun rviz rviz</code>。修改<code>Fiexed Frame</code>参数为<code>odom</code>，添加<code>RobotModel</code>，即可显示机器人。</p><p>可见机器人两腿做圆周运动，头和身体随两腿运动，并绕轴摆动，添加各种<code>Axes</code>可以显示各个坐标系。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>编写的<code>state_publisher</code>节点发布的tf话题只有<code>odom</code>到<code>axis</code>的变化，还发布了3个机器人关节状态<code>swivel</code>、<code>tilt</code>、<code>periscope</code>，分别对应头的旋转、身体的摆动、潜望镜的上下运动。<code>robot_state_publisher</code>节点根据urdf文件将这三个关节参数转换为tf变换，并发布到/tf话题。rviz订阅这些/tf话题是机器人模型运动</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波</title>
      <link href="/2020/03/06/SLAM/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"/>
      <url>/2020/03/06/SLAM/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h2><p>​    <a href="https://blog.csdn.net/heyijia0327/article/details/17487467" target="_blank" rel="noopener">https://blog.csdn.net/heyijia0327/article/details/17487467</a></p><p>​    卡尔曼滤波适用于估计一个动态系统的最优状态。即便是观测到的系统状态参数含有噪声（服从高斯分布），观测值不准确，卡尔曼滤波也能够完成对状态真实值的最优估计。</p><p>​    本例中的对象为一辆小车，需要知道它的位置和速度，用向量表示为：</p><p><img src="https://www.zhihu.com/equation?tex=%5Coverrightarrow%7Bx_k%7D%3D%28%5Coverrightarrow%7Bp%7D%2C%5Coverrightarrow%7Bv%7D%29" alt=""></p><p>​    卡尔曼滤波的工作原理主要包括先验估计和后验估计</p><h4 id="1-先验状态估计"><a href="#1-先验状态估计" class="headerlink" title="1.先验状态估计"></a>1.先验状态估计</h4><p>​    首先简化起见，假如小车在一条<strong>笔直</strong>的线路上面行驶，其运动轨迹是确定的，不确定的是小车的速度大小和位置，创建状态变量：<img src="https://www.zhihu.com/equation?tex=%5Coverrightarrow%7Bx%7D%3D%5Cbegin%7Bbmatrix%7Dp%5C%5Cv%5C%5C+%5Cend%7Bbmatrix%7D" alt=""></p><ul><li>该状态向量可看做一个<strong>状态空间</strong>，横坐标是速度，纵坐标是位置，平面上面的任意一个点就唯一地描述出这个小车的运动状态。</li><li>小车的速度和位置量在其定义域内具有正态的<strong>高斯分布</strong>规律。即每一个变量都是具有一个均值<img src="https://www.zhihu.com/equation?tex=%5Cmu" alt="\mu">)（代表该数值是最可能发生的）和<img src="https://www.zhihu.com/equation?tex=%5Csigma%5E2" alt="\sigma^2">（表示变量的不确定性程度）。</li><li>位置和速度也是有一定<strong>关联</strong>的，如果速度过高，我们可能已经移动很远了（跟踪这种关系是非常重要的，我们尽可能地从包含不确定性的测量数据中提取更多信息，这就是卡尔曼滤波的目的 ）</li><li>状态向量的第<img src="https://www.zhihu.com/equation?tex=i" alt="i">)个元素和第<img src="https://www.zhihu.com/equation?tex=j" alt="j">)个元素之间的相关程度用协方差矩阵<img src="https://www.zhihu.com/equation?tex=%5CSigma_%7Bij%7D" alt="\Sigma_{ij}"> 表示</li></ul><p><img src="https://www.zhihu.com/equation?tex=%5CSigma_%7Bij%7D%3DCov%28x_i%2Cx_j%29%3DE%5B%28x_i-%5Cmu_i%29%28x_j-%5Cmu_j%29%5D" alt=""></p><p><strong>数学描述部分：</strong></p><p>​    定义<img src="https://www.zhihu.com/equation?tex=%5Chat%7Bx%7D_k%3D%5Cbegin%7Bbmatrix%7Dposition%5C%5Cvelocity%5C%5C+%5Cend%7Bbmatrix%7D" alt="\hat{x}_k=\begin{bmatrix}position\\velocity\\ \end{bmatrix}">)，<img src="https://www.zhihu.com/equation?tex=P_k%3D%5Cbegin%7Bbmatrix%7D%5CSigma_%7Bpp%7D%26%26%5CSigma_%7Bpv%7D%5C%5C%5CSigma_%7Bvp%7D%26%26%5CSigma_%7Bvv%7D%5C%5C%5Cend%7Bbmatrix%7D" alt="P_k=\begin{bmatrix}\Sigma_{pp}&amp;&amp;\Sigma_{pv}\\\Sigma_{vp}&amp;&amp;\Sigma_{vv}\\\end{bmatrix}">。</p><p>​    其中<img src="https://www.zhihu.com/equation?tex=%5Chat%7Bx%7D_k" alt="\hat{x}_k">)是状态向量，<img src="https://www.zhihu.com/equation?tex=P_k" alt="P_k">是协方差。</p><p>​    <strong><em>状态更新方程</em></strong></p><p>​    <img src="https://www.zhihu.com/equation?tex=p_k%3Dp_%7Bk-1%7D%2B%5Cdelta+tv_%7Bk-1%7D" alt="p_k=p_{k-1}+\delta tv_{k-1}">)，<img src="https://www.zhihu.com/equation?tex=v_k%3Dv_%7Bk-1%7D" alt="v_k=v_{k-1}">写成矩阵形式：</p><p><img src="https://www.zhihu.com/equation?tex=%5Chat%7Bx%7D_k%3D%5Cbegin%7Bbmatrix%7D1%26%26%5Cdelta+t%5C%5C0%26%261+%5Cend%7Bbmatrix%7D%5Chat%7Bx%7D_%7Bk-1%7D%3DF_k%5Chat%7Bx%7D_%7Bk-1%7D%0A" alt="\hat{x}_k=\begin{bmatrix}1&amp;&amp;\delta t\\0&amp;&amp;1 \end{bmatrix}\hat{x}_{k-1}=F_k\hat{x}_{k-1} "></p><p>​    <strong><em>协方差矩阵</em></strong></p><p>​    即状态向量之间相关性的更新：</p><p><img src="https://www.zhihu.com/equation?tex=Cov%28Ax%29%3DA%5CSigma+A%5ET" alt="Cov(Ax)=A\Sigma A^T"></p><p>​    <code>协方差矩阵的主对角线就是方差，反对角线上的就是两个变量间的协方差</code></p><p>​    <a href="https://baike.baidu.com/item/协方差矩阵/9822183?fr=aladdin" target="_blank" rel="noopener">协方差矩阵</a></p><p>​    结合状态更新方程可得：</p><p>​    <img src="https://www.zhihu.com/equation?tex=%5Chat%7Bx%7D_k%3DF_k%5Chat%7Bx%7D_%7Bk-1%7D" alt="\hat{x}_k=F_k\hat{x}_{k-1}">（先验状态估计）</p><p>​    <img src="https://www.zhihu.com/equation?tex=%7BP%7D_k%3DF_k+P_%7Bk-1%7DF_k%5ET" alt="{P}_k=F_k P_{k-1}F_k^T">（先验状态估计协方差矩阵）</p><p>​    <strong><em>外部输入</em></strong></p><p>​    如小车发出控制指令，产生加速a，则状态更新方程改写为：</p><p>​    <img src="https://www.zhihu.com/equation?tex=%5Chat%7Bp%7D_k%3Dp_%7Bk-1%7D%2B%5Cdelta+tv_%7Bk-1%7D%2B%5Cfrac%7B1%7D%7B2%7Da%5Cdelta+t%5E2" alt="\hat{p}_k=p_{k-1}+\delta tv_{k-1}+\frac{1}{2}a\delta t^2">，<img src="https://www.zhihu.com/equation?tex=v_k%3Dv_%7Bk-1%7D%2Ba%5Cdelta+t" alt="v_k=v_{k-1}+a\delta t"></p><p>​    写成矩阵形式：</p><p><img src="https://www.zhihu.com/equation?tex=%5Chat%7Bx%7D_k%3DF_kx_%7Bk-1%7D%2B%5Cbegin%7Bbmatrix%7D%5Cfrac%7B%5Cdelta+t%5E2%7D%7B2%7D%5C%5C%5Cdelta+t+%5Cend%7Bbmatrix%7Da%3DF_kx_%7Bk-1%7D%2BB_k%5Coverrightarrow%7Bu%7D_k" alt="\hat{x}_k=F_kx_{k-1}+\begin{bmatrix}\frac{\delta t^2}{2}\\\delta t \end{bmatrix}a=F_kx_{k-1}+B_k\overrightarrow{u}_k"></p><p>​    其中，<img src="https://www.zhihu.com/equation?tex=B_k" alt="B_k">)是控制矩阵，<img src="https://www.zhihu.com/equation?tex=%5Coverrightarrow%7Bu_k%7D" alt="\overrightarrow{u_k}">是控制向量。由于本例子中的控制实际上只包含了加速度，所以该向量包含元素的个数为1</p><p>​    <strong><em>加入干扰的影响</em></strong></p><p>​    加入不确定干扰项<img src="https://www.zhihu.com/equation?tex=w_k" alt="w_k">（呈高斯分布），得到最终的更新方程：</p><p><img src="https://www.zhihu.com/equation?tex=%5Chat%7Bx%7D_k%3DF_kx_%7Bk-1%7D%2BB_k%5Coverrightarrow%7Bu%7D_k%2Bw_k" alt="\hat{x}_k=F_kx_{k-1}+B_k\overrightarrow{u}_k+w_k"></p><p>​    加入过程激励噪声协方差<img src="https://www.zhihu.com/equation?tex=Q_k" alt="Q_k">来描述不确定干扰：</p><p><img src="https://www.zhihu.com/equation?tex=%5Chat%7BP%7D_k%3DF_k%5Chat%7BP%7D_%7Bk-1%7DF_k%5ET%2BQ_k" alt="\hat{P}_k=F_k\hat{P}_{k-1}F_k^T+Q_k"></p><p><strong>先验估计公式上面两式</strong></p><p>​    先验估计<img src="https://www.zhihu.com/equation?tex=%5Chat%7Bx%7D_k" alt="\hat{x}_k">取决于如下三部分：一部分是上一轮的最优估计值，一部分是确定性的外界影响值，另一部分是不确定的干扰。先验估计协方差矩阵<img src="https://www.zhihu.com/equation?tex=P_k%0A" alt="P_k ">，首先是依据上一轮卡尔曼估计（后验估计）的协方差矩阵进行递推，再加上本次更新中不确定因素可能对系统造成的影响得到。</p><h4 id="2-后验估计（量测更新）"><a href="#2-后验估计（量测更新）" class="headerlink" title="2.后验估计（量测更新）"></a>2.后验估计（量测更新）</h4><p>​    加入各类传感器（如速度传感器、位移传感器等）进行矫正，以这些传感器的反馈作为纠正我们推断的依据。传感器的输出值不一定就是我们创建的状态向量当中的元素，通常进行转换。这个转换也被称作状态空间到观测空间的映射矩阵<img src="https://www.zhihu.com/equation?tex=H_k" alt="H_k">。</p><p><strong>传感器的测量值为：</strong></p><p>​    <img src="https://www.zhihu.com/equation?tex=%5Coverrightarrow+%5Cmu_%7Bexpected%7D%3DH_k%5Chat+x_k%0A" alt="\overrightarrow \mu_{expected}=H_k\hat x_k "></p><p>​    <img src="https://www.zhihu.com/equation?tex=%5CSigma_%7Bexpected%7D%3DH_kP_kH_k%5ET" alt="\Sigma_{expected}=H_kP_kH_k^T"></p><p>​    加入观测噪声<img src="https://www.zhihu.com/equation?tex=v_k%0A" alt="v_k ">和观测噪声协方差<img src="https://www.zhihu.com/equation?tex=R_k%0A" alt="R_k ">后：</p><p><img src="https://www.zhihu.com/equation?tex=%5Coverrightarrow+z_t%3DH_k%5Chat+x_k%2B%5Coverrightarrow+v_k" alt="\overrightarrow z_t=H_k\hat x_k+\overrightarrow v_k"><br>$$<br>{\Sigma _t} = {H_k}{P_k}{H_k}^T + {R_k}<br>$$<br><strong>将测量值和估计值进行融合</strong></p><p>​    要想考察两个时间同时发生的可能性，我们将两个事件单独发生的概率相乘。对两个高斯分布进行乘法运算，得到新的概率分布规律仍然符合高斯分布。</p><p><strong><em>前提知识</em></strong></p><p>​    一个<strong>单随机变量的高斯分布</strong>，期望为<img src="https://www.zhihu.com/equation?tex=%5Cmu" alt="\mu">，方差为<img src="https://www.zhihu.com/equation?tex=%5Csigma+%5E2" alt="\sigma ^2">，概率密度函数为：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BN%7D%28x%2C%5Cmu%2C%5Csigma%29+%3D%5Cfrac%7B1%7D%7B%5Csigma+%5Csqrt%7B2%5Cpi%7D%7De%5E%7B-%5Cfrac%7B%28x-%5Cmu%29%5E2%7D%7B2%5Csigma%5E2%7D%7D" alt="\mathcal{N}(x,\mu,\sigma) =\frac{1}{\sigma \sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}"></p><p>​    如果存在两个这样的高斯分布，只不过期望和方差不同，当两个分布<strong>相乘时</strong>，得到的结果为：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D%0A++++%5Cmathcal%7BN%7D%28x%2C%5Cmu_0%2C%5Csigma_0%29%5Ccdot+%5Cmathcal%7BN%7D%28x%2C%5Cmu_1%2C%5Csigma_1%29%5Coverset%7B%3F%7D%7B%3D%7D%5Cmathcal%7BN%7D%28x%2C%5Cmu%5E%7B%27%7D%2C%5Csigma%5E%7B%27%7D%29+%5Cend%7Bequation%7D" alt="\begin{equation}     \mathcal{N}(x,\mu_0,\sigma_0)\cdot \mathcal{N}(x,\mu_1,\sigma_1)\overset{?}{=}\mathcal{N}(x,\mu^{&#39;},\sigma^{&#39;}) \end{equation}"></p><p>​    其中<img src="https://www.zhihu.com/equation?tex=%5Cmu%5E%7B%27%7D+%3D%5Cmu_0%2Bk%28%5Cmu_1-+%5Cmu_0%29" alt="\mu^{&#39;} =\mu_0+k(\mu_1- \mu_0)">)，<img src="https://www.zhihu.com/equation?tex=%7B%5Csigma%5E%7B%27%7D%7D%5E2%3Dk%7B%5Csigma_1%7D%5E2%3D%7B%5Csigma_0%7D%5E2%281-k%29" alt="{\sigma^{&#39;}}^2=k{\sigma_1}^2={\sigma_0}^2(1-k)">)，<img src="https://www.zhihu.com/equation?tex=k%3D%5Cfrac%7B%5Csigma_0%5E2%7D%7B%5Csigma_0%5E2%2B%5Csigma_1%5E2%7D" alt="k=\frac{\sigma_0^2}{\sigma_0^2+\sigma_1^2}">。</p><p>​    表示成<strong>矩阵形式</strong>：</p><p><img src="https://www.zhihu.com/equation?tex=%5Coverrightarrow%5Cmu%5E%7B%27%7D%3D%5Coverrightarrow%5Cmu_0%2BK%28%5Coverrightarrow%5Cmu_1-%5Coverrightarrow%5Cmu_0%29" alt="\overrightarrow\mu^{&#39;}=\overrightarrow\mu_0+K(\overrightarrow\mu_1-\overrightarrow\mu_0)"></p><p><img src="https://www.zhihu.com/equation?tex=%5CSigma%5E%7B%27%7D%3DK%5CSigma_1%3D%5CSigma_0%28I-K%29" alt="\Sigma^{&#39;}=K\Sigma_1=\Sigma_0(I-K)"></p><p><img src="https://www.zhihu.com/equation?tex=K%3D%5CSigma_0%28%5CSigma_0%2B%5CSigma_1%29%5E%7B-1%7D" alt="K=\Sigma_0(\Sigma_0+\Sigma_1)^{-1}"></p><p>​    （其中K成为卡尔曼增益）</p><p><strong><em>卡尔曼估计</em></strong></p><p>​    下面开始对传感器数据和先验估计进行融合。</p><p>​    首先将先验估计的结果映射到观测向量空间，使两者处在同一空间（观测空间）。先验估计为：</p><p><img src="https://www.zhihu.com/equation?tex=%28%5Cmu_0%2C%5CSigma_0%29%3D%28H_k%5Chat+x_k%2CH_kP_kH_k%5ET%29" alt="(\mu_0,\Sigma_0)=(H_k\hat x_k,H_kP_kH_k^T)"></p><p>​    观测值为：</p><p><img src="https://www.zhihu.com/equation?tex=%28%5Cmu_1%2C%5CSigma_1%29%3D%28z_k%2CR_k%29" alt="(\mu_1,\Sigma_1)=(z_k,R_k)"></p><p>​    代入融合公式得到：</p><p><img src="https://www.zhihu.com/equation?tex=H_k%5Chat+x_k%5E%7B%27%7D%3DH_k%5Chat+x_k%2BK%28%5Coverrightarrow%7Bz_k%7D-H_k%5Chat+x_k%29" alt="H_k\hat x_k^{&#39;}=H_k\hat x_k+K(\overrightarrow{z_k}-H_k\hat x_k)"></p><p><img src="https://www.zhihu.com/equation?tex=H_kP_k%5E%7B%27%7DH_k%5ET%3DH_kP_kH_k%5ET-KH_kP_kH_k%5ET" alt="H_kP_k^{&#39;}H_k^T=H_kP_kH_k^T-KH_kP_kH_k^T"></p><p><img src="https://www.zhihu.com/equation?tex=K%3DH_kP_kH_k%5ET%28H_kP_kH_k%5ET%2BR_k%29%5E%7B-1%7D" alt="K=H_kP_kH_k^T(H_kP_kH_k^T+R_k)^{-1}"></p><p>​    <img src="https://www.zhihu.com/equation?tex=%5Chat+x_k%5E%7B%27%7D" alt="\hat x_k^{&#39;}">)就是第k次卡尔曼预测结果，<img src="https://www.zhihu.com/equation?tex=P_k%5E%7B%27%7D" alt="P_k^{&#39;}">是该结果的协方差矩阵。</p><p><strong>更新结果</strong></p><p><img src="https://www.zhihu.com/equation?tex=%5Chat+x_k%5E%7B%27%7D%3D%5Chat+x_k%2BK%5E%7B%27%7D%28%5Coverrightarrow%7Bz_k%7D-H_k%5Chat+x_k%29" alt="\hat x_k^{&#39;}=\hat x_k+K^{&#39;}(\overrightarrow{z_k}-H_k\hat x_k)"></p><p><img src="https://www.zhihu.com/equation?tex=P_k%5E%7B%27%7D%3DP_k-K%5E%7B%27%7DH_kP_k" alt="P_k^{&#39;}=P_k-K^{&#39;}H_kP_k"></p><p><img src="https://www.zhihu.com/equation?tex=K%5E%7B%27%7D%3DP_kH_k%5ET%28H_kP_kH_k%5ET%2BR_k%29%5E%7B-1%7D" alt="K^{&#39;}=P_kH_k^T(H_kP_kH_k^T+R_k)^{-1}"></p><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h4><p>​    总体上来讲，卡尔曼滤波的步骤大致分为两步，第一步是时间更新，也叫作先验估计，第二步是量测更新，也叫作后验估计。</p><p>​    <strong>所有公式如下</strong></p><p>时间更新</p><p><img src="https://www.zhihu.com/equation?tex=%5Chat%7Bx%7D_k%3DF_k%5Chat%7Bx%7D_%7Bk-1%7D%2BB_k%5Coverrightarrow%7Bu%7D_k%2Bw_k" alt="\hat{x}_k=F_k\hat{x}_{k-1}+B_k\overrightarrow{u}_k+w_k"></p><p><img src="https://www.zhihu.com/equation?tex=%5Chat%7BP%7D_k%3DF_k%5Chat%7BP%7D_%7Bk-1%7DF_k%5ET%2BQ_k" alt="\hat{P}_k=F_k\hat{P}_{k-1}F_k^T+Q_k"></p><p><img src="https://www.zhihu.com/equation?tex=%28%5Cmu_0%2C%5CSigma_0%29%3D%28H_k%5Chat+x_k%2CH_kP_kH_k%5ET%29" alt="(\mu_0,\Sigma_0)=(H_k\hat x_k,H_kP_kH_k^T)"></p><p>测量更新</p><p><img src="https://www.zhihu.com/equation?tex=%28%5Cmu_1%2C%5CSigma_1%29%3D%28z_k%2CR_k%29" alt="(\mu_1,\Sigma_1)=(z_k,R_k)"></p><p><img src="https://www.zhihu.com/equation?tex=%5Chat+x_k%5E%7B%27%7D%3D%5Chat+x_k%2BK%5E%7B%27%7D%28%5Coverrightarrow%7Bz_k%7D-H_k%5Chat+x_k%29" alt="\hat x_k^{&#39;}=\hat x_k+K^{&#39;}(\overrightarrow{z_k}-H_k\hat x_k)"></p><p><img src="https://www.zhihu.com/equation?tex=P_k%5E%7B%27%7D%3DP_k-K%5E%7B%27%7DH_kP_k" alt="P_k^{&#39;}=P_k-K^{&#39;}H_kP_k"></p><p><img src="https://www.zhihu.com/equation?tex=K%5E%7B%27%7D%3DP_kH_k%5ET%28H_kP_kH_k%5ET%2BR_k%29%5E%7B-1%7D" alt="K^{&#39;}=P_kH_k^T(H_kP_kH_k^T+R_k)^{-1}"></p><p>​    <img src="https://www.zhihu.com/equation?tex=%5Chat%7Bx%7D_k" alt="\hat{x}_k">)是先验状态估计向量，<img src="https://www.zhihu.com/equation?tex=P_k" alt="P_k">)是先验状态估计协方差矩阵，<img src="https://www.zhihu.com/equation?tex=%5Coverrightarrow%7Bu_k%7D" alt="\overrightarrow{u_k}">为控制向量，<img src="https://www.zhihu.com/equation?tex=%5Coverrightarrow+%7Bz_k%7D" alt="\overrightarrow {z_k}">为观测向量，<img src="https://www.zhihu.com/equation?tex=%5Chat+x_k%5E%7B%27%7D" alt="\hat x_k^{&#39;}">)就是第k次卡尔曼预测结果。<img src="https://www.zhihu.com/equation?tex=P_k%5E%7B%27%7D" alt="P_k^{&#39;}">是该结果的协方差矩阵</p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>非线性最小二乘法之GaussNewton，L-M，Dog-Leg</title>
      <link href="/2020/03/06/SLAM/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E4%B9%8BGaussNewton%EF%BC%8CL-M%EF%BC%8CDog-Leg/"/>
      <url>/2020/03/06/SLAM/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E4%B9%8BGaussNewton%EF%BC%8CL-M%EF%BC%8CDog-Leg/</url>
      
        <content type="html"><![CDATA[<h2 id="非线性最小二乘法之Gauss-Newton、L-M、Dog-Leg"><a href="#非线性最小二乘法之Gauss-Newton、L-M、Dog-Leg" class="headerlink" title="非线性最小二乘法之Gauss Newton、L-M、Dog-Leg"></a>非线性最小二乘法之Gauss Newton、L-M、Dog-Leg</h2><p><a href="https://blog.csdn.net/stihy/article/details/52737723" target="_blank" rel="noopener">https://blog.csdn.net/stihy/article/details/52737723</a></p><h3 id="最快下降法"><a href="#最快下降法" class="headerlink" title="最快下降法"></a>最快下降法</h3><p>假设$h^{T} F^{\prime}(x)&lt;0$，则$h$是$F(x)$的下降方向，即对于任意足够小的$\alpha&gt;0$，都满足$F(x+\alpha h)&lt;F(x)$。</p><p>现在讨论$F(x)$沿着$h$下降的快慢：<br>$$<br>\lim _{\alpha \rightarrow 0} \frac{F(x)-F(x+\alpha h)}{\alpha|h|}=-\frac{1}{|h|} h^{T} F^{\prime}(x)=-\left|F^{\prime}(x)\right| \cos \theta<br>$$<br>其中$\theta$为矢量$h$和$F^{\prime}(x)$的夹角，当$\theta=\pi$时，下降最快。</p><p>即$h_{s d}=-F^{\prime}(x)$是最快下降方向。</p><h3 id="最小二乘问题"><a href="#最小二乘问题" class="headerlink" title="最小二乘问题"></a>最小二乘问题</h3><p>通常的最小二乘问题都可以表示为：<br>$$<br>F(x)=\frac{1}{2} \sum_{j=1}^{n}\left(f_{i}(x)^{2}\right)=\frac{1}{2}|f(x)|^{2}=\frac{1}{2} f(x)^{T} f(x)<br>$$<br>找到一个$x^{<em>}$使得$x^{</em>}=\operatorname{argmin}<em>{x} F(x)$，其中$x=\left[x</em>{1} x_{2} \cdots x_{m}\right], f(x)=\left[f_{1}(x) f_{2}(x) \cdots f_{n}(x)\right]$。</p><p>假设对$f(x)$的第$i$个分量$f_{i}(x)$在点$\boldsymbol{x}_{k}$处Taylor展开，</p><p>$f_{i}\left(x_{k}+h\right) \approx f_{i}\left(x_{k}\right)+\nabla f_{i}\left(x_{k}\right)^{T} h, i=1,2 \cdots n$</p><p>则$f\left(x_{k}+h\right) \approx f\left(x_{k}\right)+J\left(x_{k}\right) h$，其中Jacobian矩阵<br>$$<br>J\left(x_{k}\right)=\left[ \begin{array}{c}{\nabla f_{1}\left(x_{k}\right)^{T}} \ {\nabla f_{2}\left(x_{k}\right)^{T}} \ {\vdots} \ {\nabla f_{n}\left(x_{k}\right)}\end{array}\right]=\left[ \begin{array}{cccc}{\frac{\partial f_{1}\left(x_{k}\right)}{\partial x_{1}}} &amp; {\frac{\partial f_{1}\left(x_{k}\right)}{\partial x_{2}}} &amp; {\cdots} &amp; {\frac{\partial f_{1}\left(x_{k}\right)}{\partial x_{m}}} \ {\frac{\partial f_{2}\left(x_{k}\right)}{\partial x_{1}}} &amp; {\frac{\partial f_{2}\left(x_{k}\right)}{\partial x_{2}}} &amp; {\cdots} &amp; {\frac{\partial f_{2}\left(x_{k}\right)}{\partial x_{m}}} \ {\vdots} &amp; {\vdots} &amp; {\ddots} &amp; {\vdots} \ {\frac{\partial f_{n}\left(x_{k}\right)}{\partial x_{1}}} &amp; {\frac{\partial f_{n}\left(x_{k}\right)}{\partial x_{2}}} &amp; {\cdots} &amp; {\frac{\partial f_{n}\left(x_{k}\right)}{\partial x_{m}}}\end{array}\right]<br>$$<br>通常记$f_{k}=f\left(x_{k}\right), J_{k}=J\left(x_{k}\right)$。则</p><p>$$<br>\frac{\partial F(x)}{\partial x_{j}}=\sum_{i=1}^{n} f_{i}(x) \frac{\partial f_{i}(x)}{\partial x_{j}}<br>$$<br>所以$F(x)$的梯度为：</p><p>$$<br>g=F^{\prime}(x)=J(x)^{T} f(x)<br>$$</p><h3 id="Gauss-Newton法"><a href="#Gauss-Newton法" class="headerlink" title="Gauss-Newton法"></a>Gauss-Newton法</h3><p>选择$h$使$F(x)$在$x_{k}$附近二阶近似，则</p><p>$$<br>\begin{aligned} F\left(x_{k}+h\right) \approx L(h) &amp;=\frac{1}{2} f\left(x_{k}+h\right)^{T} f\left(x_{k}+h\right) \ &amp;=\frac{1}{2} f_{k}^{T} f_{k}+h^{T} J_{k}^{T} f_{k}+\frac{1}{2} h^{T} J_{k}^{T} J_{k} h \ &amp;=F\left(x_{k}\right)+h^{T} J_{k}^{T} f_{k}+\frac{1}{2} h^{T} J_{k}^{T} J_{k} h \end{aligned}<br>$$<br>为了使$F\left(x_{k}+h\right)$取极小值，$L(h)$对$h$的一阶导数$L^{\prime}(h)$要等于0。即<br>$$<br>\frac{\partial L(h)}{\partial h}=J_{k}^{T} f_{k}+J_{k}^{T} J_{k} h =0<br>$$<br>（$F\left(x_{k}\right)$里不含$h$），则<br>$$<br>\left(J_{k}^{T} J_{k}\right) h_{g n}=-J_{k}^{T} f_{k} \<br>x_{k+1}=x_{k}+h_{g n}<br>$$<br>由于Gauss-Newton法求解过程中需要对$J^{T} J$求逆，所以要求$J^{T} J$为非奇异；另外当$x_{0}$离极小值较远时，Gauss-Newton算法可能发散。</p><p>总结Gauss-Newton法的<strong>一般步骤</strong>：</p><ul><li><p>根据$\left(J_{k}^{T} J_{k}\right) h_{g n}=-J_{k}^{T} f_{k}$，求迭代步长$h_{g n}$；</p></li><li><p>$x_{k+1}=x_{k}+h_{g n}$对解进行更新；</p></li><li><p>如果$\left|F\left(x_{k+1}\right)-F\left(x_{k}\right)\right|&lt;\epsilon$，则认为$F(x)$已收敛，则退出迭代，否则重复迭代。</p></li></ul><p>通常Gauss-Newton法收敛较快，但是不稳定。而最快下降法稳定，但是收敛较慢。所以接下来我们介绍GaussNewton和最快下降法混合法。</p><h3 id="LM阻尼最小二乘法"><a href="#LM阻尼最小二乘法" class="headerlink" title="LM阻尼最小二乘法"></a>LM阻尼最小二乘法</h3><p>Gauss-Newton法是用$\left(J_{k}^{T} J_{k}\right) h=-J_{k}^{T} f_{k}$来确定$h$，现在假设在$J_{k}^{T} J_{k}$对角线上元素都加上同一个数$u&gt;0$，即：<br>$$<br>\left(J_{k}^{T} J_{k}+u I\right) h=-J_{k}^{T} f_{k}<br>$$<br>这样即使当$J_{k}^{T} J_{k}$奇异，只要$u$充分大，总能使$\left(J_{k}^{T} J_{k}+u I\right)$，则$\left(J_{k}^{T} J_{k}+u I\right) h=-J_{k}^{T} f_{k}$必有解，这个解依赖于$\boldsymbol{u}$，记作$h_{l m}$。<br>$$<br>\begin{cases}<br>当u=0 &amp;h_{lm}\approx h_{gn}，即为GaussNewton法. \<br>当u充分大 &amp;uIh_{lm}\approx -J_k^Tf_k，h_{lm}=-\frac{1}{u}J_k^Tf_k ，即为最快下降法. \<br>特别当u \to \infty &amp;\left|h_{lm} \right| \to 0 \<br>\end{cases}<br>$$<br>因此$u$ 起着使步长$\left|h_{l m}\right|$缩短或阻尼的作用，此即为阻尼最小二乘法。</p><hr><p>那么LM阻尼最小二乘法实际迭代过程中怎样调整$u$呢？</p><p>假设$|h|$足够小，对$f(x+h)$一阶近似$f(x+h) \approx \iota(h)=f(x)+J(x) h$</p><p>则对$F(x+h)$二阶近似：<br>$$<br>\begin{aligned} F(x+h) \approx L(h) &amp;=\frac{1}{2} f(x+h)^{T} f(x+h) \ &amp;=\frac{1}{2} f^{T} f+h^{T} J^{T} f+\frac{1}{2} h^{T} J^{T} J h \ &amp;=F(x)+h^{T} J^{T} f+\frac{1}{2} h^{T} J^{T} J h \end{aligned}<br>$$<br>我们定义一个增益比$\rho=\frac{F(x)-F\left(x+h_{l m}\right)}{L(0)-L\left(h_{l m}\right)}$</p><p>（在实际中，我们选择一阶近似、二阶近似并不是在所有定义域都满足的，而是在$[x-\epsilon, x+\epsilon]$作用域内满足这个近似条件。）</p><ul><li><p>当$\rho$较大时，表明$F(x+h)$的二阶近似$L(h)$比$F(x+h)$更加接近$F(x)$，因此二阶近似比较好，所以可以减小$u$，采用更大的迭代步长，接近Gauss-Newton法来更快收敛。</p></li><li><p>当$\rho$较小时，表明采取的二阶近似较差，因此通过增大$u$，采用更小的步长，接近最快下降法来稳定的迭代。</p></li></ul><p>一种比较好的阻尼系数$u$随$\rho$选择策略：</p><p>初值$A_{0}=J\left(x_{0}\right)^{T} J\left(x_{0}\right)$，$u_{0}=\tau * \max \left{a_{i i}\right}$，$v_{0}=2$。</p><p>（算法对$\tau$取值不敏感，$\tau$可以取$10^{-6} $、$ 10^{-3}$或1都行。）<br>$$<br>\begin{cases}<br>\text{if $\rho$&gt;0} &amp;u:=u<em>max{\frac{1}{3},1-(2\rho-1)^3} &amp;v:=2;\<br>else &amp;u:=u</em>v &amp;v:=2*v;\<br>\end{cases}<br>$$</p><hr><p>总结LM阻尼最小二乘法的步骤：</p><ul><li><p>step1：初始化$u_{0}=\tau * \max \left{a_{i i}\right}, v_{0}=2$；</p></li><li><p>step2：求梯度$g_{k}=J_{k}^{T} f_{k}$，如果$\left|g_{k}\right| \leq \epsilon_{1}$，则退出，否则退出。</p></li><li><p>step3：根据$\left(J_{k}^{T} J_{k}+u_{k} I\right) h_{l m}=-J_{k}^{T} f_{k}$，求解迭代步长$h_{l m}$，若$\left|h_{l m}\right| \leq \epsilon_{2}\left(|x|+\epsilon_{2}\right)$，则退出，否则继续。</p></li><li><p>step4：$x_{n e w}=x_{k}+h_{l m}$，计算增益比$\boldsymbol{\rho}=\frac{F\left(\boldsymbol{x}<em>{k}\right)-\boldsymbol{F}\left(\boldsymbol{x}</em>{n e w}\right)}{L(0)-L\left(h_{l m}\right)}$。</p><p>如果$\rho&gt;0$，则$x_{k+1}=x_{n e w}$，$u_{k+1}=u_{k} * \max \left{\frac{1}{3}, 1-(2 \rho-1)^{3}\right}$，$v_{k+1}=2$；</p><p>否则$u_{k+1}=u_{k} * v_{k}$，$v_{k+1}=2 * v_{k}$。</p><p>重复step2。</p></li></ul><p>对于$\epsilon_{1}$、$\epsilon_{2}$可以选取任意小的值如$10^{-12}$，只是作为迭代的终止条件，其值得选取对最终的收敛结果影响不大。</p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB Robots Toobox</title>
      <link href="/2020/03/06/Windows/MATLAB-Robots-Toobox/"/>
      <url>/2020/03/06/Windows/MATLAB-Robots-Toobox/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li><a href="http://petercorke.com/wordpress/toolboxes/robotics-toolbox" target="_blank" rel="noopener">主页</a></li><li>R2014a安装的是RTB 9.10</li><li>解压，把<code>rvctools</code>文件夹放到<code>C:\Program Files\MATLAB\R2014a\toolbox</code></li><li>打开MATLAB&gt;设置路径&gt;添加并包含子文件夹&gt;选中<code>rvctools</code>文件夹&gt;保存</li></ol><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><pre><code class="matlab">rtbdemo</code></pre><p>或者查看<code>C:\Program Files\MATLAB\R2014a\toolbox\rvctools\robot\demos</code>和<code>C:\Program Files\MATLAB\R2014a\toolbox\rvctools\robot\examples</code></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h3 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h3><pre><code class="matlab">n=[1 1 1]; %法向量nr=1; %圆的半径为1c=[1 1 1]; %圆心的坐标theta=(0:2*pi/100:2*pi)&#39;; %theta角从0到2*pia=cross(n,[1 0 0]); %n与i叉乘，求取a向量if ~any(a) %如果a为零向量，将n与j叉乘    a=cross(n,[0 1 0]);endb=cross(n,a); %求取b向量a=a/norm(a); %单位化a向量b=b/norm(b); %单位化b向量c1=c(1)*ones(size(theta,1),1);c2=c(2)*ones(size(theta,1),1);c3=c(3)*ones(size(theta,1),1);x=c1+r*a(1)*cos(theta)+r*b(1)*sin(theta);%圆上各点的x坐标y=c2+r*a(2)*cos(theta)+r*b(2)*sin(theta);%圆上各点的y坐标z=c3+r*a(3)*cos(theta)+r*b(3)*sin(theta);%圆上各点的z坐标plot3(x,y,z)xlabel(&#39;x轴&#39;)ylabel(&#39;y轴&#39;)zlabel(&#39;z轴&#39;)</code></pre><h3 id="robot1"><a href="#robot1" class="headerlink" title="robot1"></a>robot1</h3><pre><code class="matlab">L1 = 0.1; L2 = 0.1;% 基于D-H参数创建腿关节%                    theta   d     a  alpha  links(1) = Link([    0       0    0   pi/2 ], &#39;standard&#39;);links(2) = Link([    0       0    L1   0   ], &#39;standard&#39;);links(3) = Link([    0       0   -L2   0   ], &#39;standard&#39;);% 现在创建一个机器人来代表一条腿leg = SerialLink(links, &#39;name&#39;, &#39;leg&#39;, &#39;offset&#39;, [pi/2   0  -pi/2]);% 定义步态轨迹的关键参数，沿x方向行走xf = 5; xb = -xf;   % 脚踏在地面上的前后限制y = 5;              % 脚与身体沿y轴的距离zu = 2; zd = 5;     % 上下时脚的高度% 定义脚所采用的矩形路径segments = [xf y zd; xb y zd; xb y zu; xf y zu] * 0.01;segments = [segments; segments];%pose列表tseg = [3 0.25 0.5 0.25]&#39;;tseg = [1; tseg; tseg];x = mstraj(segments, [], tseg, segments(1,:), 0.01, 0.1);%   TRAJ = MSTRAJ(P, QDMAX, TSEG, Q0, DT, TACC, OPTIONS)%   多段多轴轨迹% -  P（MxN）是通过点的矩阵，每个通过点1行，每个轴一列。最后一个点是目的地。% -  QDMAX（1xN）是轴速限制，不能超过，% -  TSEG（1xM）是每个K段的持续时间% -  Q0（1xN）是初始坐标% -  DT是时间步长% -  TACC（1x1）此加速时间应用于所有段转换% - 每个段的TACC（1xM）加速时间，TACC（i）是从段i到段i + 1的转换的加速时间。 TACC（1）也是段1开始时的加速时间。xcycle = x(100:500,:);qcycle = leg.ikine( transl(xcycle), [], [1 1 1 0 0 0], &#39;pinv&#39; );%机器人身体的矩形，宽度和高度尺寸，腿在每个角落。W = 0.1; L = 0.2;% 一点优化。我们使用了很多绘图选项来快速制作动画：关闭注释，如手腕轴、地面阴影、关节轴，没有平滑的阴影。%我们不是在每个循环中解析开关，而是在这里将它们预分解为一个plotop结构。 plotopt = {&#39;noraise&#39;, &#39;nobase&#39;, &#39;noshadow&#39;, &#39;nowrist&#39;, &#39;nojaxes&#39;, &#39;delay&#39;, 0};% 创建4条腿的机器人。每一个都是我们在上面构建的腿部机器人的克隆体，%有一个独特的名称，以及一个表示它在行走机器人身体上位置的基本变换。legs(1) = SerialLink(leg, &#39;name&#39;, &#39;leg1&#39;);legs(2) = SerialLink(leg, &#39;name&#39;, &#39;leg2&#39;, &#39;base&#39;, transl(-L, 0, 0));legs(3) = SerialLink(leg, &#39;name&#39;, &#39;leg3&#39;, &#39;base&#39;, transl(-L, -W, 0)*trotz(pi));legs(4) = SerialLink(leg, &#39;name&#39;, &#39;leg4&#39;, &#39;base&#39;, transl(0, -W, 0)*trotz(pi));% 为机器人创建固定大小的轴，并将Z正向向下设置clf; axis([-0.3 0.1 -0.2 0.2 -0.15 0.05]); set(gca,&#39;Zdir&#39;, &#39;reverse&#39;)hold on% 画出机器人的身体% patch是个底层的图形函数，用来创建补片图形对象。%一个补片对象是由其顶点坐标确定的一个或多个多边形。用户可以指定补片对象的颜色和灯光。patch([0 -L -L 0], [0 0 -W -W], [0 0 0 0], ...    &#39;FaceColor&#39;, &#39;r&#39;, &#39;FaceAlpha&#39;, 0.5)% 在轴上实例化每个机器人for i=1:4    legs(i).plot(qcycle(1,:), plotopt{:});endhold off% walk!k = 1;%A = Animate(&#39;walking&#39;);%while 1for i=1:500    legs(1).animate( gait(qcycle, k, 0,   0));    legs(2).animate( gait(qcycle, k, 100, 0));    legs(3).animate( gait(qcycle, k, 200, 1));    legs(4).animate( gait(qcycle, k, 300, 1));    drawnow    k = k+1;    %A.add();end</code></pre><h3 id="robot2"><a href="#robot2" class="headerlink" title="robot2"></a>robot2</h3><pre><code class="matlab">%串行链接操纵器包括一系列链接。 每个Link由四个D-H参数描述。%让我们定义一个简单的2链接操纵器。 第一个Link是（Link的参数为d、a、alpha）L1 = Link(&#39;d&#39;, 1, &#39;a&#39;, 2, &#39;alpha&#39;, pi/2);%可以这样引用或定义：%L1.a;% 我们确定它是一个旋转关节L1.isrevolute% 对于给定的关节角度，假设q=0.2 rad，我们可以确定链接变换矩阵L1.A(0.2)% 第二个LinkL2 = Link(&#39;d&#39;, 3, &#39;a&#39;, 4, &#39;alpha&#39;, 0)% 第三个LinkL3 = Link(&#39;d&#39;, 2, &#39;a&#39;, 3, &#39;alpha&#39;, 0)% 现在我们需要将它们连接到一个串行链接机器人操纵器bot = SerialLink([L1 L2 L3], &#39;name&#39;, &#39;my robot&#39;)% 显示的机器人对象显示了很多细节。它还具有许多特性，例如关节数bot.n% 机器人的正向运动学bot.fkine([0.2 0.3 0.4])% 最后我们可以画出我们机器人的简笔画bot.plot([0.4 0.5 0.6])</code></pre><h3 id="baxter1"><a href="#baxter1" class="headerlink" title="baxter1"></a>baxter1</h3><pre><code class="matlab">clc;clear;links = [        Revolute(&#39;d&#39;, 0.27,        &#39;a&#39;, 0.069, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2, &#39;offset&#39;, pi/2)        Revolute(&#39;d&#39;, 0.102+0.262, &#39;a&#39;, 0.069, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2)        Revolute(&#39;d&#39;, 0.103+0.271, &#39;a&#39;, 0.010, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2)        Revolute(&#39;d&#39;, 0.28,        &#39;a&#39;, 0, &#39;alpha&#39;, 0)];left =  SerialLink(links, &#39;name&#39;, &#39;Baxter LEFT&#39;, &#39;manufacturer&#39;, &#39;Rethink Robotics&#39;);right = SerialLink(links, &#39;name&#39;, &#39;Baxter RIGHT&#39;, &#39;manufacturer&#39;, &#39;Rethink Robotics&#39;);left.base = transl(0.064614, 0.25858, 0.119)*rpy2tr(0, 0, pi/4, &#39;xyz&#39;);right.base = transl(0.063534, -0.25966, 0.119)*rpy2tr(0, 0, -pi/4, &#39;xyz&#39;);%4个不同姿态的关节角qz = [0 0 0 0 0 0 0]; qr = [0 -pi/2 -pi/2 0 0 0 0]; qs = [0 0 -pi/2 0 0 0 0];qn = [0 pi/4 pi/2 0 pi/4  0 0];% left.plot(qz);% hold on;% right.plot(qz);t = [0:0.05:1];path = jtraj(qz,qr,t);%计算两种配置之间的关节空间轨迹path= [path;jtraj(qr,qs,t)];path= [path;jtraj(qs,qn,t)];path= [path;jtraj(qn,qz,t)];for q = path&#39;    hold on;    left.plot(q&#39;);    hold on;    right.plot(q&#39;);enda=0;for i = 1:1:20    a=[a;(path(i+1,2)-path(i,2))/0.05];endplot(t,a, &#39;r&#39;);hold on;    plot(t,path(:,2));</code></pre><h3 id="baxter2"><a href="#baxter2" class="headerlink" title="baxter2"></a>baxter2</h3><pre><code class="matlab">clc;clear;%加载机器人模型mdl_baxter;bot_left = left;bot_right = right;%显示（关节角度都是0）left_theta = [0 0 0 0 0 0 0];right_theta = [0 0 0 0 0 0 0];bot_left.plot(left_theta);hold on;bot_right.plot(right_theta);%正运动学（齐次变换）disp(&#39;左手末端位姿：&#39;);left_p0=bot_left.fkine(left_theta)%关节状态插值t = [0:0.05:1];%时间%qz、qr、qs、qn是已经定义好的关节状态%left_path是关节状态的插值，形成连贯动作q1=[0.1 0.2 0.3 0.4 0.5 0.6 0.7];q2=[0.3 0.4 0.5 0.6 0.7 0.3 0.2];q3=[0.5 0.6 0.7 0.1 0.5 0.9 1.0];left_path = jtraj(qz,qr,t);left_path= [left_path;jtraj(q1,q2,t)];left_path= [left_path;jtraj(q2,q3,t)];left_path= [left_path;jtraj(q3,q1,t)];for q = left_path&#39;    hold on;    left.plot(q&#39;);    hold on;    right.plot(q&#39;);end</code></pre><h3 id="避障"><a href="#避障" class="headerlink" title="避障"></a>避障</h3><pre><code class="matlab">%末端直线运动，并避开障碍点clc;clear;L1 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L2 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.4318, &#39;alpha&#39;, 0);L3 = Link(&#39;d&#39;, 0.15005, &#39;a&#39;, 0.0203, &#39;alpha&#39;, -pi/2);L4 = Link(&#39;d&#39;, 0.4318, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L5 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.2, &#39;alpha&#39;, -pi/2);bot = SerialLink([L1 L2 L3 L4 L5], &#39;name&#39;, &#39;my robot&#39;);T1 = transl(0.2, -0.3, 0.0);T2 = transl(0.4, 0.3, 0.2);Tx = transl(0.3, 0.0, 0.1);T = ctraj(T1, T2, 50);for i=1:1:50    d=sqrt((T(1,4,i)-0.3).^2+(T(2,4,i)-0).^2+(T(3,4,i)-0.1).^2); if(d&lt;0.014)     T(1,4,i)=T(1,4,i)+sqrt(0.0002-d.^2);     T(2,4,i)=T(2,4,i)+sqrt(0.0002-d.^2);     T(3,4,i)=T(3,4,i)+sqrt(0.0002-d.^2); endendq0=[0 0 0 0 0];M=[1 1 1 1 1 0];q = ikine(bot,T,q0,M);aplot=zeros(50,3); aa=bot.fkine(q); for i=1:1:50     aaa=aa(:,:,i);     aplot(i,:)=[aaa(1,4),aaa(2,4),aaa(3,4)]; endplot3(aplot(2:50,1),aplot(2:50,2),aplot(2:50,3) ); hold on;bot.plot(q);hold onplot3(0.3 ,0 ,0.1,&#39;r*&#39;);</code></pre><h3 id="w3"><a href="#w3" class="headerlink" title="w3"></a>w3</h3><pre><code class="matlab">%单机械臂末端直线运动，并避开障碍点使用pid控制方法clc;clear;L1 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L2 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.4318, &#39;alpha&#39;, 0);L3 = Link(&#39;d&#39;, 0.11505, &#39;a&#39;, 0.0203, &#39;alpha&#39;, -pi/2);L4 = Link(&#39;d&#39;, 0.4318, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L5 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.2, &#39;alpha&#39;, -pi/2);r1 = SerialLink([L1 L2 L3 L4 L5], &#39;name&#39;, &#39;机械臂1&#39;);T1 = transl(0.2, -0.3, 0.0);        %起始坐标矩阵T2 = transl(0.6, 0.3, 0.2);         %终点坐标矩阵Tx = transl(0.3, 0.0, 0.1);         %假定中点为障碍，需要绕过T = ctraj(T1, T2, 150);              % 直线轨迹规划，150个控制点kp=1;ki=0.7;kd=0; sum=0;d1 = zeros(150,1);%d2 = zeros(150,1);d3 = zeros(150,1);d4 = zeros(150,1);          %存储误差量 for i=1:1:150    d=sqrt((T(1,4,i)-0.6).^2+(T(2,4,i)-0).^2+(T(3,4,i)-0.1).^2);    d1(i,:) = d;  %记录整个规划过程距离障碍物距离    if(d &lt;= 0.07)        d3(i,:) = i;            %存在障碍物的范围    end endd3(d3==0) = [];  [m1,n1] = size(d3);m2 = d3(1,:);m3 = d3(m1,:);          %108-153障碍物范围% d2 = zeros(m1+1,1);     %创建空向量，存储避障信息for i=1:1:150 if((m2&lt;= i)&amp;&amp;(i &lt;= m3))             %进入避障过程    d=sqrt((T(1,4,i)-0.6).^2+(T(2,4,i)-0).^2+(T(3,4,i)-0.1).^2);    n1 = [0.04,-0.02,0];                 %方向向量    n2 = [-0.04,0.02,0];     error = d - 0.07;                                   % 误差 输入-输出    d1(i,:) = d;        %距障碍距离    d4(i,:)=error;    if(error &lt;= 0)           %内%        d2(1,:) = 0;%        d2(i-m2+2,:) = error;%        delta = d2(i-m2+2,:)-d2(i-m2+1,:);    %        sum = sum + error;%        out=(kp*error+ki*sum+kd*delta)*n;                   sum = sum + error;         out=(kp*error+ki*sum)*n1;%          T(1,4,i)=T(1,4,i)+out(1);%          T(2,4,i)=T(2,4,i)+out(2);%          T(3,4,i)=T(3,4,i)+out(3);            %修正    end    if(error &gt; 0)           %外         sum = sum + error;         out=(kp*error+ki*sum)*n2;%          T(1,4,i)=T(1,4,i)+out(1);%          T(2,4,i)=T(2,4,i)+out(2);%          T(3,4,i)=T(3,4,i)+out(3);               end    T(1,4,i+1)=T(1,4,i)+out(1);    T(2,4,i+1)=T(2,4,i)+out(2);    T(3,4,i+1)=T(3,4,i)+out(3);   %将修正后的点储存               endendq0=[0 0 0 0 0];M=[1 1 1 1 1 0];theta = ikine(r1,T,q0,M);        %反向运动学，关节角度矩阵aplot=zeros(150,3);aa=r1.fkine(theta);                     %正解，末端姿态坐标矩阵 for i=1:1:150    position = transl(aa);          %末端空间坐标矩阵（xyz）    aplot(i,:)=[position(i,1),position(i,2),position(i,3)];  end plot3(aplot(:,1),aplot(:,2),aplot(:,3),&#39;LineWidth&#39;,2 );  hold on; plot3(0.6 ,0 ,0.1,&#39;r*&#39;); hold on; r1.plot(theta); hold on figure(2); plot(d1,&#39;b&#39;); title(&#39;末端距障碍物距离&#39;); hold on; figure(3); plot(d4,&#39;r&#39;); title(&#39;理想轨迹误差&#39;);</code></pre><h3 id="匀减速"><a href="#匀减速" class="headerlink" title="匀减速"></a>匀减速</h3><pre><code class="matlab">%匀加速运动clc;clear;links = [        Revolute(&#39;d&#39;, 0.27,        &#39;a&#39;, 0.069, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2, &#39;offset&#39;, pi/2)        Revolute(&#39;d&#39;, 0.102+0.262, &#39;a&#39;, 0.069, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2)        Revolute(&#39;d&#39;, 0.103+0.271, &#39;a&#39;, 0.010, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2)        Revolute(&#39;d&#39;, 0.28,        &#39;a&#39;, 0, &#39;alpha&#39;, 0)];left =  SerialLink(links, &#39;name&#39;, &#39;Baxter LEFT&#39;, &#39;manufacturer&#39;, &#39;Rethink Robotics&#39;);right = SerialLink(links, &#39;name&#39;, &#39;Baxter RIGHT&#39;, &#39;manufacturer&#39;, &#39;Rethink Robotics&#39;);left.base = transl(0.064614, 0.25858, 0.119)*rpy2tr(0, 0, pi/4, &#39;xyz&#39;);right.base = transl(0.063534, -0.25966, 0.119)*rpy2tr(0, 0, -pi/4, &#39;xyz&#39;);%4个不同姿态的关节角qz = [0 0 0 0 0 0 0]; qr = [0 -pi/2 -pi/2 0 0 0 0]; qs = [0 0 -pi/2 0 0 0 0];qn = [0 pi/4 pi/2 0 pi/4  0 0];t = [0:0.01:1];[,len]=length(t);path=zeros(len,7);a1=2*(qr(1,2)-qz(1,2));%角加速度a2=2*(qr(1,3)-qz(1,3));ddd=zeros(len,3);bbb=zeros(len,3);for i = 1:1:len    tt=t(1,i);    q=[0 (a1*tt*tt)/2 (a2*tt*tt)/2 0 0 0 0];%每过1/100s更新的角度量    path(i,:)=q;    zz=left.fkine(q);   ddd(i,:)=[zz(1,4),zz(2,4),zz(3,4)];    xx=right.fkine(q);   bbb(i,:)=[xx(1,4),xx(2,4),xx(3,4)];endplot3(ddd(:,1),ddd(:,2),ddd(:,3));hold on;plot3(bbb(:,1),bbb(:,2),bbb(:,3));hold on;% plot(t,path(:,2));% figure(2);for q = path&#39;    hold on;    left.plot(q&#39;);    hold on;    right.plot(q&#39;);end</code></pre><h3 id="匀速"><a href="#匀速" class="headerlink" title="匀速"></a>匀速</h3><pre><code class="matlab">%匀速运动clc;clear;links = [        Revolute(&#39;d&#39;, 0.27,        &#39;a&#39;, 0.069, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2, &#39;offset&#39;, pi/2)        Revolute(&#39;d&#39;, 0.102+0.262, &#39;a&#39;, 0.069, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2)        Revolute(&#39;d&#39;, 0.103+0.271, &#39;a&#39;, 0.010, &#39;alpha&#39;, -pi/2)        Revolute(&#39;d&#39;, 0,           &#39;a&#39;, 0, &#39;alpha&#39;, pi/2)        Revolute(&#39;d&#39;, 0.28,        &#39;a&#39;, 0, &#39;alpha&#39;, 0)];left =  SerialLink(links, &#39;name&#39;, &#39;Baxter LEFT&#39;, &#39;manufacturer&#39;, &#39;Rethink Robotics&#39;);right = SerialLink(links, &#39;name&#39;, &#39;Baxter RIGHT&#39;, &#39;manufacturer&#39;, &#39;Rethink Robotics&#39;);left.base = transl(0.064614, 0.25858, 0.119)*rpy2tr(0, 0, pi/4, &#39;xyz&#39;);right.base = transl(0.063534, -0.25966, 0.119)*rpy2tr(0, 0, -pi/4, &#39;xyz&#39;);%4个不同姿态的关节角qz = [0 0 -pi/2 0 0 0 0]; qr = [0 -pi/2 0 0 0 0 0]; qs = [0 0 -pi/2 0 0 0 0];qn = [0 pi/4 pi/2 0 pi/4  0 0];t = [0:0.01:1];[,len]=length(t);path=zeros(len,7);a1=(qr(1,2)-qz(1,2))/len;%角速度a2=(qr(1,3)-qz(1,3))/len;for i = 1:1:len    q=[0 a1*i a2*i 0 0 0 0];%每过1/100s更新的角度量    path(i,:)=q;    %path= [path;q];endfor q = path&#39;    hold on;    left.plot(q&#39;);    hold on;    right.plot(q&#39;);endfigure(2);plot(t,path(:,2));</code></pre><h3 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h3><pre><code class="matlab">%末端直线运动clc;clear;L1 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L2 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.4318, &#39;alpha&#39;, 0);L3 = Link(&#39;d&#39;, 0.15005, &#39;a&#39;, 0.0203, &#39;alpha&#39;, -pi/2);L4 = Link(&#39;d&#39;, 0.4318, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L5 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.2, &#39;alpha&#39;, -pi/2);bot = SerialLink([L1 L2 L3 L4 L5], &#39;name&#39;, &#39;my robot&#39;);T1 = transl(0.2, -0.3, 0.0);T2 = transl(0.4, 0.3, 0.2);T = ctraj(T1, T2, 50);q0=[0 0 0 0 0];M=[1 1 1 1 1 0];q = ikine(bot,T,q0,M);aplot=zeros(50,3); aa=bot.fkine(q); for i=1:1:50     aaa=aa(:,:,i);     aplot(i,:)=[aaa(1,4),aaa(2,4),aaa(3,4)]; endplot3(aplot(2:50,1),aplot(2:50,2),aplot(2:50,3) ); hold on;bot.plot(q);</code></pre><h3 id="作业1"><a href="#作业1" class="headerlink" title="作业1"></a>作业1</h3><pre><code class="matlab">%末端直线运动，在障碍点处做圆弧运动clc;clear;L1 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L2 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.4318, &#39;alpha&#39;, 0);L3 = Link(&#39;d&#39;, 0.15005, &#39;a&#39;, 0.0203, &#39;alpha&#39;, -pi/2);L4 = Link(&#39;d&#39;, 0.4318, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L5 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.2, &#39;alpha&#39;, -pi/2);bot = SerialLink([L1 L2 L3 L4 L5], &#39;name&#39;, &#39;my robot&#39;);T1 = transl(0.2, -0.3, 0.0);T2 = transl(0.4, 0.3, 0.2);Tx = transl(0.3, 0.0, 0.1);T = ctraj(T1, T2, 50);%判断离障碍点的距离index1=0;index2=0;%待修正轨迹的起点和终点for i=1:1:50    d=sqrt((T(1,4,i)-0.3).^2+(T(2,4,i)-0).^2+(T(3,4,i)-0.1).^2);    if(d&lt;0.014)        if index1==0           index1=i;        end        index2=i;     endend%替换成圆弧n=[0 1 -3]; %法向量n（与直线叉积为0即可）r=0.014; %圆的半径为1c=[0.3, 0.0, 0.1]; %圆心的坐标theta1=pi/10;theta=(theta1:pi/20:theta1+pi)&#39;; %theta角从0到2*pia=cross(n,[1 0 0]); %n与i叉乘，求取a向量if ~any(a) %如果a为零向量，将n与j叉乘    a=cross(n,[0 1 0]);endb=cross(n,a); %求取b向量a=a/norm(a); %单位化a向量b=b/norm(b); %单位化b向量c1=c(1)*ones(size(theta,1),1);c2=c(2)*ones(size(theta,1),1);c3=c(3)*ones(size(theta,1),1);x=c1+r*a(1)*cos(theta)+r*b(1)*sin(theta);%圆上各点的x坐标y=c2+r*a(2)*cos(theta)+r*b(2)*sin(theta);%圆上各点的y坐标z=c3+r*a(3)*cos(theta)+r*b(3)*sin(theta);%圆上各点的z坐标TT=T(:,:,1:index1-1);%TT赋值前一段线段for i =1:1:size(x,1)%TT赋值圆弧段    TT(:,:,index1-1+i)=transl(x(i),y(i),z(i));endzz=size(TT,3);for i=1:1:(50-index2)%TT赋值后一段线段    TT(:,:,zz+i)=T(:,:,index2+i);end%逆运动学q0=[0 0 0 0 0];M=[1 1 1 1 1 0];q = ikine(bot,TT,q0,M);%画出末端轨迹线T_size=size(TT,3);%姿态数量bot_end=zeros(T_size,3);%用于存放末端位置 T_f=bot.fkine(q);%正运动学计算 for i=1:1:T_size%计算的位姿结果赋值     tmp=T_f(:,:,i);     bot_end(i,:)=[tmp(1,4),tmp(2,4),tmp(3,4)]; endplot3(bot_end(2:T_size,1),bot_end(2:T_size,2),bot_end(2:T_size,3));%画出轨迹线 hold on; %画出障碍点plot3(0.3 ,0 ,0.1,&#39;r*&#39;); hold on; %画出运动过程bot.plot(q);</code></pre><h3 id="作业2"><a href="#作业2" class="headerlink" title="作业2"></a>作业2</h3><pre><code class="matlab">clc;clear;L1 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L2 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.4318, &#39;alpha&#39;, 0);L3 = Link(&#39;d&#39;, 0.15005, &#39;a&#39;, 0.0203, &#39;alpha&#39;, -pi/2);L4 = Link(&#39;d&#39;, 0.4318, &#39;a&#39;, 0, &#39;alpha&#39;, pi/2);L5 = Link(&#39;d&#39;, 0, &#39;a&#39;, 0.2, &#39;alpha&#39;, -pi/2);bot = SerialLink([L1 L2 L3 L4 L5], &#39;name&#39;, &#39;my robot&#39;);%目标轨迹是一条线段T1 = transl(0.2, -0.3, 0.0);%起始点T2 = transl(0.4, 0.3, 0.2);%目标点%障碍轨迹是穿过目标轨迹的线段，障碍点沿障碍点轨迹匀速穿过目标轨迹T3 = transl(0.28, 0.01, 0.1);%障碍起始点T4 = transl(0.32, -0.01, 0.1);%障碍目标点%假设时间序列有120个%障碍轨迹线，来回运动Tb=ctraj(T4,T3,20);Tb2=ctraj(T3,T4,20);Tb3=ctraj(T4,T3,20);Tb4=ctraj(T3,T4,20);Tb5=ctraj(T4,T3,20);Tb6=ctraj(T3,T4,20);for i=1:1:20    Tb(:,:,20+i)=Tb2(:,:,i);endfor i=1:1:20    Tb(:,:,40+i)=Tb3(:,:,i);endfor i=1:1:20    Tb(:,:,60+i)=Tb4(:,:,i);endfor i=1:1:20    Tb(:,:,80+i)=Tb5(:,:,i);endfor i=1:1:20    Tb(:,:,100+i)=Tb6(:,:,i);end Tb_size=size(Tb,3); for i=1:1:Tb_size     tmp=Tb(:,:,i);     Tb_end(i,:)=[tmp(1,4),tmp(2,4),tmp(3,4)]; end%目标轨迹线 T=ctraj(T1,T2,120); %避障过程 Kp=8; Ki=0.3; sum=0;%pid的积分项 for i=1:1:120    d=sqrt((T(1,4,i)-Tb(1,4,i)).^2+(T(2,4,i)-Tb(2,4,i)).^2+(T(3,4,i)-Tb(3,4,i)).^2);%末端离障碍点的距离    if(d&lt;0.06)        n=[0.04,-0.02,0];%避障方向向量        %pid控制，跟踪量为以障碍点为圆心的球体面        error=d-0.06;        sum=sum+error;        out=(Kp*error+Ki*sum)*n;        T(1,4,i)=T(1,4,i)+out(1);        T(2,4,i)=T(2,4,i)+out(2);        T(3,4,i)=T(3,4,i)+out(3);     endend%逆运动学解算q0=[0 0 0 0 0];M=[1 1 1 1 1 0];q = ikine(bot,T,q0,M);%显示机械臂和障碍物的运动过程for i=1:1:119    %hold off;    bot.plot(q(i,:));    plot3(Tb_end(i,1),Tb_end(i,2),Tb_end(i,3) ,&#39;r*&#39;);endhold on;bot.plot(q(120,:));plot3(Tb_end(120,1),Tb_end(120,2),Tb_end(120,3) ,&#39;r*&#39;);%画出末端曲线T_end=zeros(size(T,3),3); T_f=bot.fkine(q); for i=1:1:size(T,3)     tmp=T_f(:,:,i);     T_end(i,:)=[tmp(1,4),tmp(2,4),tmp(3,4)]; endplot3(T_end(2:size(T,3),1),T_end(2:size(T,3),2),T_end(2:size(T,3),3) );plot3(Tb_end(2:size(T,3),1),Tb_end(2:size(T,3),2),Tb_end(2:size(T,3),3),&#39;r&#39; ); hold on;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VS+RealSense+OpenCV</title>
      <link href="/2020/03/06/Windows/VS+RealSense+OpenCV/"/>
      <url>/2020/03/06/Windows/VS+RealSense+OpenCV/</url>
      
        <content type="html"><![CDATA[<ol><li><h5 id="新建空的c-项目"><a href="#新建空的c-项目" class="headerlink" title="新建空的c++项目"></a>新建空的c++项目</h5><p>设置文Release x64</p></li><li><h5 id="添加C-包含目录"><a href="#添加C-包含目录" class="headerlink" title="添加C++包含目录"></a>添加C++包含目录</h5><pre><code>C:\Program Files (x86)\Intel RealSense SDK 2.0\includeC:\Users\liuly\opencv3\build\include</code></pre></li><li><h5 id="添加C-库目录"><a href="#添加C-库目录" class="headerlink" title="添加C++库目录"></a>添加C++库目录</h5><pre><code>C:\Users\liuly\opencv3\build\x64\vc15\libC:\Program Files (x86)\Intel RealSense SDK 2.0\lib\x64</code></pre></li><li><h5 id="添加lib的链接"><a href="#添加lib的链接" class="headerlink" title="添加lib的链接"></a>添加lib的链接</h5><p>链接器&gt;输入&gt;附加依赖项：<code>opencv_world347.lib</code>、<code>realsense2.lib</code></p></li><li><h5 id="测试im-show程序"><a href="#测试im-show程序" class="headerlink" title="测试im-show程序"></a>测试im-show程序</h5><pre><code class="c++">#include &lt;librealsense2/rs.hpp&gt;            //包括RealSense跨平台API#include &lt;opencv2/opencv.hpp&gt;            //包含penCV APIint main(int argc, char * argv[]) try    // 有个try{    rs2::colorizer color_map;            // 声明depth colorizer以实现深度数据的可视化    rs2::pipeline pipe;                    // 声明RealSense pipeline，用来封装实际设备和传感器    pipe.start();                        // 使用默认的推荐配置开始流式传输    using namespace cv;    const auto window_name = &quot;显示深度图像&quot;;    namedWindow(window_name, WINDOW_AUTOSIZE);    // 循环读取数据并显示    while (waitKey(1) &lt; 0 &amp;&amp; getWindowProperty(window_name, WND_PROP_AUTOSIZE) &gt;= 0)    {        rs2::frameset data = pipe.wait_for_frames();                        // 等待相机的下一组帧        rs2::frame depth = data.get_depth_frame().apply_filter(color_map);    //从data中取出着色深度数据        // 查询帧大小（宽度和高度）        const int w = depth.as&lt;rs2::video_frame&gt;().get_width();        const int h = depth.as&lt;rs2::video_frame&gt;().get_height();        // 从着色的深度数据创建大小为(w,h)的opencv矩阵        Mat image(Size(w, h), CV_8UC3, (void*)depth.get_data(), Mat::AUTO_STEP);        // 更新窗口        imshow(window_name, image);    }    return EXIT_SUCCESS;}// 执行失败的话catch (const rs2::error &amp; e){    std::cerr &lt;&lt; &quot;RealSense error calling &quot; &lt;&lt; e.get_failed_function() &lt;&lt; &quot;(&quot; &lt;&lt; e.get_failed_args() &lt;&lt; &quot;):\n    &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    return EXIT_FAILURE;}catch (const std::exception&amp; e){    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;    return EXIT_FAILURE;}</code></pre><pre><code></code></pre></li></ol><p>```</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VS2017编译ORB-SLAM2</title>
      <link href="/2020/03/06/Windows/VS2017%E7%BC%96%E8%AF%91ORB-SLAM2/"/>
      <url>/2020/03/06/Windows/VS2017%E7%BC%96%E8%AF%91ORB-SLAM2/</url>
      
        <content type="html"><![CDATA[<h3 id="VS2017编译ORB-SLAM2"><a href="#VS2017编译ORB-SLAM2" class="headerlink" title="VS2017编译ORB-SLAM2"></a>VS2017编译ORB-SLAM2</h3><p><a href="https://blog.csdn.net/o_ha_yo_yepeng/article/details/80070314" target="_blank" rel="noopener">教程</a></p><ol><li><h4 id="安装CMake"><a href="#安装CMake" class="headerlink" title="安装CMake"></a>安装CMake</h4><p><a href="https://cmake.org/download/" target="_blank" rel="noopener">地址</a></p></li><li><h4 id="安装Git-Bash"><a href="#安装Git-Bash" class="headerlink" title="安装Git Bash"></a>安装Git Bash</h4><p><a href="https://gitforwindows.org/" target="_blank" rel="noopener">地址</a>，编译Pangolin用到</p><pre><code class="sh">git config --global user.name &quot;liuly123&quot;git config --global user.email &quot;2240057686@qq.com&quot;ssh-keygen -t rsa -C &quot;2240057686@qq.com&quot;cat C:\Users\liuly/.ssh#添加到GitHub上#以上这些步骤都可以省略</code></pre></li><li><h4 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h4><p><a href="https://github.com/phdsky/ORBSLAM24Windows" target="_blank" rel="noopener">地址</a>，使用git</p></li><li><h4 id="下载OpenCV库"><a href="#下载OpenCV库" class="headerlink" title="下载OpenCV库"></a>下载OpenCV库</h4><p><a href="https://sourceforge.net/projects/opencvlibrary/files/opencv-win/2.4.13/" target="_blank" rel="noopener">地址</a>，解压，然后添加Path（用于运行）</p><pre><code>C:\Users\liuly\opencv\build\x64\vc14\bin</code></pre><p>为CMake添加环境变量：电脑的环境变量——&gt;系统变量——&gt;新建，变量名<code>OpenCV_DIR</code>变量值：（动态库）</p><pre><code>C:\Users\liuly\opencv\build</code></pre></li><li><h4 id="Eigen库"><a href="#Eigen库" class="headerlink" title="Eigen库"></a>Eigen库</h4><p>Eigen库是一个模板库，不需要编译</p></li><li><h4 id="编译DBoW库"><a href="#编译DBoW库" class="headerlink" title="编译DBoW库"></a>编译DBoW库</h4><p>打开CMake-gui，source code输入<code>C:\Users\liuly\Desktop\ORBSLAM24Windows\Thirdparty\DBoW2</code>，where to build输入<code>C:\Users\liuly\Desktop\ORBSLAM24Windows\Thirdparty\DBoW2\build</code></p><p>然后点configure，选中vs2017，platform选x64&gt;generate&gt;报错，然后修改OpenCV_DIR为<code>C:\Users\liuly\opencv\build\x64\vc14\lib</code>&gt;configure&gt;generate&gt;open project&gt;改成Release&gt;右键ALL_BUILD&gt;生成的lib文件为<code>ORBSLAM24Windows\Thirdparty\DBoW2\lib\ReleaseDBoW2.lib</code></p></li><li><h4 id="编译g2o库"><a href="#编译g2o库" class="headerlink" title="编译g2o库"></a>编译g2o库</h4><p>打开Cmake-gui，输入source code和where to build&gt;configure&gt;generate&gt;open project&gt;改成Release&gt;右键g2o&gt;属性&gt;C++/预处理器/预处理定义&gt;最后一行添加<code>WINDOWS</code>&gt;保存&gt;右键ALL_BUILD&gt;生成的lib文件为``ORBSLAM24Windows\Thirdparty\g2o\lib\Release\g2o.lib`</p></li><li><h4 id="编译Pangolin库"><a href="#编译Pangolin库" class="headerlink" title="编译Pangolin库"></a>编译Pangolin库</h4><p>打开Cmake-gui，输入source code和where to build&gt;configure&gt;generate&gt;open project&gt;改成Release。</p><p>注意：Pangolin库编译的时候会在git上下载一些依赖库，需要先打开Shadowsocks，然后在GitBash输入</p><pre><code class="sh">git config --global http.proxy &#39;socks5://127.0.0.1:1080&#39;</code></pre><p>然后右键ALL_BUILD&gt;生成（会git下载一些文件，还会报错无法发开pthread.lib，忽略）</p></li><li><h4 id="编译ORB-SLAM2"><a href="#编译ORB-SLAM2" class="headerlink" title="编译ORB-SLAM2"></a>编译ORB-SLAM2</h4><p>打开Cmake-gui，输入source code和where to build&gt;configure&gt;报错，然后修改OpenCV_DIR为<code>C:\Users\liuly\opencv\build\x64\vc14\lib</code>&gt;configure&gt;generate&gt;open project&gt;改成Release&gt;添加一些库依赖：</p><p>右键ORB-SLAM&gt;属性&gt;C++常规&gt;附加包含目录&gt;添加</p><pre><code>C:\Users\liuly\Desktop\ORBSLAM24Windows\Thirdparty\DBoW2C:\Users\liuly\Desktop\ORBSLAM24Windows\Thirdparty\DBoW2\DBoW2C:\Users\liuly\Desktop\ORBSLAM24Windows\Thirdparty\DBoW2\DUtilsC:\Users\liuly\Desktop\ORBSLAM24Windows\Thirdparty\g2o</code></pre><p>右键ALL_BUILD&gt;生成</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="powershell">#C:\Users\liuly\Desktop\ORBSLAM24Windows打开powshell#单目测试.\Examples\Monocular\Release\mono_tum.exe .\Vocabulary\ORBvoc.txt .\Examples\Monocular\TUM1.yaml D:\SLAM\dataset\TUM_RGB-D\rgbd_dataset_freiburg1_xyz#RGBD.\Examples\RGB-D\Release\rgbd_tum.exe .\Vocabulary\ORBvoc.txt .\Examples\RGB-D\TUM1.yaml D:\SLAM\dataset\TUM_RGB-D\rgbd_dataset_freiburg1_room D:\SLAM\dataset\TUM_RGB-D\rgbd_dataset_freiburg1_room\associate.txt#KITTI数据集双目测试.\Examples\Stereo\Release\stereo_kitti.exe .\Vocabulary\ORBvoc.txt .\Examples\Stereo\KITTI00-02.yaml D:\SLAM\dataset\data_odometry_gray/00</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Win10+CMake+MinGW+CLion</title>
      <link href="/2020/03/06/Windows/Win10+CMake+MinGW+CLion/"/>
      <url>/2020/03/06/Windows/Win10+CMake+MinGW+CLion/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/JohnJim0/article/details/81842249" target="_blank" rel="noopener">教程1</a>、<a href="https://www.cnblogs.com/herelsp/p/8679200.html#_label2" target="_blank" rel="noopener">教程2</a></p><ol><li><h4 id="安装CMake"><a href="#安装CMake" class="headerlink" title="安装CMake"></a>安装CMake</h4><p><a href="https://cmake.org/download/" target="_blank" rel="noopener">地址</a>，验证：控制台输入<code>cmake</code></p></li><li><h4 id="安装MinGW"><a href="#安装MinGW" class="headerlink" title="安装MinGW"></a>安装MinGW</h4><p><a href="https://sourceforge.net/projects/mingw-w64/" target="_blank" rel="noopener">地址</a>，安装修改：<code>x86_64</code>、<code>posix</code>。添加环境变量：找到 <code>mingw-w64.bat</code>，里面有变量地址（但运行该文件不能添加，所以要手动添加）。把<code>mingw32-make.exe</code>复制一份改为<code>make.exe</code></p></li><li><h4 id="测试HelloWord程序"><a href="#测试HelloWord程序" class="headerlink" title="测试HelloWord程序"></a>测试HelloWord程序</h4><pre><code class="cpp">#test.cpp文件#include &lt;stdio.h&gt;int main(){    printf(&quot;hello\n&quot;);    return 0;}</code></pre><pre><code class="cmake">#CMakeLists.txt文件cmake_minimum_required(VERSION 3.0)project(Hello)set(SOURCE test.cpp)add_executable(${PROJECT_NAME} ${SOURCE})</code></pre><pre><code class="powershell">#编译运行mkdir buildcd buildcmake -G&quot;Unix Makefiles&quot; ../ -DCMAKE_BUILD_TYPE=Releasemake.\Hello.exe</code></pre></li><li><h4 id="安装CLion"><a href="#安装CLion" class="headerlink" title="安装CLion"></a>安装CLion</h4></li></ol><ol start="5"><li><h4 id="编译OpenCV"><a href="#编译OpenCV" class="headerlink" title="编译OpenCV"></a>编译OpenCV</h4><p><a href="https://blog.csdn.net/u010798503/article/details/88065863" target="_blank" rel="noopener">参考</a>，注意不要安装Python2（或者换成Python3）</p></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ZED-VS</title>
      <link href="/2020/03/06/Windows/ZED-VS/"/>
      <url>/2020/03/06/Windows/ZED-VS/</url>
      
        <content type="html"><![CDATA[<ol><li>安装CUDA**</li></ol><p>原来下的是CUDA10.1，ZED要求10.0，<a href="https://developer.nvidia.com/cuda-10.0-download-archive?target_os=Windows&target_arch=x86_64&target_version=10&target_type=exelocal" target="_blank" rel="noopener">下载地址</a>，一路下一步，精简安装</p><p><strong>2. 安装ZED-SDK</strong></p><p>一路下一步</p><p><strong>3. 创建VS工程</strong></p><p>3.1 打开VS&gt;Visual C++&gt; 空项目（起名为ZED）</p><p>3.2 右键<code>源文件</code>&gt;添加&gt;新项目&gt;C++文件&gt;（起名）main.cpp，粘贴内容为：<a href="https://raw.githubusercontent.com/stereolabs/zed-examples/master/plane%20detection/src/main.cpp" target="_blank" rel="noopener">地址</a>（浏览器打开再复制）</p><p>3.3 再添加一个C++文件，名叫<code>GLViewer.cpp</code>，内容为：<a href="https://raw.githubusercontent.com/stereolabs/zed-examples/master/plane%20detection/src/GLViewer.cpp" target="_blank" rel="noopener">地址</a></p><p>3.4 右键<code>头文件</code>，添加一个头文件，名为<code>GLViewer.hpp</code>，内容为：<a href="https://raw.githubusercontent.com/stereolabs/zed-examples/master/plane%20detection/include/GLViewer.hpp" target="_blank" rel="noopener">地址</a></p><p>3.5 右键ZED&gt;属性&gt;VC++目录&gt;包含目录&gt;</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>esp8266-arduinoIDE</title>
      <link href="/2020/03/06/Windows/esp8266-arduinoIDE/"/>
      <url>/2020/03/06/Windows/esp8266-arduinoIDE/</url>
      
        <content type="html"><![CDATA[<ol><li><p>下载安装1.88版</p><p><a href="https://www.arduino.cc/en/Main/Software?setlang=cn" target="_blank" rel="noopener">地址</a></p></li><li><p>添加开发板</p><p><a href="https://github.com/esp8266/esp8266.github.io/tree/master/stable" target="_blank" rel="noopener">github地址</a>，<a href="https://raw.githubusercontent.com/esp8266/esp8266.github.io/master/stable/package_esp8266com_index.json" target="_blank" rel="noopener">json地址</a>。</p><p>在<code>文件&gt;首选项&gt;附加开发板管理器</code>里添加json地址</p><p>在<code>工具&gt;开发板管理</code>中添加esp8266开发板，安装2.5.2版</p><p>选择开发板ESP-12E</p></li><li><p>安装VS Code</p><p>安装插件Arduino（微软开发）</p><p>点Arduino扩展的齿轮&gt;设置Arduino ：Path为<code>C:\Program Files (x86)\Arduino</code></p></li><li><p>打开空文件夹</p><p>创建<code>.ino</code>文件（文件名和文件夹相同）</p><p>在下面状态栏设置：<code>AVRISP.mkll</code>、<code>ModeMCU1.0</code>、<code>COM4</code><br>右上Upload</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>frp配置</title>
      <link href="/2020/03/06/Windows/frp%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/03/06/Windows/frp%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="frp配置"><a href="#frp配置" class="headerlink" title="frp配置"></a>frp配置</h2><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a><a href="https://github.com/fatedier/frp/releases/" target="_blank" rel="noopener">下载</a></h4><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><pre><code class="ini">#frps.ini[common]bind_port = 7000dashboard_port = 7500dashboard_user = liulydashboard_pwd = abc12345token = qwertyabc</code></pre><p>启动：<code>./frps -c ./frps.ini</code></p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><pre><code class="ini">#frpc.ini[common]server_addr = liuly.imwork.netserver_port = 7000token = qwertyabc[test]type = tcplocal_ip = 127.0.0.1local_port = 80remote_port = 1024</code></pre><p>启动：<code>./frps -c ./frps.ini</code></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>key</title>
      <link href="/2020/03/06/Windows/key/"/>
      <url>/2020/03/06/Windows/key/</url>
      
        <content type="html"><![CDATA[<p>友善License<code>CCCCC-AAAAA-FFFFF-0E013-6EE85</code></p><p>VS2017 key <code>KBJFW-NXHK6-W4WJM-CRMQB-G3CDH</code></p><p>VS2013 key <code>BWG7X-J98B3-W34RT-33B3R-JVYW9</code></p><p>office2007 key <code>DBXYD-TF477-46YM4-W74MH-6YDQ8</code></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32-mdk安装</title>
      <link href="/2020/03/06/Windows/stm32-mdk%E5%AE%89%E8%A3%85/"/>
      <url>/2020/03/06/Windows/stm32-mdk%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p><a href="https://guanghou-my.sharepoint.com/:f:/g/personal/chenghello_get365_pw/EhgWI9ibjTFDq1Mab3wvyFsBaLrZJ9T5qW_1DghwHX-Ruw" target="_blank" rel="noopener">下载地址</a><img src="/images/stm32-mdk%E5%AE%89%E8%A3%85/1566286165329.png" alt="1566286165329"></p><p>另外：修改C/C++，勾选c99</p><p><a href="https://www.cnblogs.com/firege/p/5748260.html" target="_blank" rel="noopener">教程</a></p><table><thead><tr><th align="center">模式</th><th align="center">BOOT0</th><th align="center">BOOT1</th></tr></thead><tbody><tr><td align="center">普通启动</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">ISP下载</td><td align="center">1</td><td align="center">0</td></tr></tbody></table><p>串口下载引脚：A9和A10</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>newifi3刷机</title>
      <link href="/2020/03/06/Windows/newifi3%E5%88%B7%E6%9C%BA/"/>
      <url>/2020/03/06/Windows/newifi3%E5%88%B7%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="开启ssh"><a href="#开启ssh" class="headerlink" title="开启ssh"></a>开启ssh</h3><p>打开连接<a href="http://192.168.99.1/newifi/ifiwen_hss.html，（没试过）" target="_blank" rel="noopener">http://192.168.99.1/newifi/ifiwen_hss.html，（没试过）</a></p><p>或登陆路由器，安装ssh插件</p><h3 id="刷breed"><a href="#刷breed" class="headerlink" title="刷breed"></a>刷breed</h3><p>把<code>newifi-d2-jail-break.ko</code>文件放进U盘，插路由器上</p><p>打开<code>putty.exe</code>，连接<code>192.168.99.1</code>，用户名是<code>root</code>，密码是<code>web登陆密码</code></p><pre><code class="sh">cd /mnt/sda1 #进入U盘，我的u盘名叫A，就是cd /mnt/Als #显示当前目录的文件insmod newifi-d2-jail-break.ko #加载一个驱动文件（就是刷机）</code></pre><p>等重启或半分钟</p><h3 id="进breed，备份编程器固件，刷机"><a href="#进breed，备份编程器固件，刷机" class="headerlink" title="进breed，备份编程器固件，刷机"></a>进breed，备份编程器固件，刷机</h3><ol><li>拔电源，按住<code>reset键</code>，插电源</li><li>浏览器输入<a href="http://192.168.1.1" target="_blank" rel="noopener">http://192.168.1.1</a></li><li>选择<code>固件备份</code>，点编程器固件，下载<code>full.bin</code>文件（编程器固件是整个flash的数据，含有无线矫正数据，所以要备份）</li><li>选择<code>恢复出厂设置</code>，闪存布局选择<code>公版</code>，点<code>恢复出厂</code></li><li>选择<code>固件更新</code>，点<code>固件</code>右边的浏览，选择<code>NEWIFI-D2_3.4.3.9-099_20181020-1912.trx</code>或下载的对应固件，点<code>上传</code>，点<code>刷机</code></li></ol><h3 id="设置ipv6"><a href="#设置ipv6" class="headerlink" title="设置ipv6"></a>设置ipv6</h3><ol><li>进路由器，点<code>administration</code>，最下面选中文</li><li>点<code>自定义设置</code>&gt;<code>脚本</code>&gt;<code>在防火墙规则启动后执行</code>&gt;填入</li></ol><pre><code class="sh">modprobe ip6table_mangleebtables -t broute -A BROUTING -p ! ipv6 -j DROP -i eth2.2brctl addif br0 eth2.2</code></pre><p>都要点<strong>应用本页设置</strong></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>surface-ubuntu</title>
      <link href="/2020/03/06/Windows/surface-ubuntu/"/>
      <url>/2020/03/06/Windows/surface-ubuntu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.reddit.com/r/SurfaceLinux/comments/8sd3zy/how_to_dual_boot_ubuntu_1804_on_surface_book/" target="_blank" rel="noopener">教程</a></p><ol><li><p>压缩分区、备份EFI</p></li><li><p>关闭Secure Boot</p></li><li><p>启动Ubuntu U盘</p></li><li><p>正常安装（不勾选第三方）</p></li><li><p>修改源并update（不更新）</p></li><li><p>安装<a href="https://github.com/timobaehr/Surface-Boot-Themes/tree/surface_book" target="_blank" rel="noopener">linux-surface</a>内核</p><ul><li><p>安装驱动和内核</p><pre><code class="sh">sudo apt install git curl wget sedgit clone --depth 1 https://github.com/jakeday/linux-surface.git ~/linux-surfacecd ~/linux-surfacesudo sh setup.sh#5.1.15需要替换自己的版本#uname -a #查看sudo dpkg -i linux-headers-5.1.15.deb linux-image-5.1.15.deb linux-libc-dev-5.1.15.deb</code></pre></li><li><p>给内核签名</p><pre><code class="sh">#如果已经生成 MOK.der, MOK.pem, MOK.priv 文件了，不需要再次生成，密码是123123#导入moksudo mokutil --import MOK.der#重启-&gt;蓝屏MOKManager-&gt;Enroll MOK-&gt;View key-&gt;continue-&gt;输入密码-&gt;continue</code></pre><pre><code class="sh">#以后每次更新内核都执行以下步骤：#检验moksudo mokutil --list-enrolled#签名（修改版本）sudo sbsign --key MOK.priv --cert MOK.pem /boot/vmlinuz-5.1.15-surface-linux-surface --output /boot/vmlinuz-5.1.15-surface-linux-surface.signed#拷贝sudo cp /boot/initrd.img-5.1.15-surface-linux-surface{,.signed}#更新grubsudo update-grub#重启正常，就删除未签名的sudo mv /boot/vmlinuz-[KERNEL-VERSION]-surface-linux-surface{.signed,}sudo mv /boot/initrd.img-[KERNEL-VERSION]-surface-linux-surface{.signed,}sudo update-grub</code></pre></li></ul></li><li><p>安装boot-repair</p><p>设置  secure-boot 允许3rd party</p><pre><code class="sh">sudo add-apt-repository ppa:yannubuntu/boot-repairsudo apt updatesudo apt install -y boot-repair &amp;&amp; boot-repair</code></pre></li><li><p>安装<a href="https://github.com/timobaehr/Surface-Boot-Themes/tree/surface_book" target="_blank" rel="noopener">grub主题</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows下配置openvpn_server</title>
      <link href="/2020/03/06/Windows/windows%E4%B8%8B%E9%85%8D%E7%BD%AEopenvpn_server/"/>
      <url>/2020/03/06/Windows/windows%E4%B8%8B%E9%85%8D%E7%BD%AEopenvpn_server/</url>
      
        <content type="html"><![CDATA[<h2 id="windows下配置openvpn-server"><a href="#windows下配置openvpn-server" class="headerlink" title="windows下配置openvpn server"></a>windows下配置openvpn server</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p><a href="https://openvpn.net/index.php/open-source/downloads.html" target="_blank" rel="noopener">下载</a>（需要翻墙），默认安装</p></li><li><p>复制文件：<code>ca.crt</code>、<code>dh1024.pem</code>、<code>server.crt</code>、<code>server.key</code>到<code>C:\Program Files\OpenVPN\config</code></p></li><li><p>创建文件<code>server.ovpn</code>，然后复制到相同路径，内容如下</p></li></ol><pre><code class="yaml">port 1194             #指定监听的本机端口号proto udp             #指定采用的传输协议，可以选择 tcp 或 udpdev tun               #指定创建的通信隧道类型，可选 tun 或 tapca ca.crt             #指定 CA 证书的文件路径cert server.crt       #指定服务器端的证书文件路径key server.key    #指定服务器端的私钥文件路径dh dh1024.pem         #指定迪菲赫尔曼参数的文件路径server 192.168.137.0 255.255.255.0   #指定虚拟局域网占用的 IP 地址段和子网掩码，此处配置的服务器自身占用 10.0.0.1。ifconfig-pool-persist ipp.txt   #服务器自动给客户端分配 IP 后，客户端下次连接时，仍然采用上次的 IP 地址push &quot;route 0.0.0.0 0.0.0.0&quot;      #表示client通过VPN SERVER上网push &quot;redirect-gateway def1 bypass-dhcp&quot;    #使client全部网络通信通过vpnpush &quot;dhcp-option DNS 202.196.64.1&quot;      #DNS配置，依据实际情况配置push &quot;dhcp-option DNS 202.196.64.2&quot;      #DNS配置，依据实际情况配置#tls-auth ta.key 0     #开启 TLS，使用 ta.key 防御攻击。服务器端的第二个参数值为 0，客户端的为 1。keepalive 10 120      #每 10 秒 ping 一次，连接超时时间设为 120 秒。comp-lzo              #开启 VPN 连接压缩，如果服务器端开启，客户端也必须开启client-to-client      #允许客户端与客户端相连接，默认情况下客户端只能与服务器相连接persist-keypersist-tun           #持久化选项可以尽量避免访问在重启时由于用户权限降低而无法访问的某些资源。status openvpn-status.log    #指定记录 OpenVPN 状态的日志文件路径verb 3                #指定日志文件的记录详细级别，可选 0 - 9，等级越高日志内容越详细</code></pre><h3 id="配置上网"><a href="#配置上网" class="headerlink" title="配置上网"></a>配置上网</h3><p><strong>普通windows</strong></p><p>1、设置server的ip为<code>192.168.137.0</code>（server.ovpn）</p><p>2、打开网络连接，设置Internet连接共享，共享给vpn的虚拟网卡</p><p>（如果不行，就修改注册表开启NAT，<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\IPEnableRouter= 1</code>）</p><p><strong>windows server</strong></p><p>安装IIS，设置NAT规则</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows安装shadowsocks</title>
      <link href="/2020/03/06/Windows/windows%E5%AE%89%E8%A3%85shadowsocks/"/>
      <url>/2020/03/06/Windows/windows%E5%AE%89%E8%A3%85shadowsocks/</url>
      
        <content type="html"><![CDATA[<h3 id="windows安装shadowsocks"><a href="#windows安装shadowsocks" class="headerlink" title="windows安装shadowsocks"></a>windows安装shadowsocks</h3><h4 id="1安装nodejs"><a href="#1安装nodejs" class="headerlink" title="1安装nodejs"></a>1安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs</a></h4><h4 id="2安装shadowssocks"><a href="#2安装shadowssocks" class="headerlink" title="2安装shadowssocks"></a>2安装shadowssocks</h4><pre><code>npm install -g shadowsocks</code></pre><h4 id="3修改配置"><a href="#3修改配置" class="headerlink" title="3修改配置"></a>3修改配置</h4><p>打开路径<code>C:\Users\liuly\AppData\Roaming\npm\node_modules\shadowsocks</code>，修改文件<code>config.json</code></p><pre><code class="json">{    &quot;server&quot;:&quot;::&quot;,    &quot;server_port&quot;:8388,    &quot;local_address&quot;:&quot;127.0.0.1&quot;,    &quot;local_port&quot;:1080,    &quot;password&quot;:&quot;abc12345&quot;,    &quot;timeout&quot;:600,    &quot;method&quot;:&quot;aes-256-cfb&quot;}</code></pre><h4 id="4运行"><a href="#4运行" class="headerlink" title="4运行"></a>4运行</h4><p>双击<code>C:\Users\liuly\AppData\Roaming\npm\ssserver.cmd</code></p><p>获知打开node.js，输入<code>ssserver</code></p><h4 id="5自启动"><a href="#5自启动" class="headerlink" title="5自启动"></a>5自启动</h4><pre><code>@echo offstart C:\Windows\System32\cmd.exe /k &quot;C:\ProgramFiles\nodejs\nodevars.bat&quot;start C:\Windows\System32\cmd.exe /k&quot;ssserver&quot;</code></pre><p>放入<code>C:\Users\liuly\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\ss.bat</code></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习</title>
      <link href="/2020/03/06/Windows/C++%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/03/06/Windows/C++%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="C-学习"><a href="#C-学习" class="headerlink" title="C++学习"></a>C++学习</h1><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><pre><code class="c++">#include&lt;iostream&gt;using namespace std;int main(int argc, char * argv[]){    for (int i = 0; i &lt; argc; i++)    {        cout &lt;&lt; argv[i] &lt;&lt; endl;    }}//输出为所有参数//包括程序名本身（完整路径）//argc不包括程序名本身</code></pre><p>示例：</p><pre><code class="c++">int nargs = argc/2 - 1;///参数的数量（参数成对出现：参数名和参数值）for( int i = 0; i &lt; nargs; i++ ){    int j = 2*i + 2;    if( string(argv[j]) == &quot;-o&quot; )        frame_offset = stoi(argv[j+1]);    else if( string(argv[j]) == &quot;-n&quot; )        frame_number = stoi(argv[j+1]);    else if( string(argv[j]) == &quot;-s&quot; )        frame_step = stoi(argv[j+1]);    else if (string(argv[j]) == &quot;-c&quot;)        config_file = string(argv[j+1]);    else        return false;}</code></pre><h3 id="程序计时"><a href="#程序计时" class="headerlink" title="程序计时"></a>程序计时</h3><pre><code class="c++">#include&lt;iostream&gt;#include&lt;chrono&gt;using namespace std;int main(int argc, char **argv){    std::chrono::steady_clock::time_point t1 = std::chrono::steady_clock::now();//开始时刻    while (true)    {        std::chrono::steady_clock::time_point t2 = std::chrono::steady_clock::now();//当前时刻        double t = std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt; &gt;(t2 - t1).count();//开始到现在的时间        cout &lt;&lt; t &lt;&lt; endl;    }}</code></pre><p>写个class方便使用</p><pre><code class="c++">#include&lt;iostream&gt;#include &lt;chrono&gt;#include&lt;Windows.h&gt;///只是为了Sleepusing namespace std;//声明class Timer {public:    static constexpr double SECONDS = 1e-9;///秒    static constexpr double MILLISECONDS = 1e-6;//毫秒    static constexpr double NANOSECONDS = 1.0;//纳秒    Timer(double scale = MILLISECONDS);//默认的时间单位是毫秒    virtual ~Timer();    void start();    double stop();private:    std::chrono::high_resolution_clock::time_point start_t;///开始计时的时间    bool started;    double scale;};//调用int main(int argc, char * argv[]){    Timer timer1(1e-6);    //或者 Timer timer1(1e-6);    timer1.start();    Sleep(1000);    double time = timer1.stop();    cout &lt;&lt;&quot;持续时间：&quot;&lt;&lt; time&lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;}//定义Timer::Timer(double scale) : started(false), scale(scale) { }Timer::~Timer() { }void Timer::start() {    started = true;    start_t = std::chrono::high_resolution_clock::now();}double Timer::stop() {    std::chrono::high_resolution_clock::time_point end_t = std::chrono::high_resolution_clock::now();    if (!started)        throw std::logic_error(&quot;[Timer] Stop called without previous start&quot;);    started = false;    std::chrono::duration&lt;double, std::nano&gt; elapsed_ns = end_t - start_t;    return elapsed_ns.count()*scale;}</code></pre><h3 id="vector和iterator"><a href="#vector和iterator" class="headerlink" title="vector和iterator"></a>vector和iterator</h3><pre><code class="c++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){    vector&lt;int&gt; v;  //v是存放int类型变量的可变长数组，开始时没有元素    for (int n = 0; n &lt; 5; ++n)        v.push_back(n);  //push_back成员函数在vector容器尾部添加一个元素    //正向迭代器遍历容器    vector&lt;int&gt;::iterator i;    for (i = v.begin(); i != v.end(); ++i) {  //用迭代器遍历容器        cout &lt;&lt; *i &lt;&lt; &quot; &quot;;  //*i 就是迭代器i指向的元素        *i *= 2;  //每个元素变为原来的2倍    }    cout &lt;&lt; endl;    //用反向迭代器遍历容器    for (vector&lt;int&gt;::reverse_iterator j = v.rbegin(); j != v.rend(); ++j)        cout &lt;&lt; *j &lt;&lt; &quot; &quot;;    cin.ignore();    return 0;}</code></pre><p>输出为：</p><pre><code>0 1 2 3 48 6 4 2 0</code></pre><h3 id="iterator-list的偏移"><a href="#iterator-list的偏移" class="headerlink" title="iterator/list的偏移"></a>iterator/list的偏移</h3><pre><code class="c++">#include &lt;iostream&gt;     // std::cout#include &lt;iterator&gt;     // std::advance#include &lt;list&gt;         // std::listusing namespace std;int main() {    std::list&lt;int&gt; mylist;    for (int i = 0; i &lt; 10; i++) mylist.push_back(i);    std::list&lt;int&gt;::iterator it = mylist.begin();//第一个元素标号为0    std::advance(it, 5);//向后5个偏移    cout &lt;&lt; &quot;mylist第6个元素是: &quot; &lt;&lt; *it &lt;&lt; endl;    std::advance(it, -1);//向前1个偏移    cout &lt;&lt; &quot;mylist第5个元素是: &quot; &lt;&lt; *it &lt;&lt; endl;    return 0;}</code></pre><p>输出为：</p><pre><code>mylist第6个元素是: 5mylist第5个元素是: 4</code></pre><h3 id="迭代器删除元素"><a href="#迭代器删除元素" class="headerlink" title="迭代器删除元素"></a>迭代器删除元素</h3><p><strong>关联容器</strong></p><p>对于关联容器（如map，set，multimap，multiset），删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前的iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入，删除一个结点不会对其他结点造成影响。</p><pre><code class="c++">set&lt;int&gt; valset = { 1,2,3,4,5,6 };  set&lt;int&gt;::iterator iter;  for (iter = valset.begin(); iter != valset.end(); )  {       if (3 == *iter)            valset.erase(iter++);       else            iter++;  }</code></pre><p><strong>顺序容器</strong></p><p>对于序列式容器（如vector，deque，list等），删除当前的iterator会使后面所有元素的iterator都失效。这是因为vector，deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。不过erase方法可以返回下一个有效的iterator。</p><pre><code class="c++">vector&lt;int&gt; val = { 1,2,3,4,5,6 };  vector&lt;int&gt;::iterator iter;  for (iter = val.begin(); iter != val.end(); )  {       if (3 == *iter)            iter = val.erase(iter);//返回下一个有效的迭代器，无需+1       else            iter++;  }</code></pre><h3 id="nth-element排序"><a href="#nth-element排序" class="headerlink" title="nth_element排序"></a>nth_element排序</h3><p>nth_element(first,nth,last);在first到last的范围内（各种容器），确保第nth的数是正好位于nth的位置，默认升序排列，当nth元素确定拍在nth的位置后，后续就不排了（但通常结果是顺序都对）。也可以加第四个参数：bool型的比较函数</p><p><strong>数组排序</strong></p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int iarray[] = { 5,6,11,19,34,55,77,15,89,7,2,1,3,52 };    int len = sizeof(iarray) / sizeof(int);    cout &lt;&lt; &quot;原数组：&quot; &lt;&lt; endl;    for (size_t i = 0; i &lt; len; i++)        cout &lt;&lt; iarray[i] &lt;&lt; &quot; &quot;;    nth_element(iarray, iarray + 2, iarray + len);    cout &lt;&lt; endl &lt;&lt; &quot;升序排列后：&quot; &lt;&lt; endl;    for (size_t i = 0; i &lt; len; i++)        cout &lt;&lt; iarray[i] &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl &lt;&lt; &quot;第6个元素：&quot; &lt;&lt; endl &lt;&lt; iarray[6] &lt;&lt; endl;    return 0;}</code></pre><p>输出：</p><pre><code>原数组：5 6 11 19 34 55 77 15 89 7 2 1 3 52升序排列后：1 2 3 5 6 7 11 15 19 34 52 55 77 89第6个元素：11</code></pre><p><strong>vector排序</strong></p><pre><code class="c++">//vector排序#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(){    vector&lt;int&gt; a(9);    cout &lt;&lt; &quot;生成的随机数组：&quot; &lt;&lt; endl;    for (int i = 0; i &lt; 9; i++)        a[i] = i + 1;    //对一个元素序列进行(伪)随机的重新排序    random_shuffle(a.begin(), a.end());    for (int i = 0; i &lt; 9; i++)        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;(由大到小)第5个数：&quot;;    nth_element(a.begin(), a.begin() + 4, a.end());    cout &lt;&lt; *(a.begin() + 4) &lt;&lt; endl;    cout &lt;&lt; &quot;排完之后的顺序：&quot; &lt;&lt; endl;    for (int i = 0; i &lt; 9; i++)        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    return 0;}</code></pre><p>输出：</p><pre><code>生成的随机数组：9 2 7 3 1 6 8 4 5(由大到小)第5个数：5排完之后的顺序：1 2 3 4 5 6 7 8 9</code></pre><h3 id="遍历文件（windows）"><a href="#遍历文件（windows）" class="headerlink" title="遍历文件（windows）"></a>遍历文件（windows）</h3><pre><code class="c++">#include &lt;stdio.h&gt;#include &lt;io.h&gt;#include &lt;windows.h&gt;//windows x86 onlyconst char *to_search = &quot;D:\\SLAM\\*&quot;;        //欲查找的文件，支持通配符(\\前一个\表示转义字符)，这是正则表达式int main(){    long handle;                               //用于查找的句柄    struct _finddata_t fileinfo;               //文件信息的结构体    //第1次查找    handle = _findfirst(to_search, &amp;fileinfo);     if (-1 == handle) return -1;    printf(&quot;%s\n&quot;, fileinfo.name);             //打印出找到的文件的文件名    //第2次直到后面的全部文件    while (!_findnext(handle, &amp;fileinfo))    {        printf(&quot;%s\n&quot;, fileinfo.name);    }    //关闭句柄    _findclose(handle);    system(&quot;pause&quot;);    return 0;}</code></pre><h3 id="OpenCV遍历图片"><a href="#OpenCV遍历图片" class="headerlink" title="OpenCV遍历图片"></a>OpenCV遍历图片</h3><pre><code class="c++">#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;fstream&gt;using namespace cv;using namespace std;int main(){    std::string img_dir = &quot;D:\\SLAM\\dataset\\EuRoC\\MH_01_easy\\mav0\\cam0\\data\\*.png&quot;;    std::vector&lt;cv::String&gt; image_files;    cv::glob(img_dir, image_files);    if (image_files.size() == 0)    {        std::cout &lt;&lt; &quot;No image files&quot; &lt;&lt; std::endl;        system(&quot;pause&quot;);        return 0;    }    for (unsigned int frame = 0; frame &lt; image_files.size(); ++frame)    {//image_file.size()代表文件中总共的图片个数        Mat image = cv::imread(image_files[frame]);        imshow(&quot;1&quot;, image);        waitKey(1);    }}</code></pre><h3 id="class、vector、iterator遍历文件"><a href="#class、vector、iterator遍历文件" class="headerlink" title="class、vector、iterator遍历文件"></a>class、vector、iterator遍历文件</h3><pre><code class="c++">#include &lt;iostream&gt;#include &lt;io.h&gt;#include &lt;windows.h&gt;#include &lt;string&gt;#include &lt;list&gt;//list同vector同理#include &lt;vector&gt;using namespace std;class GetName{    char *path;    long handle;                               //用于查找的句柄    struct _finddata_t fileinfo;               //文件信息的结构体public:    GetName(char *to_search);    vector&lt;string&gt; NameToVector();};GetName::GetName(char *to_search):path(to_search){}vector&lt;string&gt; GetName::NameToVector(){    vector&lt;string&gt; NameVector;    //第1次查找    handle = _findfirst(path, &amp;fileinfo);    //if (-1 == handle) return;    NameVector.push_back(fileinfo.name);    //第2次直到后面的全部文件    while (!_findnext(handle, &amp;fileinfo))    {        NameVector.push_back(fileinfo.name);    }    //关闭句柄    _findclose(handle);    return NameVector;}int main(){    vector&lt;string&gt; NameVector;    char *to_search = &quot;D:\\SLAM\\*&quot;;        //前一个\表示转义字符    GetName GN(to_search);    NameVector = GN.NameToVector();    vector&lt;string&gt;::iterator i;    for (i = NameVector.begin();i != NameVector.end();i++)    {        cout &lt;&lt; *i &lt;&lt; endl;    }    system(&quot;pause&quot;);    return 0;}</code></pre><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p><a href="https://blog.csdn.net/ktigerhero3/article/details/78249266/" target="_blank" rel="noopener">https://blog.csdn.net/ktigerhero3/article/details/78249266/</a></p><h4 id="建立多个线程"><a href="#建立多个线程" class="headerlink" title="建立多个线程"></a>建立多个线程</h4><pre><code class="c++">#include &lt;Windows.h&gt;#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;void sayHello(){    while (1)    {        Sleep(1000);//单位毫秒        cout &lt;&lt; endl &lt;&lt; &quot;hello&quot; &lt;&lt; endl;    }}void sayWorld(){    while (1)    {        Sleep(1000);        cout &lt;&lt; endl &lt;&lt; &quot;world&quot; &lt;&lt; endl;    }}int main(){    thread threadHello(&amp;sayHello);    thread threadWorld(&amp;sayWorld);    threadHello.join();    threadWorld.join();    return 0;}</code></pre><h4 id="线程加锁mutex"><a href="#线程加锁mutex" class="headerlink" title="线程加锁mutex"></a>线程加锁mutex</h4><pre><code class="c++">#include &lt;Windows.h&gt;#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;mutex mymutex;void sayHello(){    int k = 0;    unique_lock&lt;mutex&gt; lock(mymutex);    while (k &lt; 2)    {        k++;        cout &lt;&lt; endl &lt;&lt; &quot;hello&quot; &lt;&lt; endl;        Sleep(2000);    }}void sayWorld(){    unique_lock&lt;mutex&gt; lock(mymutex);    while (1)    {        cout &lt;&lt; endl &lt;&lt; &quot;world&quot; &lt;&lt; endl;        Sleep(1000);    }}int main(){    thread threadHello(&amp;sayHello);    thread threadWorld(&amp;sayWorld);    threadHello.join();    threadWorld.join();    return 0;}</code></pre><p><strong>程序运行说明</strong></p><p>程序运行步骤是这样的：<br>首先同时运行threadHello线程和threadWorld线程 ；先进入threadHello线程的sayHello()函数，这个时候加了mymutex锁，另外一个threadWorld线程进入后发现mymutex锁没有释放，只能等待；当过去两个循环（每个循环2秒后）threadHello线程结束，unique_lock lock(mymutex)的生命周期结束，mymutex锁释放，执行threadWorld线程，此时开始一直say world。</p><p><strong>使用说明</strong></p><p>unique_lock中的unique表示独占所有权。<br>unique_lock独占的是mutex对象，就是对mutex锁的独占</p><p>用法：<br>（1）新建一个unique_lock 对象<br>（2）给对象传入一个std::mutex 对象作为参数; </p><pre><code class="c++">std::mutex  mymutex; unique_lock lock(mymutex);</code></pre><p>由于unique_lock lock(mymutex)的存在，这个函数结束后会自动解锁（也可以手动unlock）。 加锁的结果是使当前线程运行时别的线程等待不动。注意定义mutex的位置。</p><h3 id="隐藏控制台窗口"><a href="#隐藏控制台窗口" class="headerlink" title="隐藏控制台窗口"></a>隐藏控制台窗口</h3><p>include后面加上：</p><pre><code class="c++">#pragma comment( linker, &quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot; )</code></pre><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>普通函数与回调函数主要是在调用方式上有区别：</p><p>1、对<strong>普通函数</strong>的调用：调用程序发出对普通函数的调用后，程序执行立即转向被调用函数执行，直到被调用函数执行完毕后，再返回调用程序继续执行。从发出调用的程序的角度看，这个过程为“调用–&gt;等待被调用函数执行完毕–&gt;继续执行”。</p><p>2、对<strong>回调函数</strong>调用：调用程序发出对回调函数的调用后，<code>不等回调函数执行完毕</code>，立即返回并继续执行。这样，调用程序执和被调用函数同时在执行。当被调函数执行完毕后，被调函数会反过来调用某个事先指定的函数，以通知调用程序：函数调用结束。这个过程称为回调（Callback），这正是回调函数名称的由来。</p><pre><code class="c++">#include &lt;stdio.h&gt;typedef int(*callback)(int, int);//函数指针：输入类型和输出类型int fun1(int a, int b, callback p)//fun2函数的指针作为参数{    return (*p)(a, b);}int fun2(int a, int b)//回调函数{    return a + b;}int main(){    int res = fun1(4, 2, fun2);    printf(&quot;%d\n&quot;, res);    return 0;}</code></pre><p> 它们与普通函数并没有任何区别, 只是与其它函数使用的方式有些许差别。</p><p> 回调函数的好处是，通过修改传入fun1的参数（回调函数的指针），可以让fun1内调用不同的执行函数，如给(*p)赋值fun2、fun3的指针</p><h3 id="函数参数传递的三种方式-x-x-amp-x"><a href="#函数参数传递的三种方式-x-x-amp-x" class="headerlink" title="函数参数传递的三种方式(x,*x,&amp;x)"></a>函数参数传递的三种方式(x,*x,&amp;x)</h3><p>函数实现两个将两个数交换位置</p><p><strong>第一种</strong></p><pre><code class="c++">#include&lt;stdio.h&gt;void myswap(int x, int y){    int t;    t = x;    x = y;    y = t;}int main(){    int a = 1, b = 2;    printf(&quot;交换前a=%d,b=%d\n&quot;, a, b);    myswap(a, b);  //作为对比，直接交换两个整数，显然不行    printf(&quot;交换后a=%d,b=%d\n&quot;, a, b);    return 0;}</code></pre><p>结果</p><pre><code>交换前a=1,b=2交换后a=1,b=2</code></pre><p><strong>第二种</strong></p><pre><code class="c++">#include&lt;stdio.h&gt;void myswap(int *p1, int *p2){    int  t;    t = *p1;    *p1 = *p2;    *p2 = t;}int main(){    int a = 1, b = 2;    printf(&quot;交换前a=%d,b=%d\n&quot;, a, b);    myswap(&amp;a, &amp;b);  //交换两个整数的地址    printf(&quot;交换后a=%d,b=%d\n&quot;, a, b);    return 0;}</code></pre><p>结果</p><pre><code>交换前a=1,b=2交换后a=2,b=1</code></pre><p><strong>第三种</strong></p><pre><code class="c++">#include&lt;stdio.h&gt;void myswap(int &amp;x, int &amp;y) //这里的形参为引用类型，引用与实参进行绑定，作为实参的别名{                           //所以，使用引用类型，传入实参后，函数对引用的操作，    int t;                  //就是对实参的操作，所以实参会发生变化                    t = x;    x = y;    y = t;}int main(){    int a = 1, b = 2;    printf(&quot;交换前a=%d,b=%d\n&quot;, a, b);    myswap(a, b);  //交换两个整数的地址    printf(&quot;交换后a=%d,b=%d\n&quot;, a, b);    return 0;}</code></pre><p>结果</p><pre><code>交换前a=1,b=2交换后a=2,b=1</code></pre><h3 id="const的使用"><a href="#const的使用" class="headerlink" title="const的使用"></a>const的使用</h3><h4 id="使用const修饰变量"><a href="#使用const修饰变量" class="headerlink" title="使用const修饰变量"></a>使用const修饰变量</h4><p> 有时候我们需要定义这样一种变量，它的值不能被更改。为了满足这一要求，可以通过关键字const对变量的类型加以限定。 </p><p><strong>const 修饰普通的变量</strong></p><p> 用const修饰变量的语义是要求编译器去阻止所有对该变量的赋值行为。因此，必须在const变量初始化时就提供给它初值： （ 这个初值可以是编译时即确定的值，也可以是运行期才确定的值 ）</p><pre><code class="c++">const int bufSize=512;</code></pre><p> 这里将bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误。</p><p><strong>注意</strong>:const对象必须初始化，因为const对象一旦创建后其值就不能再改变 。</p><p>如：</p><pre><code class="c++">const int j=42; //正确，编译时初始化const int i=get_size();//正确，运行时初始化const int k;  //错误，未初始化int i=42;const int ci=i;//正确，</code></pre><p><strong>const的引用</strong></p><p> 对<strong>常量的引用(reference to const)</strong>，将引用绑定到const对象上。与普通引用不同的是： </p><p>(1) 对常量的引用不能用于修改它所绑定的对象。</p><pre><code class="c++">int i=42;int &amp;r1=i;const int &amp;r2=i;//r2也绑定了对象i,但不允许通过r2修改i的值r1=0;           //正确r2=0;           //错误，r2是一个常量引用</code></pre><p>(2) 不能将非常量引用指向一个常量对象值。 </p><pre><code class="c++">const int ci=1024;int &amp;r2=ci;         //错误，试图让一个非常量引用指向一个常量对象</code></pre><h4 id="const与指针"><a href="#const与指针" class="headerlink" title="const与指针"></a>const与指针</h4><p> const修饰指针变量有3种情况：</p><ol><li><p>指向常量的指针(pointer to const)不能用于改变其所指对象的值。</p></li><li><p>常量指针(const pointer)，指针本身定义为常量。</p></li><li><p>const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。 </p></li></ol><p><strong>（1）指向常量的指针(pointer to const)，不能通过该指针改变其所指对象的值。</strong> </p><pre><code class="c++">const double pi=3.14;double *ptr=&amp;pi;        //错误：ptr是一个普通的指针。const double *cptr=&amp;pi; //正确：*cptr=42;               //错误：不能给*cptr赋值</code></pre><p> 指向常量的指针却可以指向一个非常量对象。 </p><pre><code class="c++">double val=3.14;*cptr=&amp;val;         //正确，但不能通过cptr改变val的值。</code></pre><p> <strong>（2）常量指针(const pointer),指针本身定义为常量。</strong><br>常量指针必须被初始化，一旦初始化完成，它的值(也就是存放在指针中的那个地址)将不能被改变。<br>把*放在const关键字之前用以说明指针是一个常量。 </p><pre><code class="c++">int errorNumb=0;int *const curErr = &amp;errorNumb;//正确：curErr将一直指向errorNumb</code></pre><p> <strong>（3）将上述两种结合，指向常量对象的常量指针</strong> </p><pre><code class="c++">int a=10;const int * const p=&amp;a;</code></pre><p> 上面的例子中，不能通过指针p修改其所指对象的值(变量a),并且指针p必须被初始化，一旦初始化后，它的值将不能被改变(也就是指针p只能指向a)。 </p><h3 id="函数前后加const的区别"><a href="#函数前后加const的区别" class="headerlink" title="函数前后加const的区别"></a>函数前后加const的区别</h3><p> <strong>函数前加const</strong>：普通函数或成员函数（非静态成员函数）前均可加const修饰，表示函数的返回值为const，不可修改。格式为： </p><pre><code class="c++">const returnType functionName(param list)</code></pre><p> <strong>函数后加const</strong>：只有类的非静态成员函数后可以加const修饰，表示该类的this指针为const类型，不能改变类的成员变量的值，即成员变量为read only，任何改变成员变量的行为均为非法。此类型的函数可称为只读成员函数，格式为： </p><pre><code class="c++">returnType functionName(param list) const</code></pre><p><strong>const类型的对象只能调用后const成员函数</strong></p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;class A{private:    int m_a;public:    A():m_a(0){}    int getA() const    {        return m_a;    }    int GetA() //非const成员函数，若在后面加上const修饰则编译通过    {        return m_a;    }};int main(){    const A a2;//const对象    int t;    t = a2.getA();    t = a2.GetA();//const类型的对象只能调用后const成员函数    return 0;}</code></pre><h3 id="constexpr常量表达式"><a href="#constexpr常量表达式" class="headerlink" title="constexpr常量表达式"></a>constexpr常量表达式</h3><p> constexpr是C++11中新增的关键字，其语义是“常量表达式”，也就是在编译期可求值的表达式。最基础的常量表达式就是字面值或全局变量/函数的地址或sizeof等关键字返回的结果，而其它常量表达式都是由基础表达式通过各种确定的运算得到的 。</p><p> constexpr所修饰的变量一定是编译期可求值的，所修饰的函数在其所有参数都是constexpr时，一定会返回constexpr </p><pre><code class="c++">constexpr int Inc(int i){    return i + 1;}constexpr int a = Inc(1); // okconstexpr int b = Inc(cin.get()); // !errorconstexpr int c = a * 2 + 1; // ok</code></pre><h3 id="容器的front-和pop-front"><a href="#容器的front-和pop-front" class="headerlink" title="容器的front()和pop_front()"></a>容器的front()和pop_front()</h3><pre><code class="c++">std::list&lt;std::string&gt; images;images.push_back(&quot;123.jpg&quot;);string img= images.front();//获取容器的第一的元素images.pop_front();//删除容器的第一个元素</code></pre><h3 id="template-lt-tymename-T-gt"><a href="#template-lt-tymename-T-gt" class="headerlink" title="template&lt;tymename T&gt;"></a>template&lt;tymename T&gt;</h3><p>其实就是模板，函数的类型是未知的，当你把它应用于不同的类型时，不会造成类型冲突。</p><p>比如求最小值，要对int，float，double类型的数都适用，那么你就要写三个函数：</p><pre><code class="c++">int sum(int, int);float sum(float, float);double sum(double, double);</code></pre><p> 但是有了<code>templae&lt;typename T&gt;</code>你就只需要写一个函数。 </p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;template &lt;typename T&gt;T mmax(T a,T b){    return a&gt;b?a:b;}int main(){    int  a,b;    cin&gt;&gt;a&gt;&gt;b;    cout&lt;&lt;mmax(a,b)&lt;&lt;endl;    float c,d;    cin&gt;&gt;c&gt;&gt;d;    cout&lt;&lt;mmax(c,d)&lt;&lt;endl;    double f,g;    cin&gt;&gt;f&gt;&gt;g;    cout&lt;&lt;mmax(f,g)&lt;&lt;endl;}</code></pre><h3 id="std-pair"><a href="#std-pair" class="headerlink" title="std::pair"></a>std::pair</h3><p> pair是将2个数据组合成一个数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。 pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量 。</p><pre><code class="c++">pair&lt;int, double&gt; p1;  //声明p1 = make_pair(1, 1.2);//赋值pair&lt;int, double&gt; p2(1, 2.4);  //声明并赋初值pair&lt;int, double&gt; p3(p2);  //声明并拷贝初值//访问元素p1.first = 1;p1.second = 2.5;cout &lt;&lt; p1.first &lt;&lt; &#39; &#39; &lt;&lt; p1.second &lt;&lt; endl;</code></pre><h3 id="关联容器set"><a href="#关联容器set" class="headerlink" title="关联容器set"></a>关联容器set</h3><p> <strong>顺序容器</strong>包括vector、deque、list、forward_list、array、string，所有顺序容器都提供了快速顺序访问元素的能力。 </p><p> <strong>关联容器</strong>包括set、map ，关联容器没有顺序，通过关键字查找元素保存和访问（类似struct）</p><p> 关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的 。</p><p> 关联容器支持高效的关键字查找和访问。两个主要的关联容器(associative container)类型是map和set。<strong>map中的元素是一些关键字—-值(key–value)对</strong>：关键字起到索引的作用，值则表示与索引相关联的数据。<strong>set中每个元素只包含一个关键字</strong>：set支持高效的关键字查询操作—-检查一个给定关键字是否在set中 。</p><p> set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的 。</p><p> 标准库提供set关联容器分为： </p><ol><li><p>按关键字有序保存元素：set(关键字即值，即只保存关键字的容器)；multiset(关键字可重复出现的set) 。</p></li><li><p>无序集合：unordered_set(用哈希函数组织的set)；unordered_multiset(哈希组织的set，关键字可以重复出现) 。</p><p>在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序。set中元素的值不能直接被改变。set内部采用的是一种非常高效的平衡检索二叉树：红黑树，也称为RB树(Red-Black Tree)。RB树的统计性能要好于一般平衡二叉树。 </p><p><strong>set具备的两个特点</strong>：</p></li><li><p>set中的元素都是排序好的 </p></li><li><p>set中的元素都是唯一的，没有重复的 </p></li></ol><p>set的使用</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;set&gt;int main (){  int myints[] = {75,23,65,42,13};  std::set&lt;int&gt; myset (myints, myints+5);//初始化  std::cout &lt;&lt; &quot;myset contains:&quot;;  for (std::set&lt;int&gt;::iterator it=myset.begin(); it!=myset.end(); ++it)    std::cout &lt;&lt; &#39; &#39; &lt;&lt; *it;  std::cout &lt;&lt; &#39;\n&#39;;  return 0;}//输出：//myset contains: 13 23 42 65 75</code></pre><p>set支持的操作</p><pre><code class="c++">begin();            // 返回指向第一个元素的迭代器end();              // 返回指向最后一个元素的迭代器clear();            // 清除所有元素count();            // 返回某个值元素的个数empty();            // 如果集合为空，返回trueequal_range();      //返回集合中与给定值相等的上下限的两个迭代器erase();            //删除集合中的元素find();                //返回一个指向被查找到元素的迭代器get_allocator();    //返回集合的分配器insert();            //在集合中插入元素lower_bound();        //返回指向大于（或等于）某值的第一个元素的迭代器key_comp();            //返回一个用于元素间值比较的函数max_size();            //返回集合能容纳的元素的最大限值rbegin();            //返回指向集合中最后一个元素的反向迭代器rend();                //返回指向集合中第一个元素的反向迭代器size();                //集合中元素的数目swap();                //交换两个集合变量upper_bound();        //返回大于某个值元素的迭代器value_comp();        //返回一个用于比较元素间的值的函数</code></pre><h3 id="异步编程std-async和std-future"><a href="#异步编程std-async和std-future" class="headerlink" title="异步编程std::async和std::future"></a>异步编程std::async和std::future</h3><p> std::asyanc是std::future的高级封装， 一般我们不会直接使用std::futrue，而是使用对std::future的高级封装std::async 。<a href="https://www.cnblogs.com/moodlxs/p/10111601.html" target="_blank" rel="noopener">链接</a></p><h4 id="std-async基本用法"><a href="#std-async基本用法" class="headerlink" title="std::async基本用法"></a>std::async基本用法</h4><p>std::future可以从异步任务中获取结果，一般与std::async配合使用，std::async用于创建异步任务，实际上就是创建一个线程执行相应任务。</p><p>std::async就是异步编程的高级封装，封装了std::future的操作，基本上可以代替std::thread 的所有事情。</p><p>std::async的操作，其实相当于封装了std::promise、std::packaged_task加上std::thread。</p><pre><code class="c++">#include &lt;future&gt;#include &lt;iostream&gt;bool is_prime(int x)//判断是不是素数{    for (int i = 2; i &lt; x; i++)    {        if (x % i == 0)            return false;    }    return true;}int main(){    std::future&lt;bool&gt; fut = std::async(is_prime, 700020007);    //std::async首先创建线程执行is_prime(700020007)，创建后立即执行    std::cout &lt;&lt; &quot;please wait&quot;;    std::chrono::milliseconds span(100);    while (fut.wait_for(span) != std::future_status::ready)//等待线程执行完成        std::cout &lt;&lt; &quot;.&quot;;    std::cout &lt;&lt; std::endl;    //fut.wait_for(span)也可写作fut.wait_for(std::chrono::milliseconds(100))    bool ret = fut.get();//获取执行结果    std::cout &lt;&lt; &quot;final result: &quot; &lt;&lt; ret &lt;&lt; std::endl;    return 0;}//输出：//please wait................//final result: 1</code></pre><p> 上面先说了通用的做法，然后我们了解一下std::future、std::promise、std::packaged_task </p><h4 id="std-future说明"><a href="#std-future说明" class="headerlink" title="std::future说明"></a>std::future说明</h4><p> future是std::async、std::promise、std::packaged_task的底层对象，用来传递其他线程中操作的数据结果。 </p><h4 id="std-promise用法"><a href="#std-promise用法" class="headerlink" title="std::promise用法"></a>std::promise用法</h4><p> std::promise的作用就是提供一个不同线程之间的数据同步机制，它可以存储一个某种类型的值，并将其传递给对应的future， 即使这个future不在同一个线程中也可以安全的访问到这个值 。</p><pre><code class="c++">// promise example#include &lt;iostream&gt;       // std::cout#include &lt;functional&gt;     // std::ref#include &lt;thread&gt;         // std::thread#include &lt;future&gt;         // std::promise, std::futurevoid print_int(std::future&lt;int&gt;&amp; fut) {    int x = fut.get();    std::cout &lt;&lt; &quot;value: &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;;}int main(){    std::promise&lt;int&gt; prom;                      // 创建promise用来（在不同线程间）同步数据    std::future&lt;int&gt; fut = prom.get_future();    // promise的future    std::thread th1(print_int, std::ref(fut));   // 把future发送到新的线程    prom.set_value(10);                          // 给promise输入数据    th1.join();                                  // 启动线程    // 线程th1的函数通过fut可以get到prom中的参数    return 0;}</code></pre><h4 id="std-packaged-task用法"><a href="#std-packaged-task用法" class="headerlink" title="std::packaged_task用法"></a>std::packaged_task用法</h4><p> std::packaged_task的作用就是提供一个不同线程之间的数据同步机制，它可以存储一个函数操作，并将其返回值传递给对应的future， 而这个future在另外一个线程中也可以安全的访问到这个值。 </p><pre><code class="c++">// packaged_task example#include &lt;iostream&gt;     // std::cout#include &lt;future&gt;       // std::packaged_task, std::future#include &lt;chrono&gt;       // std::chrono::seconds#include &lt;thread&gt;       // std::thread, std::this_thread::sleep_for// 为每个值倒计时一秒：int countdown(int from, int to) {    for (int i = from; i != to; --i) {        std::cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;        std::this_thread::sleep_for(std::chrono::seconds(1));    }    std::cout &lt;&lt; &quot;Lift off!\n&quot;;    return from - to;}int main(){    std::packaged_task&lt;int(int, int)&gt; tsk(countdown);   // 创建packaged_task    std::future&lt;int&gt; ret = tsk.get_future();            // 获取它的future    std::thread th(std::move(tsk), 10, 0);   // 生成线程以从10倒计时到0    // ...    int value = ret.get();                  // wait for the task to finish and get result    std::cout &lt;&lt; &quot;The countdown lasted for &quot; &lt;&lt; value &lt;&lt; &quot; seconds.\n&quot;;    th.join();    return 0;}</code></pre><h3 id="左值，右值，左值引用，右值引用"><a href="#左值，右值，左值引用，右值引用" class="headerlink" title="左值，右值，左值引用，右值引用"></a>左值，右值，左值引用，右值引用</h3><p><a href="https://blog.csdn.net/xiaolewennofollow/article/details/52559306" target="_blank" rel="noopener">链接</a></p><h4 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h4><p><strong>左值</strong>，就是有名字的变量（对象），可以被赋值，可以在多条语句中使用。</p><p><strong>右值</strong>，就是临时变量（对象），没有名字，只能在一条语句中出现，不能被赋值 。</p><h4 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h4><p> 左值引用的声明符号为”&amp;”， 为了和左值区分，右值引用的声明符号为”&amp;&amp;”。 </p><pre><code class="c++">#include &lt;iostream&gt;void process_value(int&amp; i){    std::cout &lt;&lt; &quot;左值引用: &quot; &lt;&lt; i &lt;&lt; std::endl;}void process_value(int&amp;&amp; i){    std::cout &lt;&lt; &quot;右值引用: &quot; &lt;&lt; i &lt;&lt; std::endl;}int main(){    int a = 0;    process_value(a);    process_value(1);    return 0;}// 结果为：//左值引用: 0//右值引用: 1</code></pre><p> 被声明为右值引用的，它本身被看作左值或右值都可以。区分的标准是：如果它有一个名字，那么它是一个左值。否则，它是一个右值。 </p><pre><code class="c++">int main(){    int a = 0;    process_value(a);    int&amp;&amp; b = 1;    process_value(b);    return 0;}// 结果为：//左值引用: 0//左值引用: 1</code></pre><p>b是一个右值引用，指向一个右值1，但是由于b是有名字的，所以b在这里被视为一个左值，所以在函数重载的时候选择为第一个函数 。</p><h4 id="右值引用的意义"><a href="#右值引用的意义" class="headerlink" title="右值引用的意义"></a>右值引用的意义</h4><p> 直观<strong>意义</strong>：为临时变量续命，也就是为右值续命，因为右值在表达式结束后就消亡了，如果想继续使用右值，那就会动用昂贵的拷贝构造函数。 </p><p> <strong>右值引用是用来支持转移语义的</strong>。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。 </p><p> <strong>转移语义</strong>是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。通过转移语义，临时对象中的资源能够转移其它的对象里。</p><blockquote><p>在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。要实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。<br>普通的函数和操作符也可以利用右值引用操作符实现转移语义。</p></blockquote><h3 id="std-move-左值引用转右值引用"><a href="#std-move-左值引用转右值引用" class="headerlink" title="std::move 左值引用转右值引用"></a>std::move 左值引用转右值引用</h3><p>在C++11中，标准库在&lt;utility&gt;中提供了一个有用的函数std::move，std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue);</p><blockquote><ol><li>C++ 标准库使用比如vector::push_back 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 本来原意是想把参数push_back进去就行了,通过std::move，可以避免不必要的拷贝操作。</li><li>std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，<strong>没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能</strong>。</li><li>对指针类型的标准库对象并不需要这么做。</li></ol></blockquote><p><strong>用法</strong></p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;utility&gt;//std::move#include &lt;vector&gt;#include &lt;string&gt;int main(){    std::string str = &quot;Hello&quot;;    std::vector&lt;std::string&gt; v;    //调用常规的拷贝构造函数，新建字符数组，拷贝数据    v.push_back(str);    std::cout &lt;&lt; &quot;拷贝之后，str是：\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot;\n&quot;;    //调用move构造函数，掏空str，掏空后，最好不要使用str    v.push_back(std::move(str));    std::cout &lt;&lt; &quot;move之后，str是：\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot;\n&quot;;    std::cout &lt;&lt; &quot;vector的内容是：\&quot;&quot; &lt;&lt; v[0] &lt;&lt; &quot;\&quot;, \&quot;&quot; &lt;&lt; v[1] &lt;&lt; &quot;\&quot;\n&quot;;    system(&quot;pause&quot;);}</code></pre><h3 id="ref和引用-amp-的区别"><a href="#ref和引用-amp-的区别" class="headerlink" title="ref和引用&amp;的区别"></a>ref和引用&amp;的区别</h3><p> c++ 中 本身可以使用 &amp; 来实现引用 ，那为什么还会出现ref 呢？ </p><p>ref</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;void f2(int &amp;c){    c++;    cout &lt;&lt; &quot;in function c = &quot; &lt;&lt; c &lt;&lt; endl;}int main(){    int c = 10;    f2(ref(c));    cout &lt;&lt; &quot;out function c = &quot; &lt;&lt; c &lt;&lt; endl;    return 0;}</code></pre><p>&amp;</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;void f2(int &amp;c){    c++;    cout &lt;&lt; &quot;in function c = &quot; &lt;&lt; c &lt;&lt; endl;}int main(){    int c = 10;    f2(c);    cout &lt;&lt; &quot;out function c = &quot; &lt;&lt; c &lt;&lt; endl;    return 0;}</code></pre><p>结果是一样的：</p><pre><code>in function c = 11out function c = 11</code></pre><p><strong>区别在于</strong>考虑函数式编程（如std::bind）在使用时，是对参数直接拷贝，而不是引用 </p><pre><code class="c++">#include &lt;string&gt;#include &lt;iostream&gt;#include&lt;boost/function.hpp&gt;#include&lt;boost/bind.hpp&gt;void f(int &amp;a,int &amp;b,int &amp;c){    cout&lt;&lt;&quot;in function a = &quot;&lt;&lt;a&lt;&lt;&quot;  b = &quot;&lt;&lt;b&lt;&lt;&quot;  c = &quot;&lt;&lt;c&lt;&lt;endl;    a += 1;    b += 10;    c += 100;}int main(){    int n1 = 1 ,n2 = 10,n3 = 100;    function&lt;void()&gt; f1 = bind(f,n1,n2,ref(n3));    f1();    cout&lt;&lt;&quot;out function a = &quot;&lt;&lt;n1&lt;&lt;&quot;  b = &quot;&lt;&lt;n2&lt;&lt;&quot;  c = &quot;&lt;&lt;n3&lt;&lt;endl;    f1();    cout&lt;&lt;&quot;out function a = &quot;&lt;&lt;n1&lt;&lt;&quot;  b = &quot;&lt;&lt;n2&lt;&lt;&quot;  c = &quot;&lt;&lt;n3&lt;&lt;endl;    return 0;}</code></pre><p>输出：</p><pre><code>in function a = 1  b = 10  c = 100out function a = 1  b = 10  c = 200in function a = 2  b = 20  c = 200out function a = 1  b = 10  c = 300</code></pre><p>解释：使用ref实现了参数的引用（ 在用bind直接传参数时，如果不用ref时，调用函数是没有引用的 ）。</p><p> 不仅仅是在使用bind时，在使用thread进行编程时，也会发生这样的问题，thread的方法传递引用的时候，必须外层用ref来进行引用传递，否则会编译出错。 </p><pre><code class="c++">void method(int &amp; a){ a += 5;}using namespace std;int main(){    int a = 0;    thread th(method,ref(a));    th.join();    cout &lt;&lt; a &lt;&lt;endl;    //thread th2(method,a);  //去掉注释会编译出错    //th2.join();    cout &lt;&lt; a &lt;&lt;endl;    return 0;}</code></pre><h3 id="operator重载运算符"><a href="#operator重载运算符" class="headerlink" title="operator重载运算符"></a>operator重载运算符</h3><p> operator 是C++的一个关键字，它和运算符（如=、==、()）一起使用，表示一个<strong>运算符重载</strong>函数，在理解时可将operator和运算符（如operator=）视为一个函数名 。</p><p> 使用operator重载运算符，是C++扩展运算符功能的方法。使用operator扩展运算符功能的原因如下： </p><ul><li><p>使重载后的运算符的使用方法与重载前一致 </p></li><li><p>扩展运算符的功能只能通过函数的方式实现（实际上，C++中各种“功能”都是由函数实现的） </p></li></ul><p><strong>示例：</strong>重载==运算符</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;class person{private:    int age;public:    person(int nAge)    {        this-&gt;age = nAge;    }    bool operator==(const person&amp; ps)//重载==运算符    {        if (this-&gt;age == ps.age)        {            return true;        }        return false;    }};int main(){    person p1(10);    person p2(10);    if (p1 == p2)    {        cout &lt;&lt; &quot;p1和p2相等&quot; &lt;&lt; endl;    }    else    {        cout &lt;&lt; &quot;p1和p2不相等&quot; &lt;&lt; endl;    }    return 0;}//结果：p1和p2相等</code></pre><h3 id="std-for-each"><a href="#std-for-each" class="headerlink" title="std::for_each"></a>std::for_each</h3><p> for_each有三个参数，前两个参数用来确定一个区间，第三个参数则是操作方式，lambda，函数对象或者普通函数都可以充当其第三个参数 。</p><pre><code class="c++">#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;void helperFunction(string&amp; str){    str += &quot;.cpp&quot;;}void print(vector&lt;string&gt; vec){    for (vector&lt;string&gt;::iterator iter = vec.begin(); iter != vec.end(); iter++)    {        cout &lt;&lt; *iter &lt;&lt; &quot;\t&quot;;    }    cout &lt;&lt; endl;}int main(void){    string vecVal[] = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; };//string数组    vector&lt;string&gt; vec(vecVal, vecVal + 4);//数组加载到vector    print(vec);    for_each(vec.begin(), vec.end(), helperFunction);    //for_each会自动给helperFunction输入参数 *vec.begin()，（每次迭代vec.begin()++）    print(vec);    return 0;}//输出：//a       b       c       d//a.cpp   b.cpp   c.cpp   d.cpp</code></pre><p> for_each()有一个特殊的性质，那就是它能够返回其操作，利用这一特性，我们可以处理“置于该操作中的结果”直接看下面这个例子： </p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class MeanValue{private:    long num;    long sum;public:    MeanValue() : num(0), sum(0) {}//无参数的构造函数    void operator() (int elem)//重载() (int elem)    {        num++;        sum += elem;    }    operator double()//重载double    {        return static_cast&lt;double&gt;(sum) / static_cast&lt;double&gt;(num);    }};int main(){    std::vector&lt;int&gt;v1{ 1,2,3,4,5,6,7,8 };    double db = std::for_each(v1.begin(), v1.end(), MeanValue());    //for_each不断迭代向MeanValue()传递int，迭代完成后执行执行隐式的int转换到double（也被重载了）    std::cout &lt;&lt; db;    return 0;}//结果：4.5</code></pre><p>double db = std::for_each(v1.begin(), v1.end(), MeanValue());通过观看源码，我们知道for_each的返回值是其第三个参数。而我们的第三个参数明明是一个class，为什么我们可以赋值给一个double类型？</p><p>这里我们就要注意了，在MeanValue类中我们有一个特殊的重载，operator double()｛…｝ ，这个重载就是为了提供该类隐式转换为double的方法，所以我们可以将该类隐式转换为double类型。</p><h3 id="vector转list"><a href="#vector转list" class="headerlink" title="vector转list"></a>vector转list</h3><pre><code class="c++">vector&lt;Point2f&gt; point_set(SampPoints.begin(),SampPoints.end());</code></pre><h3 id="double转string"><a href="#double转string" class="headerlink" title="double转string"></a>double转string</h3><p><a href="https://www.cnblogs.com/chorulex/p/7660187.html" target="_blank" rel="noopener">参考</a></p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std;std::string DoubleToString(const double value, unsigned int precisionAfterPoint = 6){    std::ostringstream out;    // 清除默认精度    out.precision(std::numeric_limits&lt;double&gt;::digits10);    out &lt;&lt; value;    std::string res = std::move(out.str());    auto pos = res.find(&#39;.&#39;);    if (pos == std::string::npos)        return res;    auto splitLen = pos + 1 + precisionAfterPoint;    if (res.size() &lt;= splitLen)        return res;    return res.substr(0, splitLen);}int main(int argc, char* argv[]){    std::cout &lt;&lt; DoubleToString(0., 12) &lt;&lt; std::endl;    std::cout &lt;&lt; DoubleToString(0.0, 12) &lt;&lt; std::endl;    std::cout &lt;&lt; DoubleToString(.0, 12) &lt;&lt; std::endl;    std::cout &lt;&lt; DoubleToString(1.0, 12) &lt;&lt; std::endl;    std::cout &lt;&lt; DoubleToString(11234, 12) &lt;&lt; std::endl;    std::cout &lt;&lt; DoubleToString(0.12345, 12) &lt;&lt; std::endl;    std::cout &lt;&lt; DoubleToString(0.12345678, 12) &lt;&lt; std::endl;    std::cout &lt;&lt; DoubleToString(0.12345678, 9) &lt;&lt; std::endl;    std::cout &lt;&lt; DoubleToString(0.12345678, 8) &lt;&lt; std::endl;    std::cout &lt;&lt; DoubleToString(0.12345678, 6) &lt;&lt; std::endl;    return 0;}</code></pre><h3 id="std-move避免内存搬迁拷贝"><a href="#std-move避免内存搬迁拷贝" class="headerlink" title="std::move避免内存搬迁拷贝"></a>std::move避免内存搬迁拷贝</h3><ul><li>C++ 标准库使用比如<code>vector::push_back</code>等这类函数时，会对参数的对象进行复制,连数据也会复制。这就会造成对象内存的额外创建，本来原意是想把参数push_back进去就行了，通过std::move，可以避免不必要的拷贝操作。</li><li><code>std::move</code>是<strong>将对象的状态或者所有权从一个对象转移到另一个对象</strong>，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率，改善性能。</li><li>对指针类型的标准库对象并不需要这么做。</li></ul><p><strong>用法</strong></p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;string&gt;int main(){    std::string str = &quot;Hello&quot;;    std::vector&lt;std::string&gt; v;    //调用常规的拷贝构造函数，新建字符数组，拷贝数据    v.push_back(str);    std::cout &lt;&lt; &quot;push_back后，str是：\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot;\n&quot;;    //调用移动构造函数，掏空str，掏空后，最好不要使用str    v.push_back(std::move(str));    std::cout &lt;&lt; &quot;move并push_back后，str是：\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot;\n&quot;;    std::cout &lt;&lt; &quot;vrctor内容是：\&quot;&quot; &lt;&lt; v[0] &lt;&lt; &quot;\&quot;, \&quot;&quot; &lt;&lt; v[1] &lt;&lt; &quot;\&quot;\n&quot;;    return 0;}</code></pre><p>输出：</p><pre><code>push_back后，str是：&quot;Hello&quot;move并push_back后，str是：&quot;&quot;vrctor内容是：&quot;Hello&quot;, &quot;Hello&quot;</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="和-和-和-gt-的区别"><a href="#和-和-和-gt-的区别" class="headerlink" title=".和::和:和-&gt;的区别"></a>.和::和:和-&gt;的区别</h3><p>1、A.B则A为对象或者结构体；</p><p>2、A-&gt;B则A为指针，-&gt;是成员提取，A-&gt;B是提取A中的成员B，A只能是指向类、结构、联合的指针；</p><p>3、::是作用域运算符，A::B表示作用域A中的名称B，A可以是名字空间、类、结构；</p><p>4、:一般用来表示继承；</p><p><strong>.和-&gt;的区别：</strong> -&gt;是指针指向其成员的运算符 .是结构体的成员运算符。最大的区别是-&gt;前面放的是指针，而.前面跟的是结构体变量 </p><pre><code class="c++">struct A{   int a;   int b;};A *point = malloc(sizeof(struct A));//直接分配内存块，point作为A *的指针指向这个内存块point-&gt;a = 1;A object;object.a = 1;</code></pre><h3 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h3><p><strong>C++ 类定义</strong></p><p>定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。</p><p>类定义是以关键字 <strong>class</strong> 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 <strong>class</strong> 定义 Box 数据类型，如下所示</p><pre><code class="c++">class Box{   public:      double length;   // 盒子的长度      double breadth;  // 盒子的宽度      double height;   // 盒子的高度};</code></pre><p> 关键字 <strong>public</strong> 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。也可以指定类的成员为 <strong>private</strong> 或 <strong>protected</strong>。 </p><p><strong>定义 C++ 对象</strong></p><p> 类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象： </p><pre><code class="c++">Box Box1;          // 声明 Box1，类型为 BoxBox Box2;          // 声明 Box2，类型为 Box</code></pre><p> 对象 Box1 和 Box2 都有它们各自的数据成员。 </p><p><strong>访问类的成员</strong></p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;class Box{   public:      double length;   // 长度      double breadth;  // 宽度      double height;   // 高度};int main( ){   Box Box1;        // 声明 Box1，类型为 Box   Box Box2;        // 声明 Box2，类型为 Box   double volume = 0.0;     // 用于存储体积   // box 1 详述   Box1.height = 5.0;    Box1.length = 6.0;    Box1.breadth = 7.0;   // box 2 详述   Box2.height = 10.0;   Box2.length = 12.0;   Box2.breadth = 13.0;   // box 1 的体积   volume = Box1.height * Box1.length * Box1.breadth;   cout &lt;&lt; &quot;Box1 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;   // box 2 的体积   volume = Box2.height * Box2.length * Box2.breadth;   cout &lt;&lt; &quot;Box2 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;   return 0;}</code></pre><p> 当上面的代码被编译和执行时，它会产生下列结果 ：</p><pre><code>Box1 的体积：210Box2 的体积：1560</code></pre><h3 id="代码行数"><a href="#代码行数" class="headerlink" title="代码行数"></a>代码行数</h3><pre><code class="sh">find . -name &quot;*.h&quot; -or -name &quot;*.cpp&quot;|xargs wc -l</code></pre><h3 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h3><pre><code class="c++">void sum(int a,int b); //这是函数的声明void sum(int a,int b){} //这是函数定义(没有分号)void sum(int a,int b){};//也可以同时声明和定义//同时声明和定义空函数(空的构造函数和析构函数)KltHomographyInit()=default;~KltHomographyInit()=default;//=default相当于{}</code></pre><h3 id="virtual关键字"><a href="#virtual关键字" class="headerlink" title="virtual关键字"></a>virtual关键字</h3><p>在基类的成员函数前加<strong>virtual</strong>关键字，表示希望重载的成员函数，用一个 基类指针或引用  指向一个继承类对象的时候，调用一个虚函数时, 实际调用的是继承类的版本</p><h3 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h3><p>deque容器为一个给定类型的元素进行线性处理，像向量一样，它能够快速地随机访问任一个元素，并且能够高效地插入和删除容器的尾部元素。但它又与vector不同，deque支持高效插入和删除容器的头部元素，因此也叫做双端队列</p><h3 id="c-str-函数"><a href="#c-str-函数" class="headerlink" title=".c_str()函数"></a>.c_str()函数</h3><pre><code class="c++">#include &lt;iostream&gt;  #include &lt;cstring&gt;  using namespace std;int main(){      const char *c;    string s = &quot;1234&quot;;    c = s.c_str();    cout &lt;&lt; c &lt;&lt; endl;    s = &quot;abcde&quot;;    cout &lt;&lt; c &lt;&lt; endl;}</code></pre><p>输出：</p><pre><code class="c++">1234abcde</code></pre><h3 id="friend友元"><a href="#friend友元" class="headerlink" title="friend友元"></a>friend友元</h3><p>friend关键字的作用：在一个类中指明其他的类（或者）函数能够直接访问该类中的private和protected成员</p><h3 id="用class和struct关键字的区别"><a href="#用class和struct关键字的区别" class="headerlink" title="用class和struct关键字的区别"></a>用class和struct关键字的区别</h3><p>实际上，我们可以使用 class 关键字和 struct 关键字中的任意一个定义类。</p><p>唯一的一点区别就是，struct 和 class 的默认访问权限不太一样。</p><p>如果使用 struct 关键字，则定义在第一个访问说明符之前的所有成员都默认是 public 的；</p><p>但如果使用 class关键字，那么定义在第一个访问说明符之前的成员默认都是 private 的</p><h3 id="C-构造函数后加冒号"><a href="#C-构造函数后加冒号" class="headerlink" title="C++ 构造函数后加冒号"></a>C++ 构造函数后加冒号</h3><p>其实冒号后的内容是初始化成员列表，一般有三种情况：<br><strong>1、对含有对象成员的对象进行初始化</strong></p><p>例如，类line有两个私有对象成员startpoint、endpoint,line的构造函数写成：</p><pre><code class="c++">line（int sx,int sy,int ex,int ey）：startpoint（sx,sy）,endpoint（ex,ey）{……}</code></pre><p>初始化时按照类定义中对象成员的顺序分别调用各自对象的构造函数，再执行自己的构造函数<br><strong>2、对于不含对象成员的对象，初始化时也可以套用上面的格式</strong></p><p>例如，类rectangle有两个数据成员length、width,其构造函数写成：</p><pre><code class="c++">rectangle():length(1),width(2)){}rectangle(int x,int y):length(x),width(y)){}</code></pre><p><strong>3、对父类进行初始化</strong></p><p>例如，CDlgCalcDlg的父类是MFC类CDialog,其构造函数写为：</p><pre><code class="c++">CDlgCalcDlg(CWnd* pParent): CDialog(CDlgCalcDlg::IDD,pParent)</code></pre><p>其中IDD是一个枚举元素，标志对话框模板的ID<br>使用初始化成员列表对对象进行初始化，有时是必须的，有时是出于提高效率的考虑</p><h3 id="boost-function和boost-bind"><a href="#boost-function和boost-bind" class="headerlink" title="boost::function和boost::bind"></a>boost::function和boost::bind</h3><p> <a href="http://www.xumenger.com/cpp-boost-bind-function-20180612/" target="_blank" rel="noopener">http://www.xumenger.com/cpp-boost-bind-function-20180612/</a> </p><p><strong>1、boost::function</strong></p><p> boost::function是一个函数包装器，也即一个函数模板，可以用来代替拥有相同返回类型，相同参数类型，以及相同参数个数的各个不同的函数 </p><pre><code class="c++">#include&lt;boost/function.hpp&gt;#include&lt;iostream&gt;using namespace std;typedef boost::function&lt;int(int ,char)&gt; Func;int test(int num,char sign){   cout &lt;&lt; num &lt;&lt; sign &lt;&lt; endl;   return 0;}int main(){    Func f;    f = &amp;test;  //or f = test;    f(1, &#39;A&#39;);}</code></pre><p>它也可以用下面的函数指针形式实现</p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;typedef int (*Func)(int, char);int test(int num,char sign){   cout &lt;&lt; num &lt;&lt; sign &lt;&lt; endl;   return 0;}int main(){    Func f;    f = &amp;test;  //or f = test;    f(1, &#39;A&#39;);}</code></pre><p>但是为什么还要用boost::function呢？</p><blockquote><p>如果没有boost::bind，那么boost::function就什么都不是；而有了boost::bind，同一个类的不同对象可以delegate给不同的实现，从而实现不同的行为，简直就是无敌了</p></blockquote><p><strong>2、boost::bind</strong></p><p>boost::function就像C#中的delegate，可以指向任何函数，包括成员函数（这点就是普通的函数指针做不到的！）</p><p>当用bind把某个成员函数绑定到某个对象上的时候，就可以得到一个closure（闭包）</p><pre><code class="c++">#include &lt;string&gt;#include &lt;iostream&gt;#include&lt;boost/function.hpp&gt;#include&lt;boost/bind.hpp&gt;using namespace std;class Foo{    public:        void methodA() { cout &lt;&lt; &quot;Foo::methodA()&quot; &lt;&lt; endl; }        void methodInt(int a) { cout &lt;&lt; &quot;Foo::methodInt(&quot; &lt;&lt; a &lt;&lt; &quot;)&quot; &lt;&lt; endl; }        void methodString(const string &amp;str) { cout &lt;&lt; &quot;Foo::methodString(&quot; &lt;&lt; str &lt;&lt; &quot;)&quot; &lt;&lt; endl; }};class Bar{    public:        void methodB() { cout &lt;&lt; &quot;Bar::methodB()&quot; &lt;&lt; endl; }        int methodTest(int a, char b, int c)         {             cout &lt;&lt; &quot;Bar::methodTest(&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;, &quot; &lt;&lt; c &lt;&lt; &quot;)&quot; &lt;&lt; endl;            return 0;        }};int main(){    //无参数，无返回值    boost::function&lt;void()&gt; fun1;    //调用foo.methodA()    Foo foo;    fun1 = boost::bind(&amp;Foo::methodA, &amp;foo);    fun1();    //调用bar.methodB()    Bar bar;    fun1 = boost::bind(&amp;Bar::methodB, &amp;bar);    fun1();    //调用foo.methodInt(42)    fun1 = boost::bind(&amp;Foo::methodInt, &amp;foo, 42);    fun1();    //调用foo.methodString(&quot;hello&quot;)    //bind的时候直接传入实参，这不就是闭包吗    fun1 = boost::bind(&amp;Foo::methodString, &amp;foo, &quot;hello&quot;);    fun1();    cout &lt;&lt; endl;    //int参数，无返回值    boost::function&lt;void(int)&gt; fun2;    //bind的时候未传入实参，需要_1作为参数的占位    fun2 = boost::bind(&amp;Foo::methodInt, &amp;foo, _1);    fun2(100);    cout &lt;&lt; endl;    boost::function&lt;int(int, int)&gt; func3;    //bind的时候未传入实参，需要_1、_2、_3作为参数的占位    //下面传入一个实参，其他的用_n做占位符，很明显是一个闭包    func3 = boost::bind(&amp;Bar::methodTest, &amp;bar, _1, &#39;z&#39;, _2);    func3(1, 2);}</code></pre><h3 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h3><pre><code class="c++">inline int Max (int a, int b){    if(a &gt;b)        return a;    return b;}</code></pre><p>增加了 <code>inline</code>关键字的函数称为“内联函数”。内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样 </p><h3 id="VS点本地调试无法运行"><a href="#VS点本地调试无法运行" class="headerlink" title="VS点本地调试无法运行"></a>VS点本地调试无法运行</h3><p>原因是VS调试时起始目录是源文件的存放目录，而生成的exe文件在源文件目录的..\x64\Release下，如果c++程序使用相对路径，容易产生路径的错误</p><h3 id="struct和class"><a href="#struct和class" class="headerlink" title="struct和class"></a>struct和class</h3><p> C++中的struct是对C中的struct进行了扩充，所以增加了很多功能，主要的区别如下图所示： </p><p><img src="/images/C++%E5%AD%A6%E4%B9%A0/20181122191431245.png" alt="在这里插入图片描述"> </p><p> 上面罗列了在声明时的区别，在使用的过程中也有区别： </p><p> 在C中使用结构体时需要加上struct，而C++可直接使用，例如： </p><pre><code class="c++">结构体声明，C和C++使用同一个struct Student{    int  iAgeNum;    string strName;}struct  Student  stu1;    //C中使用Student    stu3;        //C++使用</code></pre><p><strong>C++中Struct与Class的区别</strong></p><p> struct默认防控属性是public的，而class默认的防控属性是private </p><pre><code class="c++">struct A{    int iNum;}class B{    int iNum;}A a;a.iNum = 2;        //没有问题，默认防控属性为publicB b;b.iNum = 2;        //编译出错，默认防控属性为private</code></pre><p> 在继承关系，同样：struct默认是public的，而class是private </p><pre><code class="c++">struct A{    int   iAnum；}struct B : A{    int   iBnum;}A a；a.iAnum = 1;    //在struct情况下是正确的，在class情况下是错误的//在struct的情况下B是默认public继承A的。如果将上面的struct改成class，那么B是private继承A的</code></pre><p> 上面的列子都是struct继承struct，class继承class，那么class与struct继承会怎样呢？ </p><p> 结论是：<strong>默认的防控属性取决于子类而不是基类</strong>，例如： </p><pre><code class="c++">struct A{};class B : A {};    //默认为private继承struct C : B{};    //默认为public继承</code></pre><h3 id="Eigen动态Matrix"><a href="#Eigen动态Matrix" class="headerlink" title="Eigen动态Matrix"></a>Eigen动态Matrix</h3><pre><code class="c++">Matrix&lt;double, 6, Dynamic, ColMajor&gt; jacobian;//数值类型为double，行数为6，Dynamic表示动态矩阵（其大小根据运算需要确定），ColMajor表示按列存储</code></pre><h3 id="cout-setf-设置输出格式"><a href="#cout-setf-设置输出格式" class="headerlink" title="cout.setf()设置输出格式"></a>cout.setf()设置输出格式</h3><p>通过flag对cout输出的格式进行调整。如 <code>ios_base::fixed</code>表示：用正常的记数方法显示浮点数(与科学计数法相对应)；<code>ios_base::floatfield</code>表示小数点后保留6位小数 。</p><p>setf()函数有两个原型：</p><pre><code class="c++">fmtflags setf(fmtflage) //第一原型fmtflags setf(fmtflags, fmtflags)  //第二原型</code></pre><p>原型一举例：</p><pre><code class="c++">cout.setf(ios_base::showpos);cout &lt;&lt; 66 &lt;&lt; endl;//输出: +66</code></pre><p>常见标志及作用：</p><table><thead><tr><th>fmtflags</th><th>作用</th></tr></thead><tbody><tr><td>boolalpha</td><td>可以使用单词”true”和”false”进行输入/输出的布尔值.</td></tr><tr><td>oct</td><td>用八进制格式显示数值.</td></tr><tr><td>dec</td><td>用十进制格式显示数值.</td></tr><tr><td>hex</td><td>用十六进制格式显示数值.</td></tr><tr><td>left</td><td>输出调整为左对齐.</td></tr><tr><td>right</td><td>输出调整为右对齐.</td></tr><tr><td>scientific</td><td>用科学记数法显示浮点数.</td></tr><tr><td>fixed</td><td>用正常的记数方法显示浮点数(与科学计数法相对应).</td></tr><tr><td>showbase</td><td>输出时显示所有数值的基数.</td></tr><tr><td>showpoint</td><td>显示小数点和额外的零，即使不需要.</td></tr><tr><td>showpos</td><td>在非负数值前面显示”＋（正号）”.</td></tr><tr><td>skipws</td><td>当从一个流进行读取时，跳过空白字符(spaces, tabs, newlines).</td></tr><tr><td>unitbuf</td><td>在每次插入以后，清空缓冲区.</td></tr><tr><td>internal</td><td>将填充字符回到符号和数值之间.</td></tr><tr><td>uppercase</td><td>以大写的形式显示科学记数法中的”e”和十六进制格式的”x”.</td></tr><tr><td>floatfield</td><td>输出时按浮点格式，默认为小数点后有6位数字</td></tr></tbody></table><p>注意这些flag加前缀，如<code>ios::fixed</code>，有的是<code>ios_base::fixed</code></p><p>举例</p><pre><code class="c++">cout.setf(ios::fixed,ios::floatfield);cout.precision(8);//正常的记数方法显示浮点数、输出是按浮点数显示，小数点精度为8//cout.precision()返回当前的浮点数输出精度值//cout.precision(val)设置浮点数输出的精度</code></pre><h3 id="chrono计时（s、ms、ns）"><a href="#chrono计时（s、ms、ns）" class="headerlink" title="chrono计时（s、ms、ns）"></a>chrono计时（s、ms、ns）</h3><pre><code class="c++">#include&lt;iostream&gt;#include &lt;chrono&gt;#include&lt;Windows.h&gt;using namespace std;class Timer {public:    static constexpr double SECONDS = 1e-9;///秒    static constexpr double MILLISECONDS = 1e-6;///毫秒    static constexpr double NANOSECONDS = 1.0;///纳秒    Timer(double scale = MILLISECONDS);//默认的时间单位是毫秒    virtual ~Timer();    void start();    double stop();private:    std::chrono::high_resolution_clock::time_point start_t;///开始计时的时间    bool started;    double scale;};int main(int argc, char * argv[]){    Timer timer1;    timer1.start();    Sleep(1000);    double time = timer1.stop();    cout &lt;&lt;&quot;持续时间：&quot;&lt;&lt; time&lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;}Timer::Timer(double scale) : started(false), scale(scale) { }Timer::~Timer() { }void Timer::start() {    started = true;    start_t = std::chrono::high_resolution_clock::now();}double Timer::stop() {    std::chrono::high_resolution_clock::time_point end_t = std::chrono::high_resolution_clock::now();    if (!started)        throw std::logic_error(&quot;[Timer] Stop called without previous start&quot;);    started = false;    std::chrono::duration&lt;double, std::nano&gt; elapsed_ns = end_t - start_t;    return elapsed_ns.count()*scale;}</code></pre><h3 id="内联函数inline-1"><a href="#内联函数inline-1" class="headerlink" title="内联函数inline"></a>内联函数inline</h3><p> inline是C++关键字，在函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为内联函数。这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题。关键字inline必须与函数定义放在一起才能使函数成为内联函数，仅仅将inline放在函数声明前面不起任何作用 </p><h3 id="push-back-和emplace-back"><a href="#push-back-和emplace-back" class="headerlink" title="push_back()和emplace_back()"></a>push_back()和emplace_back()</h3><p>push_back()函数向容器中加入一个临时对象（右值元素）时， 首先会调用构造函数生成这个对象，然后条用拷贝构造函数将这个对象放入容器中， 最后释放临时对象。但是emplace_back()函数向容器中中加入临时对象， 临时对象原地构造，没有赋值或移动的操作。</p><h2 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h2><h3 id="坐标对应关系"><a href="#坐标对应关系" class="headerlink" title="坐标对应关系"></a>坐标对应关系</h3><p><img src="/images/C++%E5%AD%A6%E4%B9%A0/image-20200108142255582.png" alt="image-20200108142255582"></p><p>行列与坐标系对应关系 </p><ul><li><strong>行rows：Y (height)</strong></li><li><strong>列cols：X (width)</strong></li></ul><p><strong>注意：</strong></p><p>在Mat类型变量访问时下标是反着写的，即：按照(y, x)的关系形式访问</p><p>示例：</p><pre><code class="c++">int main(){    Mat mat_src = Mat::eye(3, 4, CV_8UC1);    cout &lt;&lt; &quot;mat_src :&quot; &lt;&lt; endl;    cout &lt;&lt; mat_src    &lt;&lt; endl;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;Rows : &quot; &lt;&lt; mat_src.rows &lt;&lt; endl;    cout &lt;&lt; &quot;Cols : &quot; &lt;&lt; mat_src.cols &lt;&lt; endl;    //注: mat_src.at&lt;float&gt;(y, x), 下标关系为: y-x    mat_src.at&lt;float&gt;(0, 2) = 2;     mat_src.at&lt;float&gt;(2, 0) = 4;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;mat_src :&quot; &lt;&lt; endl;    cout &lt;&lt; mat_src    &lt;&lt; endl;    return 0;}</code></pre><p>输入：</p><pre><code class="yaml">mat_src :[  1,   0,   0,   0;   0,   1,   0,   0;   0,   0,   1,   0]Rows : 3Cols : 4mat_src :[  1,   0,   0,   0;   0,   1,   0,   0;   0,   0, 128,  64]</code></pre><h3 id="threshold灰度二值化"><a href="#threshold灰度二值化" class="headerlink" title="threshold灰度二值化"></a>threshold灰度二值化</h3><p>图像的二值化就是将图像上的像素点的灰度值设置为0或255，这样将使整个图像呈现出明显的黑白效果。在数字图像处理中，二值图像占有非常重要的地位，图像的二值化使图像中数据量大为减少，从而能凸显出目标的轮廓。OpenCV中提供了函数cv::threshold();</p><p><img src="/images/C++%E5%AD%A6%E4%B9%A0/20170810122723876.png" alt="img"></p><p>参数说明：</p><table><thead><tr><th>参数：</th><th>src</th><th>dst</th><th>thresh</th><th>maxval</th><th>type</th></tr></thead><tbody><tr><td>说明：</td><td>源图像</td><td>输出图像</td><td>阈值</td><td>dst图像中最大值</td><td>阈值类型</td></tr></tbody></table><ul><li><p>源图像可以为8位的灰度图，也可以为32位的彩色图像。</p></li><li><p>阈值的类型如下：</p><table><thead><tr><th>编号</th><th>阈值类型枚举</th><th>注意</th></tr></thead><tbody><tr><td>1</td><td>THRESH_BINARY</td><td></td></tr><tr><td>2</td><td>THRESH_BINARY_INV</td><td></td></tr><tr><td>3</td><td>THRESH_TRUNC</td><td></td></tr><tr><td>4</td><td>THRESH_TOZERO</td><td></td></tr><tr><td>5</td><td>THRESH_TOZERO_INV</td><td></td></tr><tr><td>6</td><td>THRESH_MASK</td><td>不支持</td></tr><tr><td>7</td><td>THRESH_OTSU</td><td>不支持32位</td></tr><tr><td>8</td><td>THRESH_TRIANGLE</td><td>不支持32位</td></tr></tbody></table><p><a href="https://blog.csdn.net/u012566751/article/details/77046445" target="_blank" rel="noopener">具体说明</a></p><p>示例代码</p><pre><code class="c++">#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;int main(){    Mat src = imread(&quot;C:\\lib\\pic\\img1.jpg&quot;);    Mat gray, binary;    cvtColor(src, gray, CV_BGR2GRAY);    int th = 100;    cv::Mat threshold1, threshold2, threshold3, threshold4, threshold5, threshold6, threshold7, threshold8;    cv::threshold(gray, threshold1, th, 255, THRESH_BINARY);    cv::threshold(gray, threshold2, th, 255, THRESH_BINARY_INV);    cv::threshold(gray, threshold3, th, 255, THRESH_TRUNC);    cv::threshold(gray, threshold4, th, 255, THRESH_TOZERO);    cv::threshold(gray, threshold5, th, 255, THRESH_TOZERO_INV);    //cv::threshold(gray, threshold6, th, 255, THRESH_MASK);    cv::threshold(gray, threshold7, th, 255, THRESH_OTSU);    cv::threshold(gray, threshold8, th, 255, THRESH_TRIANGLE);    cv::imshow(&quot;THRESH_BINARY&quot;, threshold1);    cv::imshow(&quot;THRESH_BINARY_INV&quot;, threshold2);    cv::imshow(&quot;THRESH_TRUNC&quot;, threshold3);    cv::imshow(&quot;THRESH_TOZERO&quot;, threshold4);    cv::imshow(&quot;THRESH_TOZERO_INV&quot;, threshold5);    //cv::imshow(&quot;THRESH_MASK&quot;, threshold6);    cv::imshow(&quot;THRESH_OTSU&quot;, threshold7);    cv::imshow(&quot;THRESH_TRIANGLE&quot;, threshold8);    cv::waitKey(0);    return 0;}</code></pre></li></ul><h3 id="distanceTransform距离变换函数"><a href="#distanceTransform距离变换函数" class="headerlink" title="distanceTransform距离变换函数"></a>distanceTransform距离变换函数</h3><p>OpenCV中，函数distanceTransform()用于计算图像中每一个非零点像素与其最近的零点像素之间的距离，输出的是保存每一个非零点与最近零点的距离信息；</p><p>图像上越亮的点，代表了离零点的距离越远。</p><p><strong>用途：</strong></p><p>可以根据距离变换的这个性质，经过简单的运算，用于细化字符的轮廓和查找物体质心（中心）。</p><p><strong>distanceTransform()函数的使用</strong></p><p>该函数有两个初始化API</p><pre><code class="c++">C++: void distanceTransform(InputArray src, OutputArray dst, int distanceType, int maskSize)C++: void distanceTransform(InputArray src, OutputArray dst, OutputArray labels, int distanceType, int maskSize, int labelType=DIST_LABEL_CCOMP )</code></pre><ul><li><p>参数说明<br>src – 8-bit, 单通道（二值化）输入图片。</p></li><li><p>dst – 输出结果中包含计算的距离，这是一个32-bit  float 单通道的Mat类型数组，大小与输入图片相同。</p></li><li><p>src – 8-bit, 单通道（二值化）输入图片。</p></li><li><p>dst – 输出结果中包含计算的距离，这是一个32-bit  float 单通道的Mat类型数组，大小与输入图片相同。</p></li><li><p>distanceType – 计算距离的类型，可以是 CV_DIST_L1、CV_DIST_L2 、CV_DIST_C。</p></li><li><p>maskSize – 距离变换掩码矩阵的大小，可以是</p><ol><li>3（CV_DIST_L1、 CV_DIST_L2 、CV_DIST_C）</li><li>5（CV_DIST_L2 ）</li><li>CV_DIST_MASK_PRECISE (这个只能在4参数的API中使用)</li></ol></li><li><p>labels – 可选的2D标签输出（离散 Voronoi 图），类型为 CV_32SC1 大小同输入图片。</p></li><li><p>labelType – 输出标签的类型，这里有些两种。</p></li></ul><p><strong>示例代码</strong></p><pre><code class="c++">int main(){    Mat src = imread(&quot;C:\\lib\\pic\\img5.jpg&quot;);    resize(src, src, Size(), 0.25, 0.25, 1);    imshow(&quot;src&quot;, src);    Mat bin;    cvtColor(src, bin, CV_BGR2GRAY);    threshold(bin, bin, 80, 255, CV_THRESH_BINARY);    imshow(&quot;bin&quot;, bin);    Mat Dist, Labels;    distanceTransform(bin, Dist, CV_DIST_L1, 3);    normalize(Dist, Dist, 0, 1, NORM_MINMAX);    imshow(&quot;dist1&quot;, Dist);    distanceTransform(bin, Dist, Labels, CV_DIST_L1, 3, DIST_LABEL_CCOMP);    normalize(Dist, Dist, 0, 1, NORM_MINMAX);    imshow(&quot;dist2&quot;, Dist);    imshow(&quot;labels2&quot;, Labels);    distanceTransform(bin, Dist, Labels, CV_DIST_L1, 3, DIST_LABEL_PIXEL);    normalize(Dist, Dist, 0, 1, NORM_MINMAX);    //normalize(Labels, Labels, 0, 255, NORM_MINMAX);    imshow(&quot;dist3&quot;, Dist);    imshow(&quot;labels3&quot;, Labels);    waitKey();    return 0;}</code></pre><h3 id="直线拟合fitLine"><a href="#直线拟合fitLine" class="headerlink" title="直线拟合fitLine()"></a>直线拟合fitLine()</h3><p><strong>作用：</strong>根据已知点集，拟合一条直线。</p><p><strong>函数形式：</strong></p><pre><code class="c++">  void cv::fitLine(        cv::InputArray points, // 二维点的数组或vector        cv::OutputArray line, // 输出直线,Vec4f (2d)或Vec6f (3d)的vector        int distType, // 距离类型        double param, // 距离参数        double reps, // 径向的精度参数        double aeps // 角度精度参数    );</code></pre><p><strong>参数：</strong></p><ul><li><p><strong>points</strong>：是用于拟合直线的输入点集，可以是二维点的cv::Mat数组，也可以是二维点的 vector。</p></li><li><p><strong>line</strong>：输出的直线，对于二维直线而言类型为cv::Vec4f，对于三维直线类型则是cv::Vec6f，输出参数的前半部分给出的是直线的方向（归一化向量），而后半部分给出的是直线上的一点（即通常所说的点斜式直线）。</p></li><li><p><strong>distType</strong>：距离类型，拟合直线时，要使输入点到拟合直线的距离和最小化（即下面公式中的cost代价最小化），可供选的距离类型如下表所示，ri表示的是输入的点到直线的距离。</p><p><img src="/images/C++%E5%AD%A6%E4%B9%A0/fea8769831b4789e0d6cf78cdec0c121.png" alt="img"></p></li><li><p><strong>param</strong>：距离参数，跟所选的距离类型有关，值可以设置为0，cv::fitLine()函数本身会自动选择最优化的值</p></li><li><p>参数5，6：用于表示拟合直线所需要的径向和角度精度，通常情况下两个值均被设定为0.01。</p></li></ul><p><strong>示例程序：</strong></p><pre><code class="c++">#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;int main(){    //创建一个用于绘制图像的空白图    Mat image = Mat::zeros(480, 640, CV_8UC3);    //输入拟合点    vector&lt;Point&gt; points;    points.push_back(Point(48, 58));    points.push_back(Point(105, 98));    points.push_back(Point(155, 160));    points.push_back(Point(212, 220));    points.push_back(Point(248, 260));    points.push_back(Point(320, 300));    points.push_back(Point(350, 360));    points.push_back(Point(412, 400));    //将拟合点绘制到空白图上    for (int i = 0; i &lt; points.size(); i++)    {        circle(image, points[i], 5, Scalar(0, 0, 255), 2, 8, 0);    }    Vec4f line_para;    fitLine(points, line_para, cv::DIST_L2, 0, 1e-2, 1e-2);    cout &lt;&lt; &quot;line_para = &quot; &lt;&lt; line_para &lt;&lt; std::endl;    //获取点斜式的点和斜率    Point point0;    point0.x = line_para[2];//直线上的点    point0.y = line_para[3];    double k = line_para[1] / line_para[0]; //斜率    //计算直线的端点(y = k(x - x0) + y0)    Point point1, point2;    point1.x = 48;    point1.y = k * (point1.x - point0.x) + point0.y;    point2.x = 412;    point2.y = k * (point2.x - point0.x) + point0.y;    line(image, point1, point2, cv::Scalar(0, 255, 0), 2, 8, 0);    imshow(&quot;image&quot;, image);    waitKey(0);    return 0;}</code></pre><h3 id="线段采样"><a href="#线段采样" class="headerlink" title="线段采样"></a>线段采样</h3><pre><code class="c++">//windows#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;algorithm&gt;using namespace cv;using namespace std;const size_t PatchSize = 1;//线段类型class Line{public:    Point2f spx;    Point2f epx;    double length;    list&lt;Point2f&gt; SampPoints;    Line(Point2f &amp;spx_, Point2f &amp;epx_) :spx(spx_), epx(epx_)    {        ReSampling();    }    void ReSampling()    {        SampPoints.clear();        Point2f dif = epx - spx; /// 从起点到终点的差矢量        length = sqrt(dif.x*dif.x + dif.y*dif.y);        double tan_dir = min(fabs(dif.x), fabs(dif.y)) / max(fabs(dif.x), fabs(dif.y));///角度正切（取正值）        double sin_dir = tan_dir / sqrt(1.0 + tan_dir * tan_dir);///角度正弦        double correction = 2.0 * sqrt(1.0 + sin_dir * sin_dir);///校正        size_t sampling_num = max(1.0, length / (2 * PatchSize*correction));///采样点的数量        // 采样        double x_inc = dif.x / sampling_num;        double y_inc = dif.y / sampling_num;        for (size_t i = 0; i &lt;= sampling_num; i++)        {            ///i=0时，SampPoints = spx            ///i=sampling_num时，ampPoints = epx            double samp_ix = spx.x + i * x_inc;            double samp_iy = spx.y + i * y_inc;            SampPoints.emplace_back(Point2f(samp_ix, samp_iy));        }    }};//线段集vector&lt;Line&gt; lines;int main(){    string path = &quot;C:\\Lib\\pic\\img5.jpg&quot;;    Mat image = imread(path, IMREAD_GRAYSCALE);    if (!image.data) {        printf(&quot;could not load image...\n&quot;);        return -1;    }    resize(image, image, Size(), 0.2, 0.2);    Ptr&lt;LineSegmentDetector&gt; ls = createLineSegmentDetector(LSD_REFINE_STD);    vector&lt;Vec4f&gt; lines_std;    // 检测LSD直线段    ls-&gt;detect(image, lines_std);    // 采样并存储直线段    for (auto line_std : lines_std)    {        lines.emplace_back(            Point2f(line_std[0], line_std[1]),//起点            Point2f(line_std[2], line_std[3]));//终点    }    // 画出直线段    cvtColor(image, image, CV_GRAY2RGB);    for (auto line : lines)    {        cv::line(image,            line.spx,            line.epx,            Scalar(0, 0, 200), 1, CV_AA//RGB颜色、粗细、抗锯齿        );        for (auto point : line.SampPoints)            cv::circle(image, point, 1, cv::Scalar(0, 200, 0), 1);    }    imshow(&quot;LSD&quot;, image);    cv::waitKey(0);    return 0;}</code></pre><h3 id="Sobel梯度计算"><a href="#Sobel梯度计算" class="headerlink" title="Sobel梯度计算"></a>Sobel梯度计算</h3><p><strong>内置函数计算</strong>（整张图像）</p><pre><code class="c++">#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;using namespace  std;//使用OpenCV的命名空间using namespace cv;////频道改变int main(){    //读取源影像    Mat Src = imread(&quot;C:\\lib\\pic\\img5.jpg&quot;, IMREAD_COLOR);    if (Src.empty())    {        return 0;    }    resize(Src, Src, Size(), 0.2, 0.2);    //将彩色影像转换为灰色影像    Mat Gray;    cvtColor(Src, Gray, CV_BGR2GRAY);    //X方向上边缘检测的结果    Mat XBorder, YBorder, XYBorder;    Sobel(Gray, XBorder, CV_16S, 1, 0, 3, 1.0, 0);    Sobel(Gray, YBorder, CV_16S, 0, 1, 3, 1.0, 0);    convertScaleAbs(XBorder, XBorder);    convertScaleAbs(YBorder, YBorder);    //XY方向上的因    addWeighted(XBorder, 0.5, YBorder, 0.5, 0, XYBorder);    namedWindow(&quot;Src&quot;, WINDOW_AUTOSIZE);    namedWindow(&quot;XBorder&quot;, WINDOW_AUTOSIZE);    namedWindow(&quot;YBorder&quot;, WINDOW_AUTOSIZE);    namedWindow(&quot;XYBorder&quot;, WINDOW_AUTOSIZE);    imshow(&quot;Src&quot;, Gray);    imshow(&quot;XBorder&quot;, XBorder);    imshow(&quot;YBorder&quot;, YBorder);    imshow(&quot;XYBorder&quot;, XYBorder);    waitKey(0);    return 0;}</code></pre><p><strong>单个像素梯度</strong><a href="https://blog.csdn.net/qq_37124237/article/details/82183177" target="_blank" rel="noopener">参考链接</a></p><pre><code class="c++">#include&lt;opencv2/opencv.hpp&gt;#include&lt;iostream&gt;using namespace std;using namespace cv;int main(){    Mat m_img = imread(&quot;C:\\lib\\pic\\img5.jpg&quot;);    resize(m_img, m_img, Size(), 0.2, 0.2);    //blur(m_img, m_img, Size(3, 3));    Mat src(m_img.rows, m_img.cols, CV_8UC1, Scalar(0));    cvtColor(m_img, src, CV_RGB2GRAY);//原灰度图    Mat dstImage(src.rows, src.cols, CV_8UC1, Scalar(0));//总的梯度大小    for (int i = 1; i &lt; src.rows - 1; i++)    {        for (int j = 1; j &lt; src.cols - 1; j++)        {            dstImage.data[i*dstImage.step + j] = sqrt(                (src.data[(i - 1)*src.step + j + 1]                    + 2 * src.data[i*src.step + j + 1]                    + src.data[(i + 1)*src.step + j + 1]                    - src.data[(i - 1)*src.step + j - 1]                    - 2 * src.data[i*src.step + j - 1]                    - src.data[(i + 1)*src.step + j - 1])                *                (src.data[(i - 1)*src.step + j + 1]                    + 2 * src.data[i*src.step + j + 1]                    + src.data[(i + 1)*src.step + j + 1]                    - src.data[(i - 1)*src.step + j - 1]                    - 2 * src.data[i*src.step + j - 1]                    - src.data[(i + 1)*src.step + j - 1])                +                (src.data[(i - 1)*src.step + j - 1]                    + 2 * src.data[(i - 1)*src.step + j]                    + src.data[(i - 1)*src.step + j + 1]                    - src.data[(i + 1)*src.step + j - 1]                    - 2 * src.data[(i + 1)*src.step + j]                    - src.data[(i + 1)*src.step + j + 1])                *                (src.data[(i - 1)*src.step + j - 1]                    + 2 * src.data[(i - 1)*src.step + j]                    + src.data[(i - 1)*src.step + j + 1]                    - src.data[(i + 1)*src.step + j - 1]                    - 2 * src.data[(i + 1)*src.step + j]                    - src.data[(i + 1)*src.step + j + 1]));        }    }    Mat grad_y(src.rows, src.cols, CV_8UC1, Scalar(0));    {        for (int i = 1; i &lt; src.rows - 1; i++)        {            for (int j = 1; j &lt; src.cols - 1; j++)            {                grad_y.data[i*grad_y.step + j] = abs(                    src.data[(i - 1)*src.step + j + 1]                    + 2 * src.data[i*src.step + j + 1]                    + src.data[(i + 1)*src.step + j + 1]                    - src.data[(i - 1)*src.step + j - 1]                    - 2 * src.data[i*src.step + j - 1]                    - src.data[(i + 1)*src.step + j - 1]);            }        }    }    Mat grad_x(src.rows, src.cols, CV_8UC1, Scalar(0));    {        for (int i = 1; i &lt; src.rows - 1; i++)        {            for (int j = 1; j &lt; src.cols - 1; j++)            {                grad_x.data[i*grad_x.step + j] = abs(                    src.data[(i - 1)*src.step + j - 1]                    + 2 * src.data[(i - 1)*src.step + j]                    + src.data[(i - 1)*src.step + j + 1]                    - src.data[(i + 1)*src.step + j - 1]                    - 2 * src.data[(i + 1)*src.step + j]                    - src.data[(i + 1)*src.step + j + 1]);            }        }    }    imshow(&quot;原图&quot;, src);    imshow(&quot;gradient&quot;, dstImage);    imshow(&quot;Vertical gradient&quot;, grad_y);    imshow(&quot;Horizontal gradient&quot;, grad_x);    waitKey(0);    return 0;}</code></pre><h3 id="像素读写"><a href="#像素读写" class="headerlink" title="像素读写"></a>像素读写</h3><pre><code class="c++">#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;using namespace std;using namespace cv;void salt(Mat image, int n);int main(int argv, char** argc){    Mat src;    src = imread(&quot;C:\\lib\\pic\\img5.jpg&quot;);    resize(src, src, Size(), 0.2, 0.2);    salt(src, 3000);    imshow(&quot;input&quot;, src);    waitKey(0);    return 0;}// 添加椒盐噪声void salt(Mat image, int n){    int i, j;    for (int k = 0; k &lt; n; k++) {        i = std::rand() % image.cols;        j = std::rand() % image.rows;        //像素操作--------------        if (image.type() == CV_8UC1) {            image.at&lt;uchar&gt;(j, i) = 255;        }        else if (image.type() == CV_8UC3) {            image.at&lt;Vec3b&gt;(j, i)[0] = 255;            image.at&lt;Vec3b&gt;(j, i)[1] = 255;            image.at&lt;Vec3b&gt;(j, i)[2] = 255;        }        // -----------------------    }}</code></pre><h3 id="画箭头"><a href="#画箭头" class="headerlink" title="画箭头"></a>画箭头</h3><pre><code class="c++">#include &quot;opencv2/core/core.hpp&quot;#include &quot;opencv2/highgui/highgui.hpp&quot;#include &quot;opencv2/imgproc/imgproc.hpp&quot;using namespace cv;void drawArrow(cv::Mat&amp; img, cv::Point pStart, cv::Point pEnd, int len, int alpha,    cv::Scalar&amp; color, int thickness = 1, int lintType = 8);int main(int argc, char** argv){    cv::Mat mat = imread(&quot;C:\\lib\\pic\\img5.jpg&quot;);    resize(mat, mat, Size(), 0.2, 0.2);    namedWindow(&quot;test&quot;);    imshow(&quot;test&quot;, mat);    Mat m(400, 400, CV_8UC3, Scalar(0, 0, 0));    Point pStart(380, 100), pEnd(100, 250);    Scalar lineColor(0, 255, 255);    drawArrow(m, pStart, pEnd, 10, 45, lineColor);    pStart = Point(100, 100);    pEnd = Point(320, 190);    lineColor = Scalar(0, 0, 255);    drawArrow(m, pStart, pEnd, 25, 30, lineColor, 2, CV_AA);    pStart = Point(200, 420);    pEnd = Point(370, 170);    lineColor = Scalar(255, 0, 255);    drawArrow(m, pStart, pEnd, 17, 15, lineColor, 1, 4);    imshow(&quot;draw arrow&quot;, m);    waitKey();    return 0;}void drawArrow(cv::Mat&amp; img, cv::Point pStart, cv::Point pEnd, int len, int alpha, cv::Scalar&amp; color, int thickness, int lineType){    const double PI = 3.1415926;    Point arrow;    //计算 θ 角（最简单的一种情况在下面图示中已经展示，关键在于 atan2 函数，详情见下面）       double angle = atan2((double)(pStart.y - pEnd.y), (double)(pStart.x - pEnd.x));    line(img, pStart, pEnd, color, thickness, lineType);    //计算箭角边的另一端的端点位置（上面的还是下面的要看箭头的指向，也就是pStart和pEnd的位置）     arrow.x = pEnd.x + len * cos(angle + PI * alpha / 180);    arrow.y = pEnd.y + len * sin(angle + PI * alpha / 180);    line(img, pEnd, arrow, color, thickness, lineType);    arrow.x = pEnd.x + len * cos(angle - PI * alpha / 180);    arrow.y = pEnd.y + len * sin(angle - PI * alpha / 180);    line(img, pEnd, arrow, color, thickness, lineType);}</code></pre><h3 id="两图合并显示"><a href="#两图合并显示" class="headerlink" title="两图合并显示"></a>两图合并显示</h3><pre><code class="c++">#include &lt;opencv2/opencv.hpp&gt;using namespace std;using namespace cv;void main(){    Mat img1 = imread(&quot;C:\\lib\\pic\\img5.jpg&quot;);    Mat img2 = imread(&quot;C:\\lib\\pic\\img2.jpg&quot;);    int height = img1.rows;//高度    int width1 = img1.cols;//左图宽度    int width2 = img2.cols;//右图宽度    // 将高图像等比缩放与低图像《高度》一致,（因为要左右分布）    if (img1.rows &gt; img2.rows)    {//左图更宽        height = img2.rows;        width1 = img1.cols * ((float)img2.rows / (float)img1.rows);//高度一定，保持长宽比        resize(img1, img1, Size(width1, height));    }    else if (img1.rows &lt; img2.rows)    {//右图更宽        width2 = img2.cols * ((float)img1.rows / (float)img2.rows);        resize(img2, img2, Size(width2, height));    }    //创建目标Mat    Mat img(height, width1 + width2, img1.type());    Mat r1 = img(Rect(0, 0, width1, height));//创建矩形    img1.copyTo(r1);//图像拷贝到矩形    Mat r2 = img(Rect(width1, 0, width2, height));//创建矩形    img2.copyTo(r2);//图像拷贝到矩形    imshow(&quot;des&quot;, img);    waitKey(0);}</code></pre><h3 id="显示文字"><a href="#显示文字" class="headerlink" title="显示文字"></a>显示文字</h3><h4 id="显示文字（不支持中文）"><a href="#显示文字（不支持中文）" class="headerlink" title="显示文字（不支持中文）"></a>显示文字（不支持中文）</h4><p>函数原型：</p><pre><code class="c++">void cv::putText(    cv::Mat&amp; img, // 待绘制的图像    const string&amp; text, // 待绘制的文字    cv::Point origin, // 文本框的左下角    int fontFace, // 字体 (如cv::FONT_HERSHEY_PLAIN)    double fontScale, // 尺寸因子，值越大文字越大    cv::Scalar color, // 线条的颜色（RGB）    int thickness = 1, // 线条宽度    int lineType = 8, // 线型（4邻域或8邻域，默认8邻域）    bool bottomLeftOrigin = false //true=&#39;原点在左下方&#39;，false=&#39;原点在左上方&#39;，为ture文字会倒过来);</code></pre><p>另外，我们在实际绘制文字之前，还可以使用cv::getTextSize()接口先获取待绘制文本框的大小，以方便放置文本框。具体调用形式如下：</p><pre><code class="c++">cv::Size cv::getTextSize(    const string&amp; text,    cv::Point origin,    int fontFace,    double fontScale,    int thickness,    int* baseLine);</code></pre><p>示例</p><pre><code class="c++">#include &lt;opencv2/opencv.hpp&gt;using namespace cv;using namespace std;int main(){    //创建空白图用于绘制文字    cv::Mat image = cv::Mat::zeros(cv::Size(640, 480), CV_8UC3);    //设置蓝色背景    image.setTo(cv::Scalar(100, 0, 0));    //设置绘制文本的相关参数    std::string text = &quot;Hello World!&quot;;    int font_face = cv::FONT_HERSHEY_COMPLEX;    double font_scale = 1;    int thickness = 1;    int baseline;    //获取文本框的长宽    cv::Size text_size = cv::getTextSize(text, font_face, font_scale, thickness, &amp;baseline);    //将文本框居中绘制    cv::Point origin;    origin.x = image.cols / 2 - text_size.width / 2;    origin.y = image.rows / 2 + text_size.height / 2;    origin.x = 0;    origin.y = text_size.height;    cv::putText(image, text, origin, font_face, font_scale, cv::Scalar(0, 255, 255), thickness, 8, false);    //显示绘制解果    cv::imshow(&quot;image&quot;, image;    cv::waitKey(0);    return 0;}</code></pre><h4 id="显示中文（windows）"><a href="#显示中文（windows）" class="headerlink" title="显示中文（windows）"></a>显示中文（windows）</h4><pre><code class="c++">#include &lt;opencv2/opencv.hpp&gt;#include &quot;windows.h&quot;void putTextZH(cv::Mat &amp;dst, const char* str, cv::Point org, cv::Scalar color, int fontSize,    const char *fn = &quot;Arial&quot;, bool italic = false, bool underline = false);int main(){    using namespace cv;    cv::Mat srcImage = cv::Mat(240, 320, CV_8UC3, cv::Scalar::all(0));    putTextZH(srcImage, &quot;OpenCV欢迎你&quot;, Point(0, 0), Scalar(255, 0, 0), 30, &quot;微软雅黑&quot;);    cv::imshow(&quot;显示中文&quot;, srcImage);    cv::waitKey(0);    cv::destroyAllWindows();    return 0;}void GetStringSize(HDC hDC, const char* str, int* w, int* h){    SIZE size;    GetTextExtentPoint32A(hDC, str, strlen(str), &amp;size);    if (w != 0) *w = size.cx;    if (h != 0) *h = size.cy;}void putTextZH(cv::Mat &amp;dst, const char* str, cv::Point org, cv::Scalar color, int fontSize, const char* fn, bool italic, bool underline){    CV_Assert(dst.data != 0 &amp;&amp; (dst.channels() == 1 || dst.channels() == 3));    int x, y, r, b;    if (org.x &gt; dst.cols || org.y &gt; dst.rows) return;    x = org.x &lt; 0 ? -org.x : 0;    y = org.y &lt; 0 ? -org.y : 0;    LOGFONTA lf;    lf.lfHeight = -fontSize;    lf.lfWidth = 0;    lf.lfEscapement = 0;    lf.lfOrientation = 0;    lf.lfWeight = 5;    lf.lfItalic = italic;   //斜体    lf.lfUnderline = underline; //下划线    lf.lfStrikeOut = 0;    lf.lfCharSet = DEFAULT_CHARSET;    lf.lfOutPrecision = 0;    lf.lfClipPrecision = 0;    lf.lfQuality = PROOF_QUALITY;    lf.lfPitchAndFamily = 0;    strcpy_s(lf.lfFaceName, fn);    HFONT hf = CreateFontIndirectA(&amp;lf);    HDC hDC = CreateCompatibleDC(0);    HFONT hOldFont = (HFONT)SelectObject(hDC, hf);    int strBaseW = 0, strBaseH = 0;    int singleRow = 0;    char buf[1 &lt;&lt; 12];    strcpy_s(buf, str);    char *bufT[1 &lt;&lt; 12];  // 这个用于分隔字符串后剩余的字符，可能会超出。    //处理多行    {        int nnh = 0;        int cw, ch;        const char* ln = strtok_s(buf, &quot;\n&quot;, bufT);        while (ln != 0)        {            GetStringSize(hDC, ln, &amp;cw, &amp;ch);            strBaseW = max(strBaseW, cw);            strBaseH = max(strBaseH, ch);            ln = strtok_s(0, &quot;\n&quot;, bufT);            nnh++;        }        singleRow = strBaseH;        strBaseH *= nnh;    }    if (org.x + strBaseW &lt; 0 || org.y + strBaseH &lt; 0)    {        SelectObject(hDC, hOldFont);        DeleteObject(hf);        DeleteObject(hDC);        return;    }    r = org.x + strBaseW &gt; dst.cols ? dst.cols - org.x - 1 : strBaseW - 1;    b = org.y + strBaseH &gt; dst.rows ? dst.rows - org.y - 1 : strBaseH - 1;    org.x = org.x &lt; 0 ? 0 : org.x;    org.y = org.y &lt; 0 ? 0 : org.y;    BITMAPINFO bmp = { 0 };    BITMAPINFOHEADER&amp; bih = bmp.bmiHeader;    int strDrawLineStep = strBaseW * 3 % 4 == 0 ? strBaseW * 3 : (strBaseW * 3 + 4 - ((strBaseW * 3) % 4));    bih.biSize = sizeof(BITMAPINFOHEADER);    bih.biWidth = strBaseW;    bih.biHeight = strBaseH;    bih.biPlanes = 1;    bih.biBitCount = 24;    bih.biCompression = BI_RGB;    bih.biSizeImage = strBaseH * strDrawLineStep;    bih.biClrUsed = 0;    bih.biClrImportant = 0;    void* pDibData = 0;    HBITMAP hBmp = CreateDIBSection(hDC, &amp;bmp, DIB_RGB_COLORS, &amp;pDibData, 0, 0);    CV_Assert(pDibData != 0);    HBITMAP hOldBmp = (HBITMAP)SelectObject(hDC, hBmp);    //color.val[2], color.val[1], color.val[0]    SetTextColor(hDC, RGB(255, 255, 255));    SetBkColor(hDC, 0);    //SetStretchBltMode(hDC, COLORONCOLOR);    strcpy_s(buf, str);    const char* ln = strtok_s(buf, &quot;\n&quot;, bufT);    int outTextY = 0;    while (ln != 0)    {        TextOutA(hDC, 0, outTextY, ln, strlen(ln));        outTextY += singleRow;        ln = strtok_s(0, &quot;\n&quot;, bufT);    }    uchar* dstData = (uchar*)dst.data;    int dstStep = dst.step / sizeof(dstData[0]);    unsigned char* pImg = (unsigned char*)dst.data + org.x * dst.channels() + org.y * dstStep;    unsigned char* pStr = (unsigned char*)pDibData + x * 3;    for (int tty = y; tty &lt;= b; ++tty)    {        unsigned char* subImg = pImg + (tty - y) * dstStep;        unsigned char* subStr = pStr + (strBaseH - tty - 1) * strDrawLineStep;        for (int ttx = x; ttx &lt;= r; ++ttx)        {            for (int n = 0; n &lt; dst.channels(); ++n) {                double vtxt = subStr[n] / 255.0;                int cvv = vtxt * color.val[n] + (1 - vtxt) * subImg[n];                subImg[n] = cvv &gt; 255 ? 255 : (cvv &lt; 0 ? 0 : cvv);            }            subStr += 3;            subImg += dst.channels();        }    }    SelectObject(hDC, hOldBmp);    SelectObject(hDC, hOldFont);    DeleteObject(hf);    DeleteObject(hBmp);    DeleteDC(hDC);}</code></pre><h2 id="SLAM"><a href="#SLAM" class="headerlink" title="SLAM"></a>SLAM</h2><h3 id="L-K跟踪"><a href="#L-K跟踪" class="headerlink" title="L-K跟踪"></a>L-K跟踪</h3><pre><code class="c++">//linux#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;vector&gt;#include &lt;chrono&gt;#include &lt;string&gt;using namespace cv;using namespace std;int main(){    std::string img_dir = &quot;/mnt/hgfs/dataset/EuRoC/MH_01_easy/mav0/cam0/data&quot;;    std::vector&lt;cv::String&gt; image_files;    cv::glob(img_dir, image_files);    if (image_files.empty())    {        std::cout &lt;&lt; &quot;No image files&quot; &lt;&lt; std::endl;        return 0;    }    Mat image,last_image;    list&lt; cv::Point2f &gt; keypoints;    for (size_t frame = 0; frame &lt; image_files.size(); ++frame)    {        image = cv::imread(image_files[frame]);        // 对第一帧提取FAST特征点        if(frame==0)        {            vector&lt;cv::KeyPoint&gt; kps;            cv::Ptr&lt;cv::FastFeatureDetector&gt; detector = cv::FastFeatureDetector::create();            detector-&gt;detect(image, kps);            for (auto kp:kps)                keypoints.push_back(kp.pt);            last_image = image;            continue;        }        // 对其他帧用LK跟踪特征点        vector&lt;cv::Point2f&gt; next_keypoints;        vector&lt;cv::Point2f&gt; prev_keypoints;        for (auto kp:keypoints)            prev_keypoints.push_back(kp);        vector&lt;unsigned char&gt; status;/// 点的跟踪状态        vector&lt;float&gt; error;        chrono::steady_clock::time_point t1 = chrono::steady_clock::now();        cv::calcOpticalFlowPyrLK(// LK跟踪                last_image,                image,                prev_keypoints, ///要跟踪的点                next_keypoints, ///跟踪成功的点                status,                error);        chrono::steady_clock::time_point t2 = chrono::steady_clock::now();        chrono::duration&lt;double&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;double&gt;&gt;(t2 - t1);        cout &lt;&lt; &quot;LK Flow use time：&quot; &lt;&lt; time_used.count() &lt;&lt; &quot; seconds.&quot; &lt;&lt; endl;        // 把跟丢的点删掉（跟踪成功的点）        int i = 0;        for (auto iter = keypoints.begin(); iter != keypoints.end(); i++)        {            if (status[i] == 0)///跟踪失败            {                iter = keypoints.erase(iter);///跟踪失败，就将keypoints列表中对应的元素删掉                continue;            }            *iter = next_keypoints[i];///跟踪成功，把跟踪成功的点存到keypoints列表中对应的位置上（点的位置会更新）            iter++;///（如果跟踪失败就continue了，跟踪成功才会执行到这一步）        }        cout &lt;&lt; &quot;tracked keypoints: &quot; &lt;&lt; keypoints.size() &lt;&lt; endl;        if (keypoints.size() == 0)        {            cout &lt;&lt; &quot;all keypoints are lost.&quot; &lt;&lt; endl;            break;        }        // 画出 keypoints        cv::Mat img_show = image.clone();        for (auto kp:keypoints)            cv::circle(img_show, kp, 5, cv::Scalar(0, 240, 0), 1);        cv::imshow(&quot;corners&quot;, img_show);        cv::waitKey(1);        last_image = image;    }}</code></pre><h3 id="LSD线段"><a href="#LSD线段" class="headerlink" title="LSD线段"></a>LSD线段</h3><pre><code class="c++">#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;//注意：需要opencv3.4.6以前的版本using namespace cv;using namespace std;int main(){    string path = &quot;C:\\lib\\pic\\img5.jpg&quot;;    Mat image = imread(path, IMREAD_GRAYSCALE);//注意必须指明IMREAD_GRAYSCALE，否则无法检测    //blur(image, image, Size(3, 3)); // 使用3x3内核来降噪    resize(image, image, Size(), 0.2, 0.2);    //Canny(image, image, 50, 200, 3); // Apply canny edge // Create and LSD detector with standard    /*    LSD_REFINE_NONE，没有改良的方式；    LSD_REFINE_STD，标准改良方式，将带弧度的线（拱线）拆成多个可以逼近原线段的直线度；    LSD_REFINE_ADV，进一步改良方式，计算出错误警告数量，通过增加精度，减少尺寸进一步精确直线。    */    Ptr&lt;LineSegmentDetector&gt; ls = createLineSegmentDetector(LSD_REFINE_STD);    vector&lt;Vec4f&gt; lines_std;    // 检测直线    ls-&gt;detect(image, lines_std);    // 直线叠加到图像中    Mat drawnLines(image);    ls-&gt;drawSegments(drawnLines, lines_std);    // 只画出直线    Mat only_lines(image.size(), image.type(), CV_32F);//灰度图转彩色    ls-&gt;drawSegments(only_lines, lines_std);    imshow(&quot;【包含原图】&quot;, drawnLines);    imshow(&quot;【仅直线】&quot;, only_lines);    waitKey(0);    return 0;}</code></pre><h3 id="加载图像序列并提取FAST"><a href="#加载图像序列并提取FAST" class="headerlink" title="加载图像序列并提取FAST"></a>加载图像序列并提取FAST</h3><pre><code class="c++">#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;fstream&gt;//#pragma comment( linker, &quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot; )using namespace cv;using namespace std;int main(){    std::string img_dir = &quot;D:\\SLAM\\dataset\\EuRoC\\MH_01_easy\\mav0\\cam0\\data\\*.png&quot;;    std::vector&lt;cv::String&gt; image_files;    cv::glob(img_dir, image_files);    if (image_files.size() == 0)    {        std::cout &lt;&lt; &quot;No image files&quot; &lt;&lt; std::endl;        system(&quot;pause&quot;);        return 0;    }    vector&lt;cv::KeyPoint&gt; kps;    cv::Ptr&lt;cv::FastFeatureDetector&gt; detector = cv::FastFeatureDetector::create();    for (unsigned int frame = 0; frame &lt; image_files.size(); ++frame)    {        Mat image = cv::imread(image_files[frame], IMREAD_GRAYSCALE);        detector-&gt;detect(image, kps);        cvtColor(image, image, COLOR_GRAY2RGB);        for (auto kp : kps)        {            cv::circle(image, kp.pt, 3, cv::Scalar(0, 240, 0), 1);        }        cv::imshow(&quot;corners&quot;, image);        cv::waitKey(100);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
